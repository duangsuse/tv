1
00:00:03,400 --> 00:00:04,104
陆光你说句话啊！

2
00:00:04,710 --> 00:00:07,180
排序算法，比如选择排序、冒泡排序

3
00:00:07,180 --> 00:00:10,010
是各种高校、培训班、面试题的必选项

4
00:00:10,010 --> 00:00:13,710
然而，很多人只是略能默写，分不清优劣

5
00:00:13,710 --> 00:00:16,850
对这种有趣的程序有点可惜

6
00:00:16,850 --> 00:00:19,870
小学信息技术也有Py的选择排序实现

7
00:00:19,870 --> 00:00:23,650
其实选择排序就是更易写的插入(即交换)排序

8
00:00:23,650 --> 00:00:28,620
你不用按索引读写数组、或自己处理最大值(max)的更新而已

9
00:00:28,620 --> 00:00:32,000
把数字类比成人的「高矮」乍一看利于理解

10
00:00:32,000 --> 00:00:34,450
其实反而给思索增加了难度

11
00:00:34,450 --> 00:00:37,490
人的高矮比数字的大小顺序更容易看出吗？

12
00:00:37,490 --> 00:00:42,550
这里咱用 正序(a,b) 的真假性来定义值的顺序

13
00:00:42,550 --> 00:00:47,100
(a的索引<b, 即a在b前, 默认越前越小)

14
00:00:47,100 --> 00:00:50,170
其实很多时候不是你搞不懂算法的基本原理，

15
00:00:50,170 --> 00:00:52,170
而是对数组索引不太熟，

16
00:00:52,170 --> 00:00:53,600
卡在索引计算上了

17
00:00:53,600 --> 00:00:57,700
那么直观看见算法对数组的操作过程，会不会略有俾益？

18
00:00:57,700 --> 00:01:01,390
动苏花了一天时间，写了 150 行JS代码

19
00:01:01,390 --> 00:01:05,485
四个算法指针可视化，一起看看吧

20
00:01:06,120 --> 00:01:10,850
下面名称中 a是列表,任何i 是 0~N(a)-1 中的索引号

21
00:01:10,850 --> 00:01:18,420
复习下0是第一项，如 [1,2] 长N=2 区间 0~1,即末引

22
00:01:18,420 --> 00:01:22,060
插入排序默认 i1 后(初始时 末引-i1长=0)

23
00:01:22,060 --> 00:01:23,820
的子表是有序的,

24
00:01:23,820 --> 00:01:26,840
每轮i 从(0止i1)

25
00:01:26,840 --> 00:01:29,350
把 a[i] 置为其与 a[i1] 的最大值，

26
00:01:29,350 --> 00:01:33,290
i 迭代一遍 a[i1] 就持有前部的最大值

27
00:01:33,290 --> 00:01:34,820
不会大于 i1+1

28
00:01:56,930 --> 00:02:00,590
冒泡排序可能是相当慢且不比插入简单的排序

29
00:02:00,590 --> 00:02:04,360
如你所见除了把检查的两项改从 i,i1 成相邻项

30
00:02:04,360 --> 00:02:08,120
即修改i的区间保证i-1不出界

31
00:02:08,120 --> 00:02:09,909
这个算法没有任何升级

32
00:02:32,500 --> 00:02:34,970
下面我们要看的是两个基于分治法的排序，

33
00:02:34,970 --> 00:02:37,340
分治是把数据分成几块，

34
00:02:37,340 --> 00:02:41,470
各自处理再合并的方法(有点类似 MapReduce,

35
00:02:41,470 --> 00:02:44,350
但分治不一定合并返回值)

36
00:02:44,350 --> 00:02:46,590
快速与合并排序的不同在于

37
00:02:46,590 --> 00:02:48,340
快排是先自身后子表

38
00:02:48,340 --> 00:02:49,860
而合并事如其名

39
00:02:49,860 --> 00:02:53,830
是子表先有序再把二者归为有序列

40
00:02:53,830 --> 00:02:55,540
快排以中点把列表划分

41
00:02:55,540 --> 00:02:57,900
成<它,>=它 的两部分，

42
00:02:57,900 --> 00:03:01,928
对其施用自身，直到<2项，绝对有序的情况

43
00:03:44,170 --> 00:03:48,420
合并以中点把列表分成两个子表，直到

44
00:03:48,420 --> 00:03:50,650
每层开始把自己的两列项

45
00:03:50,650 --> 00:03:53,370
按其[0]位小先移除的顺序输出，

46
00:03:53,370 --> 00:03:54,800
直到两边清空，

47
00:03:54,800 --> 00:03:56,480
所以每层的左右列

48
00:03:56,480 --> 00:03:57,839
是各自有序的

49
00:04:27,270 --> 00:04:29,250
我们知道算法复杂度是其操作数

50
00:04:29,250 --> 00:04:31,230
(如数组读写,交换其索引)

51
00:04:31,230 --> 00:04:33,210
随输入数据量的变化率，

52
00:04:33,210 --> 00:04:35,190
过于简单或冗杂的算法

53
00:04:35,190 --> 00:04:37,170
往往能轻松解决小的输入，

54
00:04:37,170 --> 00:04:39,140
可那是基于CPU本身每秒几百万条

55
00:04:39,140 --> 00:04:41,120
操作的速度，

56
00:04:41,120 --> 00:04:43,100
如果数据有个那么几MB

57
00:04:43,100 --> 00:04:45,700
(2^10 字节,整数4=2*2字节)，

58
00:04:45,700 --> 00:04:47,190
就不行辣~

59
00:04:47,190 --> 00:04:51,070
选择插入冒泡排序的复杂度都是 O(n*n) ，

60
00:04:51,070 --> 00:04:54,010
你可能好奇三者中第二层循环次数

61
00:04:54,010 --> 00:04:55,810
明明越来越小为何不算上。

62
00:04:55,810 --> 00:04:58,200
其实复杂度也只是参考

63
00:04:58,200 --> 00:05:00,950
程序执行耗时不止和输入量有关，

64
00:05:00,950 --> 00:05:03,780
所以很少算乘方级别以下的项。

65
00:05:03,780 --> 00:05:06,320
快速排序是 O(n*log2 n) ，

66
00:05:06,320 --> 00:05:08,870
第一个 n 是每层级所有子表总长，

67
00:05:08,870 --> 00:05:11,420
log 是乘方求底数，此处是中点二分的层深度，

68
00:05:11,420 --> 00:05:16,510
x=log2 n, x**2=n ；这些是理论不会就算了

69
00:05:16,510 --> 00:05:19,050
另外，规劝大家一句不要手写排序算法，

70
00:05:19,050 --> 00:05:21,000
也不要写一些和应用行为

71
00:05:21,000 --> 00:05:22,320
没直接关系(如Java.io流行的write)的代码，

72
00:05:22,320 --> 00:05:25,630
四年老程序猿告诉你，你程序再慢

73
00:05:25,630 --> 00:05:26,910
慢不过下层库，

74
00:05:26,910 --> 00:05:29,930
排版再合规再美也不会变得更快

75
00:05:29,930 --> 00:05:32,320
这是思维不是断行成诗

76
00:05:32,320 --> 00:05:34,090
所以我们要学习算法

77
00:05:34,090 --> 00:05:36,940
有更开阔的眼界未必能让你做到更多，

78
00:05:36,940 --> 00:05:38,990
但它确实能让你更少受到自满、

79
00:05:38,990 --> 00:05:40,430
虚荣这些因素的影响，

80
00:05:40,430 --> 00:05:43,570
让你能变着方法写出程序最美的版本

81
00:05:43,570 --> 00:05:48,360
是指代码和算法语义，内外都漂亮。

82
00:05:48,360 --> 00:05:51,220
当然，如果点赞过百我会更新排序篇的下一期

83
00:05:51,220 --> 00:05:52,600
包含 Shell希尔分块插入排序

84
00:05:52,600 --> 00:05:56,930
和 Python,JDK 都在用的 TimSort 预规划归并排序

