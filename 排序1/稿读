快排以中点把列表划分成<它,>=它 的两部分，并对其施用自身，直到<2项的绝对有序情况
合并以中点把列表分成两个子表，直到<2项，
每层开始把自己的两列项
按其[0]位小先移除的顺序输出，
直到两边清空，
所以每层的左右列
是各自有序的

我们知道算法复杂度是其操作数
(如数组读写,交换其索引)随输入数据量的变化率，
过于简单或冗杂的算法
往往能轻松解决小的输入，
可那是基于CPU本身每秒几百万条操作的速度，
如果数据有个那么几MB(2^10 字节,整数4=2*2字节)，
就不行辣~

选择插入冒泡排序的复杂度都是 O(n*n) ，
你可能好奇三者中第二层循环次数
明明越来越小为何不算上。
其实复杂度也只是参考
程序执行耗时不止和输入量有关，
所以很少算乘方级别以下的项。

快速排序是 O(n*log2 n) ，
第一个 n 是每层级所有子表总长，
log 是乘方求底数，此处是中点二分的层深度，
x=log2 n, x**2=n ；这些是理论不会就算了

另外，规劝大家一句不要手写排序算法，
也不要写一些和应用行为
没直接关系(如Java.io流行的write)的代码，
四年老程序猿告诉你，你程序再慢
慢不过下层库，
排版再合规再美也不会变得更快
这是思维不是断行成诗

所以我们要学习算法
有更开阔的眼界未必能让你做到更多，
但它确实能让你更少受到自满、
虚荣这些因素的影响，
让你能变着方法写出程序最美的版本
是指代码和算法语义，内外都漂亮。

当然，如果点赞过百我会更新排序篇的下一期
包含 Shell希尔分块插入排序
和 Python,JDK 都在用的 TimSort 预规划归并排序 
喜欢记得长按三连+不吐不快的弹幕，拜拜~


利用 hachiko-bapu 的 lrc_merge -d 0 sub.srt& lrc_merge -d 0 lrc -min-len 2000 将字幕末时置为其后项始时
