1
00:00:03,407 --> 00:00:04,907
陆光你说句话啊！

2
00:00:04,712 --> 00:00:06,212
排序算法，比如选择排序、冒泡排序

3
00:00:07,185 --> 00:00:08,685
是各种高校、培训班、面试题的必选项

4
00:00:10,014 --> 00:00:11,514
然而，很多人只是略能默写，分不清优劣

5
00:00:13,714 --> 00:00:15,214
对这种有趣的程序有点可惜

6
00:00:16,857 --> 00:00:18,357
小学信息技术也有Py的选择排序实现

7
00:00:19,874 --> 00:00:21,374
其实选择排序就是更易写的插入(即交换)排序

8
00:00:23,657 --> 00:00:25,157
你不用按索引读写数组、或自己处理最大值(max)的更新而已

9
00:00:28,627 --> 00:00:30,127
把数字类比成人的「高矮」乍一看利于理解

10
00:00:32,001 --> 00:00:33,501
其实反而给思索增加了难度

11
00:00:34,455 --> 00:00:35,955
人的高矮比数字的大小顺序更容易看出吗？

12
00:00:37,499 --> 00:00:38,999
这里咱用 正序(a,b) 的真假性来定义值的顺序

13
00:00:42,553 --> 00:00:44,053
(a的索引<b, 即a在b前, 默认越前越小)

14
00:00:47,104 --> 00:00:49,204
其实很多时候不是你搞不懂算法的基本原理，

15
00:00:50,178 --> 00:00:51,404
而是对数组索引不太熟，

16
00:00:52,171 --> 00:00:53,604
卡在索引计算上了

17
00:00:53,606 --> 00:00:55,106
那么直观看见算法对数组的操作过程，会不会略有俾益？

18
00:00:57,708 --> 00:00:59,208
动苏花了一天时间，写了 150 行JS代码

19
00:01:01,397 --> 00:01:02,897
四个算法指针可视化，一起看看吧

20
00:01:06,126 --> 00:01:07,626
下面名称中 a是列表,任何i 是 0~N(a)-1 中的索引号

21
00:01:10,858 --> 00:01:12,358
复习下0是第一项，如 [1,2] 长N=2 区间 0~1,即末引

22
00:01:18,429 --> 00:01:19,929
插入排序默认 i1 后(初始时 末引-i1长=0)

23
00:01:22,061 --> 00:01:23,561
的子表是有序的,

24
00:01:23,822 --> 00:01:25,322
每轮i 从(0止i1)

25
00:01:26,849 --> 00:01:28,349
把 a[i] 置为其与 a[i1] 的最大值，

26
00:01:29,359 --> 00:01:30,859
i 迭代一遍 a[i1] 就是前部的最大值

27
00:01:33,294 --> 00:01:34,794
不会大于 i1+1

28
00:01:56,940 --> 00:01:58,440
冒泡排序可能是相当慢且不比插入简单的排序

29
00:02:00,596 --> 00:02:02,096
如你所见除了把检查的两项改从 i,i1 成相邻项

30
00:02:04,368 --> 00:02:05,868
即修改i的区间保证i-1不出界

31
00:02:08,121 --> 00:02:09,621
这个算法没有任何升级

32
00:02:32,508 --> 00:02:34,875
下面我们要看的是两个基于分治法的排序，

33
00:02:34,975 --> 00:02:37,342
分治是把数据分成几块，

34
00:02:37,343 --> 00:02:38,843
各自处理再合并的方法(有点类似 MapReduce,

35
00:02:41,479 --> 00:02:42,979
但分治不一定合并返回值)

36
00:02:44,355 --> 00:02:45,855
快速与合并排序的不同在于

37
00:02:46,593 --> 00:02:48,093
快排是先自身后子表

38
00:02:48,347 --> 00:02:49,847
而合并事如其名

39
00:02:49,860 --> 00:02:51,360
是子表先有序再把二者归为有序列

40
00:02:53,830 --> 00:02:55,330
快排以中点把列表划分

41
00:02:55,549 --> 00:02:57,049
成<它,>=它 的两部分

42
00:02:57,902 --> 00:02:59,402
对其施用自身，直到<2项的绝对有序情况

43
00:03:44,178 --> 00:03:45,540
合并以中点把列表分成两个子表，直到<2项，

44
00:03:48,429 --> 00:03:48,017
每层开始把自己的两列项

45
00:03:50,650 --> 00:03:50,494
按其[0]位小先移除的顺序输出，

46
00:03:53,379 --> 00:03:52,971
直到两边清空，

47
00:03:54,802 --> 00:03:55,448
所以每层的左右列

48
00:03:56,482 --> 00:03:57,925
是各自有序的

49
00:04:27,275 --> 00:04:29,154
我们知道算法复杂度是其操作数

50
00:04:29,254 --> 00:04:31,133
(如数组读写,交换其索引)

51
00:04:31,233 --> 00:04:33,112
随输入数据量的变化率，

52
00:04:33,212 --> 00:04:35,091
过于简单或冗杂的算法

53
00:04:35,191 --> 00:04:37,070
往往能轻松解决小的输入，

54
00:04:37,170 --> 00:04:39,049
可那是基于CPU本身每秒几百万条

55
00:04:39,149 --> 00:04:41,028
操作的速度，

56
00:04:41,128 --> 00:04:43,007
如果数据有个那么几MB

57
00:04:43,107 --> 00:04:44,986
(2^10 字节,整数4=2*2字节)，

58
00:04:45,706 --> 00:04:46,965
就不行辣~

59
00:04:47,197 --> 00:04:49,848
选择插入冒泡排序的复杂度都是 O(n*n) ，

60
00:04:51,077 --> 00:04:52,599
你可能好奇三者中第二层循环次数

61
00:04:54,017 --> 00:04:55,350
明明越来越小为何不算上。

62
00:04:55,819 --> 00:04:58,101
其实复杂度也只是参考

63
00:04:58,201 --> 00:05:00,852
程序执行耗时不止和输入量有关，

64
00:05:00,952 --> 00:05:03,603
所以很少算乘方级别以下的项。

65
00:05:03,783 --> 00:05:06,229
快速排序是 O(n*log2 n) ，

66
00:05:06,329 --> 00:05:08,775
第一个 n 是每层级所有子表总长，

67
00:05:08,875 --> 00:05:11,321
log 是乘方求底数，此处是中点二分的层深度，

68
00:05:11,421 --> 00:05:16,413
x=log2 n, x**2=n ；这些是理论不会就算了

69
00:05:16,513 --> 00:05:18,959
另外，规劝大家一句不要手写排序算法，

70
00:05:19,059 --> 00:05:21,505
也不要写一些和应用行为

71
00:05:21,008 --> 00:05:24,051
没直接关系(如Java.io流行的write)的代码，

72
00:05:22,327 --> 00:05:26,597
四年老程序猿告诉你，你程序再慢

73
00:05:25,637 --> 00:05:29,143
慢不过下层库，

74
00:05:26,916 --> 00:05:31,689
排版再合规再美也不会变得更快

75
00:05:29,930 --> 00:05:34,235
这是思维不是断行成诗

76
00:05:32,327 --> 00:05:36,781
所以我们要学习算法

77
00:05:34,094 --> 00:05:36,849
有更开阔的眼界未必能让你做到更多，

78
00:05:36,949 --> 00:05:39,704
但它确实能让你更少受到自满、

79
00:05:38,995 --> 00:05:42,559
虚荣这些因素的影响，

80
00:05:40,439 --> 00:05:45,414
让你能变着方法写出程序最美的版本

81
00:05:43,571 --> 00:05:48,269
是指代码和算法语义，内外都漂亮。

82
00:05:48,369 --> 00:05:51,124
当然，如果点赞过百我会更新排序篇的下一期

83
00:05:51,224 --> 00:05:53,979
包含 Shell希尔分块插入排序

84
00:05:52,601 --> 00:05:56,834
和 Python,JDK 都在用的 TimSort 预规划归并排序

85
00:05:56,934 --> 00:05:59,689
喜欢记得长按三连+不吐不快的弹幕，拜拜~

