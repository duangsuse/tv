非常实用的硬核算法；5G的编码工具；每次听歌用到3次
声波(PCM)、wav,mp3 文件比这复杂些，但原理完全一样

这是什么技术呢？傅里叶变换。给你一束白光，它能让你看清色谱里每波长的能量相等；给你杯鸡尾酒，能知道这五彩斑斓是什么构成的，进而统计、滤波、重混……

声音有音高和响度，而音色是振动的模式，振动像画圆480度，周期往复。然而，音高-响度 其实是音色的一部分，直接对应 频率-震幅 ；正如乐曲里尖锐和低沉 共同构成[某片时间的音乐]，都是乐的可调成分、分量(compoment)

适用于(+-)y部分的乘法(Gain)被用于调响度，+则用于混音，这些计算在2D像素图上也能用，它们被称为『信号处理』， 但音高怎么调呢？靠加速吗？

FT就是把一条线(也即波,函数,信号,点值式)，变成许多“不同频率”线的叠加，一个多项式。 项数=频率数，系数=频的振幅，系数大=幅大=对还原信号更重要
这就可以做图像柔化、音频压缩和均衡器，变声器，音乐可视化，因为你能只对低频的信号 压低或提高、右移；还能调鸡尾酒（啊不

频谱是以1周期 T=2pi 为单位，不是随随便便都叫同1频率k (亦作w)
我们看 f(x)=sin(T*x 1)+sin(T*x 3) ，对应频幅谱 F(k)=1/N int_0^N dt sin(T*t k) f(t) 如N=5,d=(1/100)~1
1/N 是说某1刻"f(t)" 由N个频率相加=1.0 ，积分=迭代d变量(.001~1),求和

没错"time"t=x ,一般t=0~1.0 ，非常适合描述运动模式和速率，但你把线视作一堆散点，算式对了 区间不是0~1结果也相同
sin和f于(t=0~N) 若以这俩线乘法“相关”再求和，正负峰-谷会互相抵销为0，只有频率对才会“共振”，余下它在k=3时的振幅

这是傅里叶级数 e^T*tk ，e是一个复数 cos+jsin ，算式含(j=-1开方) 代表它是复数、虚数，复数乘法的物理意义是2D旋转(缓存了其系数)，好像箭头 I(0,1) 顺时针转成圆，
然后你还原 f(t)=int_0^频数 dk F(k)*e^-T*tk ，这儿只有e^符号相反，它是取共轭复数(conj) 即相反向量，cos(+-) 振幅是不变的，sin(+-) 角度必须反转。 频谱图哪来的角度？因为单纯的e^次数 只能表示频率，不能包含相位(phase)。

FT可以频谱化一切现实波形，通过叠加小波逼近尖锐、不规则的锯齿波，但这会损失时差信息。没错，音乐动效、频谱图并不是无损的，靠 震幅n1 sin(k1*T x)+.. 不能还原波形
相同的形状，时间有点偏差，在这个算式里会让震幅变散。 但如果我们用不同的2pi倍的“转速”把f(t)缠绕在0点，它会扭成花而互相抵消，除非“共振”0点转0 6点转6，正好在数轴某侧画成圆，就量出震幅和向量角 相位，也就是正反f(t)F(k)里负号的来源
当然偶函数(中心对称如cos)所有频的相位都是0，然后sin线是关于x轴对称的(负频率)，FFT也是基于此二分优化。窗口大小都是2的次方，如512=2^9

至于不周期=周期无限长，和“无限(频谱宽)”个小波叠成方波，是什么关系，Sigma和int(求有限和,积无尽分割)又是啥关系，就不必理解了。离散是被“仅N关键帧”的连续，它比连续好用的多且完全等效
伯克利大学，也即著名BSD操作系统的软工名校出版的一本Python数学方法里，仅用2页就讲完了FT和FFT的正反变换，它没有探讨积分是什么，只是把信号分N=1/dt 格，然后用k不同的N点sin波，求复数点积

然后多项式求值 k1*f(1)+k2*f(2) 也叫向量点乘(dot)或内积，一种“基” 正交=垂直=积非0 啊垂直于平面是叉乘(外积 yz -xz xy)  (AB)正交=Ai*Bj是 1若(i=j)否则0

点乘不是卷积，不需要先取2次T(转-180),即ij翻转；卷积(convolve)核上你要应用给最左项的乘数，因为窗口滑移产生重叠(结果也窄1/2个核)，实际该给最右项

import scipy.signal as S
K=np.array([1]*4).reshape((2,2))
I=np.arange(1,10).reshape((3,3)) #linspace(1,10, 10)#步长10/1
S.convolve2d(I,K, "valid")

