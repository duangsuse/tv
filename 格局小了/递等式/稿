格局小了[递等式]大学C语言折腾一年的运算符是咋回事？用JS做了才知道！

大学有一门课程非常神奇，叫编译原理；著名的某某教授就出自此科，啊这是会教授人的还是会卖弄文采，误人子弟的我就不吐槽了

这期视频面向入门者。你可能觉得一上来就学写计算器有点夸张，但好好想想，首先没有什么比实际应用更贴切、更适合学习，再者，哪怕你现在不懂这门语言的语法，写完这个项目不也就明白了吗？

大家入门时可能写过计算器，不过大多是记住一个数，然后告诉你要把它加减乘除另一个数，把记住的数改一下的那种计算器；它会把 `1+2*3` 算成 `3*3=9` 啊，我今天告诉你另一种方法，逆波兰算符重排

用这种方法把 `1+2*3` 变成 `1 2 + 3 *` 后利用一个栈，遇见数字就添加、遇见算符就添加 最近添的两个数 的+-*/结果，注意这个逆序式它没更改数字的顺序啊，算法过程我不赘述

那怎么把 "1+2*3" 变成列表呢，我们用正则表达式切分；然后把这堆数字和符号喂给我们的算法，得到逆序式，然后用栈去化简、收纳这个算式，得到结果 6

你可能觉得，哇好厉害，但更厉害的还在后面。小学数学会有一大堆四则计算要你写出过程，而你一看哇有能给过程的计算器居然收费，要是那时候有人做就好了

自己动手丰衣足食。其实我们在逆序式执行了计算的每一步，添加一个函数调用，把当前剩余栈以求数值外的另一种方式收纳，把它化为中缀式，显示出来就行了

看起来这个归纳函数和刚才不同，但我们对算术式的处理方法一样，都是把每个+-*/ 节点、每个字面量变成一个值，比如数值或文本


现在的收纳两边都同是数值类型，并且一定是子项先求值，那 true?print("a"):print("B") 会只输出 a 吗？ false && print("B") 工作正常吗？不。第一个先化简到 true?undef:undef ，此时两个输出函数都已经调用了，但只有一个的结果有被用到、只有第一个的输出是我们想要的

那 q? a:b 三元表达式咋整呢？如果对栈元素还是只区分单项或算符，是做不到的。我弄出了一个超离于二参运算之外，并且支持求值过程的模型，称作 tvr 模型，t是常量如 运算符号、v是子项、r是结果。
a+b 就是 t[0](v(1),v(2))  ，它不 return ，而是调用 r(结果) ，把结果赋值到上层树，比如 `(1+2)*3` 变 `(3)*3` ，从而允许显示求值步骤

比如 a=2; 1+a，+的左侧 v(1) 是个t=1的调用，t 是常量无需重写，就不调用 r 也不显示此步骤；而右侧 v(2) 是t="a" 的调用， r(作用域["a"]=2) ，这就有了各种语法树节点和执行序

我能调用一个函数型的值 (true? print:alert)("hello") ，但我能让 str.length 里 "length" 不是一个可求值的节点，而作为常量保存吗？不能，因为刚刚的树遍历，只有算符和俩子节点、只有完整求值，是不能选择性执行，或者对节点上的不同变量有另外解释的

tvr 是一个面向 S-表达式的求值基本方法，它需要先转化成嵌套列表，不能像刚才那样用作逆波兰的栈然后再每步，把整体显示成中缀；或许对于 `f("")` 即 `"" f 1 ()` 或 `o.f("")` 即 `o "" f 1 .()` 这两种调用法(等于N参运算)可以用栈上收纳N=1次的方法求值各参数，这也是JVM的方法，但它必须是求值的，不能做 q? a:b 的部分求值；所以我们有个中间处理会把 q?a:b 变成 (? q a b) 的可嵌套列表，f("") 变成 (call f "") 的列表形式

那么在 tvr 所需的输入结构上，构造它的方法和我第一次讲的栈求值法一样，只是为兼容 q?a:b -> (q ? a b) 我们要对 ? 算符的特殊右项进行一个 [a,b] 数组铺平处理，那怎么区分它和 JSON []值 呢，动态设置 it.flat="," 属性就OK 了，如果是 Java 可能就要建一个子类型用 instanceof ，强力推荐利用类型去区分；这个右项怎么来的待会讲。


我有个好玩的，刚才我们的单项被 parseInt 解析，但其实 JSON.parse("1")==1 也能解析数值啊，那我再加一个 obj.key 点号访问符，就能 "helo".length==4 , {a:1}.a+2==3 ，酷吗？向正常编程语言靠近一步了

但当你再去 0.1+1 时就GG 了，不要说小苏啊让我改改正则表达式，问题不止这个，还有 {a:1.0}.a , "hello." 这些都是合法 JSON ；JS 的话 (.5 + 1.) 都是允许的，你用正则切了看看？

它还有个问题，就是 obj.1 明显是错的，它不能在读取时立刻发现；虽然这不影响，但不优雅性真的是可以说明有些潜在问题的

刚刚我们对输入应用正则切分，我称为模糊解析；因为它无视任何上下文，不能处理相同字符的依地意义不同，双引号里的 +-. 这些还是运算符吗？所以我们要依据上文，来判断字符的含义，但怎么做。很多人卡这了


我有个主意， 1.0 和 (1.为负) 怎么区分？是不是可以按 . 后面是不是数字？那能不能把输入切分为 . 前、 . 后两部分，前部已经读完、含义已经确定，点后分情况理解是访问还是个小数？

那为避免 (1.1.减1)==0.1 这种脑残写法可不可以直接把 .号后才做的切分提到这个数的第一位，第一个 [0-9] 的字符就知道是整数或小数，不是个变量名？所以你现在知道为什么命名不能是 1号, 2分 这样的数字前缀了，实在是于人于机难以阅读

我们把输入包在一种叫『字符流』的东西里，进行分解；这个设计我不展开称述，你知道JS不区分单个字符和字符串，所以我这个情况合并也OK就行

这里的流和迭代器之类不一样，如果你要读取 "123a" 里的数字，用迭代器 next()=="a" 时你才知道数字部分完了，但 "a" 也消耗了，下次就读取不到

那怎么在流上读取 "你好世界" ? 这里就体现流对职责范围拆分的能力，先定义个程序 (str,N=str.length)=>s(N)==str? s(-N): noRead

我们测试几个输入，会发现失败的地方是不一样的；编译器报错行号是不是一样原理呢。

你肯定想问，那小苏，这和点运算符有啥关系呢？

如果说 (1 in nums) 里 in 只是要留空格的特殊算符，  . 和 +- 这些绝对是不一样的，加减右边是数字或括号，它的右边是一个名字；可不可以说预读、消耗这个流的前缀的过程，是受当前算符是 +- 还是 .key 这些算符种类的影响的；那是不是也能说 q? (a:b) 的问号右边是种特殊的:切分语法


当然也有人认为它本质不同，因此把它作为 +- 表达式单项 的组合，左递归读取，只要不嫌代码多都可以；左递归 这个我不展开。用动苏的方法你不需要这些有的没的，咱不图啥规范，啊咱就图个乐呵

我在刚刚我们的 "你好"+"世界" 中间插了一个东西，一个加号；你好是第0项，偶数，1项 +是奇数，2项又是偶数 ，它现在是一个以加减乘除切分的列表，我们称中缀链

那刚说的区分点号呢，程序是 x=atom(s); while((o=opr(s) )){x=o.join(x, o.right(s) )} ，其中x是单项o是中缀，一旦出现中间符是不是立刻读下项，否则就终止？而右边下项的语法是 o 决定的，现在我们就能区分 123.0 和 a+1, a.length 的不同了，当然 o[k], o.f(x1) 这些也能解析，这里不展开讲

我们把刚才自己负责判断新项是算符还是单项的函数，嵌入进来，因为 opr 解析器的结果包含了优先级信息；然后再用栈执行，试试是不是恢复了用正则切时的功能

这个 x 的实现，我毕竟不可能在这教大家写JSON解析器，那就是一个以n项流前缀，尝试 JSON.parse 直至得到结尾位置的设计，省代码量
o 的实现就是一个单字符在不在 "+-*/."
.name 的实现我也不用while，就是 /(\w+)/ 的正则匹配，复用刚才 JSON前缀尝试法

同样是喂给逆波兰重排一堆数字符号，直到输入结尾，现在我们是不是有理有据了；从文件顶端，知道每个部分出现的规律，而不是散乱的一堆词条、字面量，这就是形式化语法；来上文本框试试战利品。


算符优先级和流，引入的原因我都给大家讲了，

为1+(2*3)引入逆波兰&栈，为显示计算步骤引入栈的中缀转化，为区分 1.2 和 {a:1}.a 引入流读取
为支持 q?a:b, a&&b 类运算的部分求值引入 tvr 模型，为让 q ? (a:b) 有 tvr 支持、其右项展开为 [q ? a b] 引入栈的嵌套表转化

有些知识背景的人可能觉得很奇怪。用过 S-表达式 的人肯定知道它的语序是算符在前参数随后，但我的语序是 a[1] 是 +-? "()" 这些，主要是为了输出时方便，而且 [fn,"()",...arg] 和 [obj,".()",fn,...arg] 也是很符合直觉的

关于算符链的有些做法我自己也拿不准，比如+-*/ 的我都可以只储存它们拼合两项的方法而不是名字，比如 ',' 逗号是不是一种低优先级的算符，我为代码简洁性加上了，因为这次有中间处理是否是 flat 列表，就用同级算符 a+b+c=+abc 铺平做了，在 f(a), f(a,b) 调用里它其实有混淆单多项的嫌疑，不过Py和Lua 其实都爱混淆这些；
不过 !q 和 Kotlin 里 x!! 的后、前缀运算符优先级高于中缀，而不应该作为算符链上的元素，这点很符合直觉；然后逆波兰不支持同符号左右优先级，因为它不会重排参数；但利用同级铺平我们可以从右边计算 2**3**2=2**9=512 ；典型的 1+1>2 合作共赢

我勉强做了调用 f(x) 语法的解析，但真的不想给大家引入 '('... ')' 这种对应的解析模式，干脆把括号去掉 f x ,  f.call 1, 2 ；它们都是基于运算符特殊右项的读法，基于逗号与空 表达式

没错，它的优先级高于逗号，但右边是表达式；这样就能支持 f1 f(a,b), c 这样的语法；别忘了 q?a:b 三项都是表达式，平行的

f.run 1, 2+3 和 f.run+1 看起来很难区分，其实就看 run 后第一项是不是单项、括号， +1 的这种情况肯定就是空表达式了，那语义就是 f的 getRun() 属性或者无参数 run() 方法

递归下降法是一种利用了程序流与输入流对仗性的，非常优雅且高性能的解析器算法；一些人觉得它不好是因为不会用它，是因为对短代码有歧视，看不起行号少描述利落的

所以作为一个天天和编程语言打交道的人，话都说不利索很骄傲咯？

比如说 PEG.js 吧，到处弄 _=whitespace 跳空格规则，运算符优先级全靠左递归，语法规则写得就跟啥一样，喜欢才奇怪了；那我们该怎么处理空白和注释呢？

给 feed 加个过滤流，wsFeed(feed("  1")) ，它在每次读取前跳过空白和注释前缀，但这样如果我是在字符串内部 不能跳怎么办呢？
无分词器的好处来了，解析器可以直接和流共享当前词条类型，如果不为0 就暂停跳空格；当然这次我们利用 slicerP 解析值、和.号成员名，不是逐字符 (内可空格)，
不需要展开谈 wsFeed 带来的另一些红利，比如高亮和代码美化所需的完整解析、按{}增量解析等，一句话，简简单单30行，囊括从语言设计到解释器、到IDE的完整流程

一些人喜欢在知乎上吹要什么大公司、30人团队去研发，拜托，那你要随意跨界发表言论，也别拿没钱当借口好吗？说的好像你找几个大教授、中科院研究员就能给你解决了一样。你要是不动脑想啊，100个人还是玩具状态，成天整公关炒作，咱能不弄这些无聊的吗？

真正的能力不是能解决很多问题，而是时刻看清自己最初的问题。

在实现了基本运算与判断后，我们依赖JS的变量替换定义个阶乘函数；好

最后我们把 JS 的所有运算符给这门语言加上，秀一下。你学会了吗？


咳。彩蛋

如果我们给 JVM 做这个编译器，首先 q?1+2:puts(3) 要翻译成 q; br.not b; 1 2 + br c; :b 3 puts 1 () :c 这么一个带跳转的指令序列，函数调用也带参数数目，&& || 同理；它和我们最开始的逆波兰不同，得有参数数目和跳转指令

这个跳转具体是怎么实现。这里数据和程序是混合的，理论优雅，你弄个常量编号化也没区别。比如 (1 2 + br c) 是 4项，那 br.not 4 就可以连接到 puts 1 了；同理 br c (3 puts 1 ()) 是c=3项，能跳到程序结尾；我们算每部分的长度，这也是 Lua 的方法

对于复杂点的代码生成器，就有一个回填链表； a->b 里所有 a ; 再有 b->c 的情况下最后都被填入c的偏移量； while 可以 break 可以 continue 对吧，只有 break 的地址是未知的，if else 和刚才 q?a:b 也是只有结尾不知道，所以只用记一个 是从哪跳；那 return throw 呢？不巧它们都是独立于控制流，利用调用栈信息的，和编译原理关系不大

嗯 Kotlin 里 break@label, JS 的 out:while{break out} 这些都是扩展的，Lua 语法不支持，来源地址列表 的性质不变

但还有个重要问题， Java 是强类型语言，它的 +-*/ 都是 iadd, lsub 的这种带类型操作；这就不得不牵扯到类型系统，可我的彩蛋偏偏不用静态类型，试问动态语言有类型吗？有，不过在运行时，而且区分不强。

类型检查器、类型约束不过是在编译期以一种受限的形式做计算，而如果我们能在编译期平权的做计算、代码生成；编译本该是解释的优化，而不是分界。

我们知道好的程序拥有足够抽象性，它在任何地方都是可以运行的，为什么不把运行代码片段收集到的信息，用来生成代码呢？你可能觉得我没在静态分析、混淆执行和编译啊，可我写个解释器顺带编译能力，它不香吗？

比如 fn add=a+b ，某次我 add(1,2L) ，那我在运行时知道是 int+long ，自动变成 ladd(i2l(a), b) 行不行？而这个 ladd 有两个语义，它可以仅仅做宽整数加法，也可以顺带生成对 ladd 指令的调用

add(IL) $0 !L $1 +L ret

边解释、边编译，生成同名的一大堆重载方法，计划通。

什么你说 Listener 这些匿名子类怎么办？复制作用域(现仅全局表)，用 Proxy 接受参数啊

不过这样的问题就是不能遍历所有程序分支，其功能像代码覆盖率测试。所以你们看到了，类型系统进行静态的符号化(部分)执行，虽然鸡肋，还是有必要性的



// 取材 scan_ops.js, ops.js , tvr 求值模型

我和我为逆波兰的被动接项性争论了很久，最好的例子是 Fold cur=0; atom_op[cur](s); s^=1 然后结束时 if(cur!=0)throw err ；一致以为它结合 Join 应该很妙，但它结合的其实是 Repeat(atom|op) 因为 Join 知道 cur 是单项还是符，而且与及早查错的观念背道而驰

而它与 Join 的结合，需要中缀算符的信息，就得交给 fold,fold_sep 两个归纳器；但最后又只能返回第一项的流归纳结果，可以说根本没法复用这个链结构，果然还是支持特殊右项的方法好；而 , 号也不是算符， var a,b 和 op(a,b) 里逗号内项不同；嘛，如果利用 a+b+c 相同算符参数合并，也不是不可以
