# 苏算法[kD树]2D点最近邻算法，kNN和游戏碰撞检测都必要？

关于 DOM 了解比较深的人应该知道 `e.closest(css)` 和 `doc.elementFromPoint(x,y)` 方法，给定一个点，我们今天来看看它背后的二分搜索树-k维散点树

其实 e.closest 是指父节点链而非x,y值上，哈被骗了吧？不过这次的实例都是 JS 编写，我们会自己实现一个真正意义上的 `t.closest(e)` ，对H5游戏设计必不可少，优化对JS这种本来效率就不高的语言挺重要的

引入问题：我有三个点，我给你它们位置的序列

三点的位置是不断变动的，如果某次有两点的距离<l ，告诉我它们的编号，我把它们俩推开，可以构造一个萤火虫的效果

或许你可以尝试所有点的配对，但这太慢了——每点和另外 N-1 点尝试，基本上 O(n**2) 复杂度，我们耗光了整个搜索空间(全组合)，比选择排序还慢；今天我要教的就是一种类似二分查找的二叉树BST搜索结构，可以认为它是>1维点集上普通BST划分法扩充后的特例

最好的解法显然是先过滤位置变动极小的点，对运动了的点与它的最近邻判定碰撞，下次遇到它邻居就略过

那物理碰撞咋整呢？没有很好的方法把外包矩形区的宽高编码进点里，但无论是方是圆，给定中心点和最近一点都很容易确定它和另一个图形间的距离是否碰撞；关键不是在矩形区，而在最近点间的关系

比如我们可以把圆表示为两个点O,A，如果圆心的最近点不是A 而是X，那它和X 碰撞、正方形同理；那么我们怎么解决点集最近邻呢？

在正式讲解 kD k维切分搜索树前我想先引入一种不需要数学知识的前置算法，

这里有一个鼠标的黑圆，上面有个红圆，角落有个绿的；你觉得我最可能和谁碰撞？红的对吧

所以我们把矩形区切成几等分，比如可以按符号来分，但一个点有两个数，我们就先按x来分，构成几个 SortedSet ，再按 y 分，比如分开四个象限，最后才是那个x,y范围的点集；这个切分是不是像 Trie? 它们的相似仅止于此。

当某一点移动时，比如y变了，我们看它有没有突破那个范围，如果有就删掉再交给这个 Set 的父级整个重划分 到相邻Set，这个过程是浅层的x优先；始终把点集合x,y均分为多个矩形区；如果每次移动的只有玩家，那它就能剪枝掉他与另外3大块里所有点的碰撞测试，很简单吧？我们实现下

我们可以无限地加深这个范围分叉树，从而减少二项距离排序开销，但终究它还是有些缺陷的；我们的划分没有几何意义，也看不入一些大佬的法眼，轮到 kD-Tree 出场了



人物原地不动，理论上机器只在等按键事件，你却一直在计算重力下落和碰撞 施加反作用力，啊或许是非常真实，但没必要

我们可以限制某段 x 范围内 y 的最低点，换句话说就是给整个关卡一个高度地图，一旦在某x区间 y高度是绝对不小于某数的，因为超级玛丽的场景对象是按方块为单位计算没有斜坡，这是比重力+地面碰撞合理的解法；也是向量计算中常见的限制与往复化数值

所以说小的游戏，更能体现出作者的精细程度
