分词算法？无匹配就跳1字符
利用失败路径 __a, _ab 选择跳过数
不匹配时最多消耗从0变到M项

DP和树

能不能去掉 All(p) 的重试，只利用 Trie 匹配输入流？重试图化Trie

当我们步过一棵树，每深一层接下来的选择都少很多，尝试次数是有限的。

从0数到10只有10个数，可如果在它要>10 时重设为1，就能无穷无尽的数下去了，树是图的子集，图的深度是无限的，因为某点的后路能跳回其父节点

当步进失败时返回0点继续，就实现了外层循环失败-树0点重匹配的功能
abc 里每项失败时转移到a再看，就兼容了 aba, __a; aab, _ab 的情况；而 aab 在第二a后b(输入为a)失败时，a显然已出现，转移到最近a重试ab
每字符的失败方向是0点，或者最浅层的前字符；如 hisa,is,ism ，hism 在 hisa 失败转移 s 再试m 就好
但这浅层的前字符不太优雅啊，Trie是时刻考虑前面字符的，flishx 和 hish 里 i 不该失败到浅层前字符，于是在创建 fail 指针时相当于在对路径本身匹配，知道 fl-ish x 的后缀，x 失败就转到 ish_ 嘛

所以 KMP 就是单子串单次匹配的窄化AC自动机，即循环Trie

^ish
fi^sh fail节点的扫描始终落后一字，s 错到 i, h 错到 s

自动机只不过是休眠的程序流、靠我们更新状态号继续执行；列表迭代器是自动机吗？它是没有判断没有循环的自动机
如果靠状态号能拿到 p? a:b 这样的东西就有 if ，如果 a,b 的状态能重走到 p? ，就是循环(程序指针的往复) ，走到DFA终止态就是 return

稀奇的名词，往往有非常简单的解释，比自动机更强更广泛的，未必有自动机难懂

抽象层次更高，却更实际、更有表达力；状态号的变迁演了出大戏，剧本是下项规则，灵魂是带循环树步过，走到最终态、唯一树叶时以匹配收场；从行为倒推思想，难

编号化Trie图
AC 自动机，它的接口是 add(s,f) 和 onChar ，被动状态转移，现代语言用树步过 yield 也能做到，但自动机会自由许多
实现一个批量 replace
模式匹配和解析器不是一回事
Sunday 字符对齐
利用 Map<Str,Int> 的 KMP


程序和数据从没有硬性隔离，数据，亦是程序；优秀的程序员都懂这个道理，所以他们从不写重复代码；我们对某类程序的理解，不是三言两语的排版规范所能定义的

分不清算法的灵魂本质和实现方式，才是过早优化的万恶之源

优雅不在代码
优雅是变量关系的圆舞曲
只有程序活在你脑中才能看到
面对一堆英文和临时值当然是不知道的
