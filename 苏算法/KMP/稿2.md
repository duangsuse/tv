# 苏算法[KMP]子串查找、前后缀树

先看个相关问题，给你个汉语词典，怎么把 "你好这世界" 切成三段？

你可以定义 `s.index(ss): for i<n(s): for j<n(ss): if s[i+j]!=ss[j]:continue@i;  return i`

也即 `strstr=(s,ss)=>s.some((c0,i)=>{ if(ss.every((c,j)=>c==s[i+j]) )return i })`

然后利用 `split: i0=0;  push "abc".slice(i0,i=index("b")); i0=i+n("b")+1 while(i!=-1)`

保留切分符的近亲 `strtok=(s,ss,i=0,M=n(ss))=>function*(){ let i0=i; i=s.indexOf(ss,i);if(i==-1)return; i+=M+1;yield s.slice(i0, i) }`

然后用归纳法累积各词条切分结果 `"这 世界 你好".split(" ").reduce((k,a)=> a.map(s=>strtok(s,k) ).flat(), ["你好吗这个世界"])`

打咩！何必呢？有更好、更简单的方法

以前缀树来分词，它的树枝长这样 `t[c]=t1` ，没错每层都是一个字典，我们持有 `tNow=t0` 树根，依据字符 `c=s[i++]` 进行树步过 `tNow=tNow[c]` ，走到树叶时 `i-tok.length` 就是匹配的起始i ，并 `tNow=t0` 重新从词条们的 `tok[0]` 开始歩进

那词典是 abc,ac 输入 abd ac ，在 tNow=b/ 无路了怎么办？跳过1字 d 能继续找到 ac

可如果输入是 zzzabc ，你再跳过试试？zzz 3字根本不可能匹配，而因为每次不匹配我们最多跳1字符，很慢才能对齐到 `s[3]='a'` ，有没有办法让每次都能消耗 "abc"长 m=3 个字符？

Trie 步进随时可能像 abc在abd的d 一样无路，如果我们用 _ 表示失败后，下一字的可能， `_ab, __a, ___` ， ababc 前缀 aba 符合第二种 __a 情况，跳过 2 字符就能对齐，到下个前缀有匹配的位置；此时的 Trie 只有成功没有失败，绝对能消耗3字符

我们能否让每次都消耗无限个字符，完全避免 tNow=t0 呢？

树的深度是有穷尽的。走一步，接下来的可能性就少一点

从1数到3只有3个数，但如果在它要>3时重设为1，就能无限的数下去了；这就是树和图搜索的区别。

continue跳转到它之前的语句，称为循环；树指向其父树，称为环形引用

如果我们把失败指针设置为 t0 ，失败就自动重匹配，也就兼容 `zza, zab` 的这些情况，可以无限的投喂 `c=s[i++]` 给它，而它的作用就是走到了某个路径时执行一些动作，这个路径称为终态，好比程序走到了 return 语句；我们称它为 AC 自动机，一种 DFA(遇输入状态一定改变的状态机,否则是 NFA)

但这个 fail 指针还有个问题， dog,oil, 匹配 doil ，do无g 失败时该转哪？t0 吗？不会再喂给你 'o' 判 oil 了啊；在之前 do_ 失败消耗3字符因为 i 不是 dog 的前缀，毕竟KMP不考虑词典有俩词的情况

可以在添加 dog 的失败指针时对它分词，取前1字符的 `t` 树枝，d->t0, o->t0, g->o/il ；因为 g 之前 o 肯定是匹配了的，而如果有 doo ，g 的失败也是指向 do/o ，可以形成一个重试链表，当然基于 Map<Char,Trie> 的我们用不到，但 dump, uma, umay 的 dum/ p 失败转到 um/ 是很清楚的

看懂了 o g=(ok) o/; o o=(ok) o/ 的转移判定你应该会发现这是死循环，do/ 后只要没字符 g o 就不会重设回 d/ 了，而假设 o o=(ok) d/ ，你会发现不能喂 `s[i++]` 了，只有到达 dog, doo 才能跳过匹配长度，或者 o o=(ok) (i+=1; t= d/) ，意义不大脾气不小，所以还是别想用这个奇技淫巧把。

这样我们把一次最多消耗从0、m 变到无限，即输入长度 n
