# Knuth-Morris 和 Pratt `"aab.indexOf("ab")` 算法？

如果你觉得 KMP 实现轻而易举，相信是不会点开这期视频的，容我先给大家引入点基础知识。

树、递归、动规有什么区别

树是递归的形态，也是可被改变的递归，例如二叉树就是可变的二分查找，然而最终搜索某数还是靠递归的节点遍历去剪枝、去判断。数据和程序是并蒂而生的。

递归可以靠返回值代表树枝树叶，来生成一颗树，它是根树。但生成递归结构并不一定需要递归，最典型的无疑是文件树，你只是随意创建文件和目录，得到文件树的深度也不只会是1 （文件深0,夹深+1

`trie=(p0=new Map,KZ=Symbol.for("Val"))=>(k,v)=>{let ki,p=p0;if(no(v)){for(ki of k)p=p.get(ki); return p[KZ]} else{for(ki of k)p.set(ki,p=p.get(ki)||new Map); p[KZ]=v} }`

那么动态规划(DP)的网格呢？它的行i是子问题的编号，列j是子问题i的输入的编号，那么当我们以i+=1 方向计算 `a[i-1][j]` 就代表深1层问题同输入的结果，换句话说，它是对递归函数形式化的缓存，同时避免了调用栈和重复计算的开销

举个例子，把 4 变成 `1+3, 2+2, 3+1` ，然后我要进行 `3=1+2,2+1` 一大堆穷举怎么做：行是 1~4 ，列是0，内容是列表 x于0~圆整(i/2) x, i-x

显然没嵌套啊，真实内容是 x于0~圆整(i/2) `product(a[x][0],a[i-x][0])` 每项的 .join("+") ，而行01是 `[0],[1]`；这样我们就通过2D数组计算了一个基线是0,1 的递归算法的特例

再看看fib数列、背包问题、共同子串

树和状态机，也就是图有什么区别

根据当前节点的漫步，树可以有 a b; a b c, 也可以有 a b a ，但这个 a 是独立的，它不能往回指，也就是 ababab... 当然可能外套个 for 循环就行了，但那就不是单一的状态机了。程序的当前位置、计算机本身也是状态机啊

类似正则表达式 (ab)* ，我们知道正则也是 NFA->DFA ，是自动机(变化规则受限的状态机)

今天的内容涉及我的一个Java,Py,JSON啥的 解析器框架 Scanjs ，主要是帮大家引入 Trie 字前缀树 的必要知识点，但老实说KMP算法和解析过程没啥关系，因为解析器都是完整扫描 不存在跳过0匹配部分，

顶多加快 bash heredoc `<<EOF` 的扫描速度吧，但很不幸配对子串的语法是 \n\s*(EOF) ，也就是说高大上的算法、某某机啦在这里毫无用武之地，就像正则的字串级 *+{min,most} 不适合识别编程语言文法，反而让直白易懂，基于调用栈和指令指针的递归下降法抢占了先机，挺可惜。

虽然目前 scan 主打的是后缀树，看到 "pu" 能断言后随 pu-blic 的那种，我们先用 Trie 来穷举字符串内的许多子串匹配，

KMP的优势在于对输入文本，它只会向前，类似 i+=m+1 的重测试，也就是最多试 n/m 次；而暴力法在不匹配后i只能跳过一个位置，毕竟不知道刚刚测试的后缀是不是子串的前缀

scan 的 feed("aabc") 流也只会向前，以 `More(Trie(["abc"]).p)` 读取它是这样：T读"aa"无路，匹配失败，More 不会自动朝前1字符再匹配；于是我们创建 `All(p){ r=p(s); if(r)yield; elif(!s(-1))break while (1)}`

我也可以跳过直到 s(1) 出现在 trie 根的可能字符里，但遇到 ababc 里的 ab ，它还是只前进一个，不知道该对齐到 ab^a ，更不能处理 aaaabc ，它只会不断重试

只需给 Trie 加些小路径，就可以让 a_abc 匹配失败时跳过_ 直接对齐到下个前缀：你子串是 abc 对吧？我添加一个特殊字符 _ 代表字符不在当前路径时的路径，于是有：

__a, _ab 这两种情况，刚刚我们测试 aba bc 正好是 __a ，它的值为 2 ，i跳过 ab 两个字符再匹配，那 ___ 的值就是3；简单吧？这就是 KMP 对 Trie 所做的唯一修改，也正是这个失败路径把 Trie 树变成了一张图，一个每状态收到字符都有两条路的DFA；典型的同时优化时间和内存，导致一颗正儿八经的树变得亲妈不认，被人理解为神秘的DFA 写个80页也讲不清，我不禁想起了 Knuth 那句老话，过早优化是万恶之源；

举个例子， aaaab 里找 aab ，它会切成 aa aab 去寻找，先匹配了 _aa 跳过2项直接搜 ab ，因为共同前缀， _aa 先于 __a 嘛

有个重叠状态，ab^abc 里若 bc 不匹配就跳回最近的a的状态；如果我们把 a 失败的树路径 _ab 编号化，我们的跳过实际相当于它的跳回、最成功的重叠态编号 _ab 当然比 __a 重试的少

这种方法本质上和KMP是一样的，只不过不涉及任何机械化的算法和数组分配。

也有点像AC自动机，AC就是把 Trie 节点编号化了，节点的字符表指向新状态号；然后每点 fail 都到0点，或者当前字符最浅的节点，比如 his, is, ism

不过 scan 的 All(Trie.p) 不像 AC 是一遍过的， him,is,ism 处理 "hism" ，是匹配 hi 发现没 m 失败跳过 h 再匹配到 ism 的；而 AC hi 没有 m 就转到i前缀 is,ism 去尝试，它不用跳h再来次

看起来 scanjs 荒废了这个好用又高级的算法，不过后缀也是完整单词，在编程语言关键字里实属罕见；而创建它 unicode 支持不好弄、new Map开销也不比Trie少，况且这样匹配报错位置不好算， hix 失败了是 ix!=is, h多余 两个问题

>再谈「过早优化是万恶之源」

只是很少有人在乎别人能不能搞懂，更多人只是在乎代码好不好用，很多人眼里的「恶」并不包含冗长难懂，他们眼里只要用到一些理论，不管代码多拉扯都能登「优雅」之堂的；甚至以一些听君一席话如听一席话的空洞代码为荣，又空又长，4000行代码做了500行的工作，毫无切分、类比和简写，没错，说的就是你Java 人均情况最严重

如果KMP的讲解先无视这个fail指针回指的内存优化，它不就是单纯的Trie匹配吗？

KMP 的核心压根不是什么自动机、向量矩阵、动态规划、状态转移，而是一颗带失败路径，指向它父级的前缀树，只是有人分不清数据的思想实质和存储形式，用机器层次奇怪的索引计算，解读算法层次上 容器间的关系，不难理解才怪了。

那我们再来看看无前缀树版的 KMP ，我们需要对子串计算它后缀和前缀重叠的部分： aba=1, abcab=2, abcaf=0 ，每次对齐在下个位置都要再前移这些，但这个就和输入无关，aaaab 里找 ab 还是比较慢的，而且要判 aab.endsWith(ab) 特列

我们为什么不从 "a" 累积到 "abcabf" 打表，看看每个节点时回退多少？于是从输入i++ 维护当前路径，取共同部分长度的职责交给了AC自动机，fail 时的重定位刚讲过；我们可以依据已经匹配的部分取左移个数

然后再看看 Sunday ，它关于输入内字符有个字符-数表，初始是 m ，而如果出现于子串，则是同字符最右到末尾的距离

abc abf 在j=2失败一次，若i首字符不在子串，连首字跳过 m+1 ，否则i只跳 该字符到末尾的距离

比如 avvvab 里 ab , av-v 全跳， va-b 查到 b 的偏移 1, 啊a偏移2 ，跳过 v 检查 ab=ab

```js
const sunday=(s,ss)=>{
  let N=n(s), M=n(ss),c, i,j, shift={}
  for(c of s)shift[c]=M+1
  i=M; for(c of ss)shift[c]=(i--)//最大M
  while(i<=N-M){j=0
    for(;s[i+j]==ss[j];j++) if(j>=M)return i
    //if(i+M>=N)
    i+= shift[ s[i+M] ]
  }
  return -1
},kmp=ss=>{
  dp=Array(m) //行是状态、列是字符->新状态
  dp[0][ss[0]]=1
  let X=0 //最近同字符
  for(j=1;j<M;j++){
    for(c=0; c<=0xFF; c++){//字符集
      dp[j][c]=(ss.charAt(j)==c)? j+1 : dp[X][c]//从 __ab 回退到 ab
    }
    X=dp[X][ss[j]]
  }
  return s=>{
    j=0
    for(i=0;i<N;i++){
      j=dp[j][s[i]]
      if(j==M)return i-M +1 //终止态M
    }
    return -1
  }
}

let n=o=>o.length,
sunday=(s,ss)=>{
  let M=n(ss),j, go={}
  if(M==0)return 0
  let c,i,i1=n(s)-M;
  for(c of s)go[c]=M+1;
  i=M;for(c of ss)go[c]=(i--) // xx^ab,ab : go[a]=2
  for(;i<=i1;i+=go[s[i+M]] ) {
    for(j=0;s[i+j]==ss[j];j++) if(j==M)return i
  }
  return -1
}
sunday("abccvtabtabe","abe")
```
