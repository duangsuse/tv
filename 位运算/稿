[位运算]进制换算、秒数到年月日. Base64 都是这类算法，还能简化泛滥的开关变量?

编程时偶尔能看到 10<<2, fl&=~F_OK 这种代码， mo?

10<<1 是20, <<2 是 10*2**2 即40
别用这种2次方优化了小傻瓜~ 真的快编译器会帮你改写的
fl&=~F_OK 是删掉位旗(压缩布尔变量集) F_OK, flg&F_OK 则是测试, 而 i&~F 相当 !(i&F) , flg|=F_OK 是添加

位运算特指2进制的位运算，2进制每位只有两种情况，非常适合存储一堆 boolean 值(2)，|位并集&位交集，所以数学 的符号和逻辑 AND OR 有点相似

^是位异或, 不是数学意义乘方(a**k)啊 ，~位取反, 也可以认为是给每位应用 x=x^1 吧；他俩是不损失信息量的运算所以有种简单的加密法 XOR key 按字节为块直接取反块内几位，有人会拿 a^=b;b=a^b,a=a^b; 交换ab，真心不建议这些奇怪的写法啊
&|^ 的参数都可被称作位遮罩(mask)，比如 0xFF&i 就是取i末位的8位， 0xFF<<(2*8) 是取四字节整数(Java int) 左[1] 个8位，之所以难学，这个操作是和目标语言数值的二进制长度、最大值溢出规则，乃至C 里的本机字节序(大小端)等二进制存储形式有关

进制换算，比如到2进吧，5, 不断取余并除2, 这个除实际上是2进制右移

这也是位置计数法对位权的定义,2进右第N位的1相当于 2^N, 所以2^0 1, 数学规则是有系统性的
我们每/2 一次，相当于里面所有 2^N 的位权 N-1 ，所以第二次取余2 的结果就是 2^1 的位值

那2进制读取呢， n*2+(str[i]-'0') ,2进制左移

以上方法对10,16,8进都有效，也无关大小端(多字节更大/更小位在前)

世界上并没有进制「换算」，只有进制读/显，读取10进制再toString(2)显2进制 也是进制转换，因为10啊2啊这些都是数的表现形式，数的实质是加减乘除判大小同 操作，

不同的表现形式是等效的，背后的模型上的可用操作是无区别的
不同的框架工具是等效的，背后的API区别是可以用垫片忽略的
不同的编程语言和命名方式是等效的，程序员的思维和表达的便利才是必不可少的
不同的性能是等效的，只要你想想敏感度和基础开销，难用的库只能替补接口清晰的库

你可以把一个秒意义的问题，比如判断大会员何时过期，映射到年月日(日是小数)，再换回秒意义，问题一样得到解决

此问题与刚才的[到2进]唯一区别是基数不总2，而是大于60的部分(如果有) 算作分、大于 60*60 作时、24*时 作天、365*天 作年，当然月份判定和闰年是实际工程需考虑的

于是取余除就不管用了，我们得按降序排列单位计数判>，得除的结果 再对余应用下级单位
wait, 真的不管用了吗？如果咱把单位表按升序，不按与秒的比率，60 秒=1分，62 秒，秒=余60数2、分(除60得6)=无更大单位=6 ，所以，这也是一种基数会变动的进制换算法，只是某次基数有对应-单位名

(插播JS/CSS时钟)

咱讨论下如何用一堆二进制位表示正负整数

当然，对计算机而言数的文本形式并不重要，但对人而言，16进制以1字为块对应2进制的4位，比如 0x9, 就是2**4+1 即 0b1001 啊,  0xfa 两位是 15,10 即 0b1111_ 1010(8+2) 即 250

补码
比如 Java 有不区别符号位的 ushr >>> 移动但没有 ushl ，是因为它的符号位在前((short)-99>>>15==-1)。在溢出时，如 short 的 2**(16-1) -去给零的那个1, (short)32768 时会回滚到负值，你再往上加(位并)，它会往下减，可以看 
(short)0x8000==-32768, 仅符号位, 相当于最小值，如果有符号位也有个1, (short)0x8001, 欸 -32767 ；所以 ~2==-(2 +1) ，0是分给非负数的那一部分了，最小值的绝对值比最大值的更大
Java 的位移动是裁切的 ushr能暴露符号位，可 ushl 只能剪掉符号没有大用；当然，这些都是电子系的东西，和编程一点关系也没有，都是些嵌入式常用的奇技淫巧，许多编程语言都只提供不限最值的浮点数呢！

//有 (short)-100& 0xff <<8 即 0x0064&0xff00 , 结果当然和100大相径庭, 而 100&0x00ff 和 -100& =9c 呢差别也很大，
