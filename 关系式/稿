今天咱来谈谈函数式编程 FP 有些人了解的一个名词，一种等式求解方法。

unification 这名字太 English 了，而且国内文档很少；尽管你天天听 PLT 系的人提起，除了甩你论文链接，他们也不会告诉你名字以外的任何信息；我把它译作 归一化

其实我今天也可以就告诉你归一化即 变量是一等公民、变量是值，就像函数式有函数值，四个字足够概括。

也有人叫它合一化。其实质是等号(=)，一个无序二参操作，我的意思是二项之间默认有相等关系，我们只是确证下相等并提取出变量而已，这就叫归一。

问题都是从简单开始的，从最简单的范例伸展、泛化到最终很有趣的情况

从 a=1 或 1=a 得出 a:1 这个很自然吧，这里就有了 符号 与其 对应表 ，对应表可以是全局的，毕竟要能知道一个符号被赋的值。因为符号是内存地址而不是名字，它是唯一、可随时新建、不会冲突的

很多人就分不清这个数据表象和实质啊，例如一些人赋值用户定 innerHTML 会 filter 不想支持的标签，但是 innerText 他也觉得有被注入的风险；
这是没有分清不同的表现形式和背后的文档元素间的联系。命名的实质往往是存储位置的引用，而位置地址当然是唯一的。

那么我们不靠名字怎么得到 a 的值呢，通过 st.go((a)=> eq(a,1)) 的 API 我们就能知道结果变量的引用，且基于它构造一个关系

现在你知道，归一化是把一个变量、一个值，无关顺序通过赋值变得相等，还能猜到这个操作可能用在两同类项目，也能失败如 1=2, a!=b 时 a=b

归一化其实是，把两个可能含有变量的值，各自内部位置对应的变量，于对应表上的值，尝试划个等号

咳需要注意的是， a=b 里 a 不是=b 的当前值，而是直接指代了 b 的值，要不然 b 当时没定义后来 =c ，就构不成 a=c 了；

当然相等关系的传递性是个链条，可以通过for循环解引用，并在变量赋值时 断言值没循环引用自己(编程错误)

但是 a=1&b=c&c=b 时 c=a 该怎么推呢，我们还没有方法去组合等号关系，去构造更复杂的逻辑关系；我现在告诉你：
st.go(fn) 的 fn 返回一个 Goal 也即对应表的流， eq(ab)=st=>(s1=unify(ab))?[s1]:[]
如果成功则得到归一的对应表，失败就无解，它就是这样一个流。为什么要用惰性计算的流而不是列表？关系的解都是可穷举的吗， 
N>1 有多少可能，因为有点面向穷举的意思，所以求解器UI基本都显示查询的执行时间，你看SQL是不是也一样。

BFS,DFS 本质上都是遍历相邻项生成的搜索树；我举个明显的例子：从 1 开始每次操作 +1,*2 如何走到 12

我们用 for(x of dfs(1, _=>randPick()))if(ops(1,x)==12)return x 寻找这个排列，因为*+没交换律 bfs 不能用的啊

关系式 opList(1,named(x, seq(elem(*2 +1))))=12


哦为了性能我们减少对 Map.copy 的使用，抽象出 st.fork(k,v) 默认返回自身 0复制，然后 &| 这些关系会组合几个流，返回单个流，它的每项计算自然是被组合的 Goal 先调用下修改了表，我们0复制也OK的

但我偏不。我还是清醒这是在教你们实现的，过早的优化是万恶之源；但我们也能反将一军让它比带复制者更易调试，变量的名字是带计数的： opOrInit(0,x=>x+1) 待会看看

and且: a=1&b=a 是 b=a 在 a=1 成立的前提下执行，得到最后者的流 我们称之 all(...ps)
or或: a=1|a=2 是二者各自成立的情况并流对吧，毕竟我们要支持 0~-无限, 0~无限 的合并流；我们称之 one(...ps)

miniKanren 有个非常原始的设计，就是 "he"+"llo"=="hello" 它给表示成 appendo("he","llo","hello") ，且不论这里有个中缀语序是否该颠倒(Haskell `+` 是颠倒的)的问题，
那个 o 是 out 的缩写啊，你想想 Kanren 系语言的N参关系命名尾部都带个 o ，不奇怪吗

cat("ab",x)="abc"

我们还可以做一个层叠盒子的可视化
