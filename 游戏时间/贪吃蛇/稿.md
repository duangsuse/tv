# 游戏时间[贪吃蛇]手机上玩？咦，怎么卡进墙里了！

欸，我眼前的这是什么东西，弯弯曲曲的，蚊子吗？ 啊，爬到我眼睛了！*叶公好龙

这是一条队列，它有一个队头、一个队尾(push)，每次最新一点 朝当前方向，涂黑一格；最老点清除掉，新老更替，就像一条在爬行的线 哦不 蛇了。

看看这个网格(grid)，它有 n 行 m 列，就是说每行分配 m 个格子；称为 `int[n][m] a; `，那 a[0] 就是第一行、 `a[i=0][j=0] `就是左上角第一格、` a[n-1][m-1] `就是右下角最右一格；计算通

其实我挺奇怪，为什么编程学习者会对这个简单游戏有愿望。毕竟它就是在像素图上，弄个长度和分数成正比的先进先出(FIFO)队列；时差更新而已，
可我第一次想做时也迷迷糊糊 只知道要用 push/shift 入出队列后更新那一格颜色，连每像素有几种情况都没想过

当时如果听说身边有人做出来了，我也的确觉得很牛逼啊；而今天，你不仅能在网页、命令行、触摸屏里玩贪吃蛇，还能自制奖品和地图，废话不多说，3分钟了解下！

这里感谢下 Milo Yop ，虽然二维数组本质，是普通数组 以列长分块，是C语言结构与指针入门内容；但他很好的混合了单格子索引与 RingBuffer 环形复用暂存队列，我也是在阅读他的回答后，写了我的第一个贪吃蛇程序

这是游戏按帧刷新流程。
让我来听听有没有小可爱，说蛇只能在用户按键时移动，因为不知道方向是啥？

啊有一个当前方向的。
用户按一下，移一格，那还有撞死的蛇啊，我大战300回合直接填满地图！ *直接休闲游戏变智力

这个游戏的状态表，初始态是一条蛇，i+j 位置 `(n/2)*m+ m/2` ，方向=上=-m ，靠 +-每列个数m 就能拿到上下1行同列的格编号；

我们无论是设计什么程序，对它每个生命周期，例如帧更新时，必要的状态集和继承性都会有个预判；你看到这张图就应该推敲下，是什么东西，影响了这次的变化；上一帧 push 的蛇头和方向嘛

总的来说，我们在一个格子数 `n*m` ，四边有墙(i,j==0或n,m )的地图 `rect=Array(n*m)` 上，有一个蛇体队列 que ，它每次按当前方向 dir 涂黑并入队下一点，然后弹出并涂白最老点；方向键按下即改变当前方向

JS push(项) 索引的方向是向右，增加啊；那么蛇头就是 `a[a.length-1]` 以下写作 `x1(a)` ，蛇尾就是 项=pop()

也就是说如果你看 que 这条蛇，它的头是在右边，它的身体块“死掉”是从左边；而增减和始终是0

也可以用 unshift,pop 这样蛇头就是 `a[0]` ，但性能不好；另外和 que 1:1 一个 p 变量等效 `x1(que)` 可以避免许多 `a[i]` 索引取值，`push(p= p中点)` 以后每次 `p1=走(p,dir); push(p= p1)` 即可但蛇本质只是队列啊，这个优化你自己加

实操。

当下一格碰上墙就GG了。碰撞上苹果，只把它涂黑，不弹最老点，蛇就变长了，然后重新随便选点涂苹果；


刚刚我们谈的地图，是一个 `宽=列数=m, 高=行数=n` 的2D数组，
它的每个格子可能是 `空白、蛇体或墙、苹果` ，我们就用编号 123 存格内的情况喽

但是目前为止它都是看不见的一堆编号，必须要有个程序把它变成字符串 给人看，鄙视链从这里才开始了

我先来个标准示范，用 JS 的 grid hr.red 渲染这个位图

然后是 canvas 算好i行j格的 xywh 矩形，按内容应用绘制函数，啊 `fillStyle="red"; fillRect()`

如果你不想学高大上的命令行版，就没必要看下面一段，因为 grid 和 onkeydown 改方向的显示方法和输入事件，已经是游戏外观的全部了。

透露下为啥不用移植性更好的 canvas 反而选择元素网格，待会蛇的移动是有 CSS 动画的，看起来会像不是零散坐标构成的一样，厉害叭


基本了解C语言的人，会知道 \n 这种换行控制符，还有人知道利用 \r 可以制作进度条；可了解带来终端色彩的 ANSI `\x1b` (即八进制 `\033`) 转义序列的人就很少了

我们可以把每行转化为内文+\n 换行符，而内文是把每单元格 x 输出为数组 `风格=["  ", "[]", "()" ]` 的第x项

不过这是基础方法，有个缺点，就是不会自动清屏，甚至会有光标乱闪


基本没人知道 clear 命令只是向标准输出写入了点东西，没有黑魔法吧， `clear|hexdump -c` 后你会发现 `printf '\x1b[H;\x1b[3J'` 可以实现这种刷新，
而有的人为此每帧 `system("clear; cls")` 一下，我算是明白为什么有人不爱看了，毕竟进程的创建是开销极高的操作，根本不适合300毫秒执行一次

当然，Windows 控制台不吃这一套，但它也有自己的光标位置操作方法， wincon.h 内有 `SetConsoleCursorPosition(COORD {y,x})` ；完全可以把换行符变成 直接设光标到行i&输出，这比每次清屏或只靠 `mode con cols=m rows=n` 要好；所以我们要从JS调用 C API

而对 Linux 系呢，直接写 [H 控制序列回转光标，就能输出下一帧了；下内容，纯JS的亲们跳过。

对 Node 可用 require+ C++ `NODE_SET_METHOD  _MODULE v8::` 插件也可以直接用 ffi ，我建议规避 `v8::{Isolate,FunctionCallbackInfo,String}` 等一大堆暴露的无关的引用孤立概念， `ffi.Library("libm",{rand:["int",[]] }).rand()` 它不香吗？

我真想吐槽下前端界这个理论水平，函数值硬是能逼成 callback ，老长一串 我都不知道是要定义函数还是 void 动作里回调了

而对于控制台按键事件，又是鄙视链更大的一部分，C scanf 或 getc 能用吗？它们是阻塞的，就是说这个(终端输入,文件流)读取的系统调用，休眠程序主线程 啊直到用户敲了键盘，才恢复，你动画刷新是固定频率啊，能等这个吗？

如果不是 Node 已经有了非阻塞 stdin 读取，Linux 下 ioctl_tty `stty` 的 cbreak 和 nodelay 设置下才能去 `fgetc(stdin)` ，

Python 有 `aioconsole.get_standard.streams` ；WinAPI 上有 _kbhit() 和 _getch() 可以预判，Linux 上 `tcgetattr` VMIN,VTIME 0缓冲和0时延后可以实现。
- `echo 'TIOCGWINSZ;ICANON,ECHO; VMIN,VTIME;TCSANOW'|cpp -include sys/ioctl.h -include termios.h` //c_lflag,c_cc
- `struct termios{iflag i,o,c,l; u8* cc}`
- 但获取控制台宽高还是需要 `ioctl(stdin=0, TIOCGWINSZ, *{short n,m})` 。
- 那 Windows.h 就是 `GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &o);o.dwSize.X` ，我暂不支持

不想吐槽 npm 了，为了可配置这制仗CLI都做得出来，还区分 -save,dev, -g 然后 node 里又不支持非得 link

苦中作乐吧， Node 这 API 风格也就这样了  `npm -g i node-ffi-napi`

```js
module.paths.push(
  child_process.spawnSync("npm", "-g root".split(" ")).stdout.toString().trim() )
const {Library:dll, DynamicLibrary:_dll, Callback:CFn,VariadicForeignFunction:CVaFn,FFI_TYPE:CStruct}=require("ffi-napi") //亦可有 ref-napi,ref-array/struct-di
//CIF,CIF_var(tRet, tsArg, nFixArg?, abi);

let ioc=CVaFn(_dll("libc").ioctl, ["int",["int"] ])

process.stdin._events.keypress=(sk,{name:k})=>k=="q"?process.exit():console.log(k);
process.on("exit",()=>{})
```



好。现在你已会写基于点队列的贪吃蛇了，我们来看看彩蛋部分。

1.怎么支持触摸事件
2.怎么支持多玩家、多生命、触摸屏
3.自定义苹果外的奖励：只增长、加苹果、穿墙、反向、2,0倍速
4.支持贴图主题、区分墙、蛇头身尾、方向
5.手绘地图

网页 pointer 事件是统一的鼠标/触摸 API，用户点击时会生成 onpointer down/up 的按下弹起事件，只需计算下xy的相差里较大的一个，就知到横纵和正负，我们以 上下右左  的顺序(没错, `[-m,+m,+1,-1]` )让手势API帮我们索引；左下象限呃 没办法 ANSI 控制台是这样

把 `class Snake{dir,que}` 从全局独立出来，添加 `keys="WSDA",name,color,nLive=3` 这些必要的新信息便于区分，旧情况就是 nLive=1 的特例嘛；然后主循环的更新逻辑也变成和蛇数 1:1 ， `for(snk of snks){试转向(ev.key,snk.keys);snk.step(a)}`

把屏幕分成两等分，分别对应 `snk[i]` ；换向的时候可以震动下，手感好点。


只增长、不死、穿墙、2倍速,暂停 都是可以并存的，状态给 class Snake{flag} 一个真假旗属性就够了
只增长就是禁用每帧的除尾嘛，穿墙的话实质是碰到某个墙边 会传送到对面，2倍速是蛇的 step 方法再做一遍，暂停就是跳过 step ；面向对象管用吧？

然后自动反向是基于它尾部的 dir 即 `dir= -queD[0]` 的，刚刚支持贴图的方向时讲过； `que.reverse()` 下，下一帧就是朝尾部负方向增长


贴图主题利用 `style.backgroundImage=url` ，多文件有点麻烦啊；我们把宽高相同的贴图资源并列在一张 img 里，绘制到 canvas ，然后利用 `can.toDataURL()` 加载和绘制这些贴图。

区分蛇头和墙，它和墙、和蛇身碰上都是一个死，编号 1,2 然后 ==1||==2 就GG并列判断呗，当然如果你要添加不同类型的“撞死”可以换成 `!=0&<N `, N是死亡块的终止编号比如 苹果=3

你可能知道 9-patch 这种边框贴图技术，我这次用的是它的同类 4-patch ，分别是 横竖、正反斜杠的四张图

每块蛇身的方向直接像 que 一样存下来，绘制时以贴图编号+方向号一起读取。


最后允许手绘地图啊，对不住了，点赞过百了我再做吧

贴图的编号 y,+方向 x 分布是这样

空白,
墙面,蛇身 是 4-填充
蛇头,蛇尾 是四向
苹果
…自定义

地图的加载先是 名字 nm 地图配置，我们用一些制表符号表达内部墙面方向和苹果 空白、自定义蛇食

移动的动画也基于 queD 尾项，利用 `e.animate(kfs,cfg)` API
单格贴图的选择，空白苹果没有方向，墙面 00,nm 两点右斜, 0m,n0 两点左斜；蛇是基于 que 按i遍历渲染，如果 queD 改变,相接两项：

- -m 1; +m -1 是右斜
- +m -1, -m 1 是左斜

长1时只有蛇头，要不就 是从蛇尾后 迭代queD 蛇体 止于蛇头
