游戏时间[贪吃蛇]手机上玩？咦，怎么跑到地图外面去了！

欸，我眼前的这是什么东西，弯弯曲曲的，蚊子吗？ 啊，爬到我眼睛了！

噢，这是一条队列，它有一个队头、一个队尾，每次最新一点 朝当前方向涂黑一格；最老点清除掉，就像一条在爬行的线 哦不 蛇了。

我们把这个网格显示出来，它有 n 行 m 列，就是说每行有 m 个格子；称它为 a ，那 a[0] 就是第一行、 a[i=0][j=0] 就是左上角第一格、 a[n-1][m-1] 就是右下角最右一格

老实说我挺奇怪编程学习者里 会对这个简单游戏有愿望的，毕竟它就是在像素图上弄一个长度和分数成正比的 先进先出队列、时差更新而已，可我第一次想怎么做时也迷迷糊糊 只知道要用 push/shift (入出队操作) 队列，连每像素有几种情况都没想过

当时如果听说身边有人做出来了，我也的确觉得很牛逼啊；而今天，你不仅能在网页、命令行、触摸屏里玩贪吃蛇，还能自制地图和奖品，废话不多说，3分钟了解下游戏按帧刷新流程！

这里感谢下 Milo Yop ，虽然二维数组本质，基于普通数组列分块，是C语言结构与指针入门内容；但他很好的混合了单个格索引与 RingBuffer 环形暂存队列，我也是在阅读他的回答后，写了我的第一个贪吃蛇程序

让我来听听有没有小可爱，说只能在用户按键时移动，因为不知道方向是啥？
这个蛇游戏的初始状态是一条蛇，ij 位置 (n/2, m/2) ，方向=上=-m ；啊有一个当前方向，用户按一下，移一格，那还有撞死的蛇啊 我大战300回合直接填满地图！

我们无论是设计什么程序，对它每个生命周期，例如帧更新时，必要的状态集都会有个预判；你看到这张图就应该推敲下，是什么东西，影响了这次的变化；蛇头和方向嘛

总的来说，我们在一个格子数 m*n ，四边有墙的地图 a 上，有一个蛇体队列 que ，它每次按当前方向 dir 涂黑并入队下一点，然后弹出并涂白最老点；方向键按下即改变当前方向

当下一格碰撞上苹果，把它变成蛇体，不弹出最老点，蛇就变长了，然后立刻随便选点涂苹果；碰上墙就GG了


刚刚我们谈的地图，是一个 宽=列数=m, 高=行数=n 的2D数组，它的每个格子可能是 空白、蛇体或墙、苹果 ，我们就用编号 123 存格内的情况喽

但是目前为止它都是看不见的一堆编号，必须要有个程序把它变成字符串 给人看，鄙视链从这里才开始了

我先来个标准示范，用 JS 的 table td.apple CSS类 渲染这个位图

然后是 canvas 算好i行j格的 xywh 矩形，按内容应用绘制函数，啊 fillStyle="red"; fillRect

如果你不想学高大上的命令行版，就没必要看下面一段，因为 canvas 和 onkeydown 改方向的显示方法和输入事件，已经是游戏外观的全部了。


基本了解C语言的人，会知道 \n 这种换行控制符，还有人知道利用 \r 可以制作进度条；可了解带来终端色彩的 ANSI \x1b (即 \033) 转义序列的人就很少了

我们可以把每行转化为其内文+\n 换行符，而内文是把每单元格 x 输出为数组 ["  ", "[]", "()" ] 的第x项；不过这样有个缺点，就是不会自动清屏，甚至会有光标乱闪


基本没人知道 clear 命令只是向标准输出写入了点东西，没有黑魔法吧， `clear|hexdump -c` 后你会发现 `printf '\x1b[H;\x1b[3J'` 可以实现这种刷新，
而有的人为此每帧 `system("clear; cls")` 一下，我算是明白为什么有人不爱看了，毕竟进程的创建是开销极高的操作，根本不适合300毫秒执行一次

当然，Windows 控制台不吃这一套，但它也有自己的光标位置操作方法， wincon.h 内有 SetConsoleCursorPosition(COORD {y,x}) ；完全可以把换行符变成 直接设光标到行i&输出，这比每次清屏或只靠 `mod con cols=m rows=n` 要好

而对 Linux 系呢，直接写 [H 控制序列就能输出下一帧了


而对于控制台按键事件，又是鄙视链更大的一部分，C scanf 或 getc 能用吗？它们是阻塞的，就是说这个(终端输入=文件流)读取的系统调用，休眠 啊直到用户敲了键盘，才恢复执行程序主线程，你动画刷新是固定频率啊，能等这个吗？

我们必须用非阻塞的字符读取， WinAPI 上有 _kbhit() 和 _getch() 可以预判缓冲队列里有没有字符不等待就能读取，而 Linux 有点复杂，最方便的方法是用 ncurses 的 getch()==-1 和 mvprintw 读显都包了，也有人甚至用新的 IO selector API (文件集读/写->监听器) 监听标准输入文件更改的

(如果你用 timer 信号刷新屏幕，然后让主循环去做不常有的 getc() ，我只能说你角度独特……

我不引入外部库啊，标准终端靠 ioctl 就能获得终端宽高 getmaxyx() ，设置成非阻塞即时获取输入的模式的：

那么控制台的部分，我们用 NodeJS 实现下。


好。现在你已会写基于点队列的贪吃蛇了，我们来看看彩蛋部分。

1.怎么支持触摸事件
2.怎么支持多玩家、多生命、触摸屏
3.支持贴图主题、区分墙、蛇头身尾方向
4.自定义苹果外的奖励：只增长、加苹果、穿墙、自动反向、高/0速
5.手绘地图

网页 pointer 事件是统一的鼠标/触摸 API，用户点击时会生成 onpointer down/up 的按下弹起事件，只需计算下xy的相差里较大的一个，就知到横纵和正负

把 class Snake{p0,dir,que} 这几个符号从全局独立出来，添加 keys="ADWS",name,color,nLive=3 这些必要的新信息便于区分，旧情况就是 nLive=1 的特例嘛；然后主循环的更新逻辑也变成和蛇数 1:1 ， for(snk of snks){试转向(ev.key,snk.keys); snk.step(a)}
pointermove 事件 ev.touches 里对每个指头都有独立的索引号，刚才的 down/up 事件xy差的方法，换成固定时差算速度>阈值即换向，把 touches[i], snks[i].dir 对应下就OK了
或者把屏幕分成两等分，分别对应 snk[i] ，啊我用的就是这个方法；换向的时候可以震动下，手感好点。


贴图主题利用 canvas drawImage 进行，但是多文件有点麻烦啊；我们把宽高相同的贴图资源并列在一张 img 里，绘制到 canvas ，然后利用 get/put ImageData 加载和绘制这些贴图。
墙和蛇碰上都是一个死，编号 1,2 然后 ==1||==2 就GG并列判断呗，当然如果你要添加不同类型的“撞死”可以换成 !=0&<N , N是死亡块的终止编号比如 苹果=3

但是绘制时它有独立的贴图序号，样子就不同。然后蛇尾什么的方向可以通过 que 相邻项的 ji 横纵差是否为0，但从性能考虑就直接和存 p0 的 que 一样存下来，绘制时同编号一起读取。

给 class Snake{flag} 一个真假旗属性就够了，只增长、穿墙、2倍速、暂停 都是可以并存的
只增长就是禁用每帧的除尾嘛，穿墙的话实质是碰到某个墙边 会传送到对面，2倍速是蛇的 step 方法再做一遍，暂停就是跳过 step ；面向对象是不是管用？

然后自动反向是基于它尾部的 dir 即 dir= -queD[0],p0=que[0] 的，刚刚支持贴图的方向时讲过； que.reverse() 下，下一帧就是朝尾部负方向增长


最后允许手绘地图啊，刚刚谈贴图我可能没表达清楚，不止是蛇，墙面也应该分方向的，但是横纵交接的时候，如果不是方块是线状的，就会出现横断的情况，比较好的解决方法是45度拼接，就是自动生成 9-patch 嘛
所以一个方块贪吃蛇也是能扯到很多问题的

不过度展开。我最后选择是贴图素材 y 是蛇苹果这些单项， x 是它们的上下左右方向，如果左上无颜色默认为前一个x格
墙面的编号 1~4 特殊处理了，它的上下贴图实际是 纵向和右倾边角 ，左右是横和左倾 ，45度勉强能围住
蛇身编号 5~8 贴图是蛇身，类似墙面，纵向和右倾边角
蛇头和蛇尾 同理，本应占用 9~3*4, 13~4*4 的空间，但我把它右移到苹果、自定义1,2,3 的后面，因为它其实是种蛇身的特殊部分，不能靠方块类型直接拿到

好我们写个 Py 脚本自动旋转，生成这个精灵图

地图的加载，我们用一些制表符号表达内部墙面方向和苹果、自定义123

最后我们，因为基于这个我们可以用 CSS 动画，实现按纵横方向平滑移动，是不是像用了物理引擎一样？

