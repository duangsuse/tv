## 如何学习

在JS里，FT的可视化能在40行里完成，但如果真要用那么多公式讲这个问题，你就不太有编程哲学🧩

>简单清晰是可靠的先决条件，不是可靠的牺牲品

包括在AI潮里，我听到些奇怪的说法，类同“物理学的大厦已经建立，只有两朵浮云” 和 “物理不存在”

AI毁掉的分明是柯洁的榜一，为什么我们把围棋等同于柯洁呢？ 其次，捷宝失去了榜一就没活了吗？

在编程里，无论if,for这些“现象”，还是逻辑函数(<,&&,||; +-=)与程序指针的“本质”，__是平行存在的，只是用户面向不同__。 倒不如说，if等函数跳转才是本质，而汇编是它的解释器；低频的filter{it>0}才叫本质，高频的for是样板是冗余

如果《西游记》是代码，那81种动物就是类的设定，舞台质量凭选型。在学习语言前你就能理清它们。 你的文章/视效就是本质，代码只算外语，写得歪七扭八的摆π就更次了，甚至，缠绕转圈圈都不如xy各自“共振”更好解释FT的原理。

稀少的，晚学习的，未必就更本质。 只有心里有“基频”，才能对知识做变换，滤除高频的噪音，忘记重复的谐波

学习的窗口广，那些溢美之词和术语的抖动才不会让你盲从，次数也就不需要太深奥。

确实有一种频谱，能量化每个知识点的响度，只要别纂紧已知的符号。基频，其实就是同类书本里重叠的问题。 寻找基频，并不是“解决”书，而是解构书， 用心站在作者的领域去思考

像《诗经·彼阳》那样，把基频当面条一样随便伸缩测试匹配度。不严谨晚点修就是了。总比不爱看但会背强，总比百年过去没人整理强

人类，不应该靠全力奔跑，才能留在原地。装个轮子吧。

>平凡人是“自顶向下”recursive descent 先给模型-参数再思考；而电脑在编译时就向下过了，“自底向上”深先遍历，算法的意义只是在计算结果。__示例输入有多复杂都OK--找边界情况？找关键帧？__ “数学式要无穷啊！”

可电脑，早已从生硬的晶体管、逻辑门发展到满街的触屏，从深奥的(1+1)向上到了浅显的(2)，从孤独的调用树发展成了字典的参数图。 在代码里，多领域的联动，如单领域般宏大而生机勃勃。

本文摘要
- 简单清晰是可靠的先决条件，不是可靠的牺牲品
- 理科和工用间是连续的，是拼音和语音的关系
- 专业知识让问题迎刃而解，体系一致的def让问题不刃而解。当攻略到这种程度时，结构就是算法，提问就是解答
- 语言的简单，胜过符号的简陋。追求理论，就是重复前人的对，剔除前人的错，传承所谓的智慧，像做科学实验般优雅；基建起心智模型，拒绝吃心智负担
- 这种创造力，让你很难单纯把知识抄下来，而不与自己的专业领域产生联系；让你无法做GPT一般的“跨端复制式编程”了

另外
- 计算机不是科学或数学，但这正是它的广泛之处。编程和Web圈就是“知识懒加载”的底气
- 编程无关计算机，就像天文无关望远镜。 编程是预知问题的艺术，这个指标跨越语言、符号体系，一直美到图形界面
- 知其变，守其恒，同自然界般死板。穷其变，链不穷，才会赋予这些概念之孤岛，超越时空的意义
- 人类，不应该靠全力奔跑，才能留在原地。装个轮子吧。 70年前Fortran诞生时，逐条算术的汇编在程序员里就out了，但用“大脑超频”的概念理解智能的活化石，万世不绝呢

### 编程是预先提问的艺术

先问为什么，慢讲是什么。 缺乏这种思想的理工，一言以蔽之，简单的太肤浅，难得太空洞。

科学或理论的课题不是懂不懂，是已知和未知。[编程的艺术是驾驭复杂性的技术](https://www.zhihu.com/question/423764018/answer/1587113755)，是藏绌的艺术。

如果你觉得没做出啥就满嘴飘术语的人很幼稚， 那就别崇拜风口浪尖或深入浅出的白象。 对比二者，就能发现字典式的记忆、易问难解的抽象，并不是成功的主要原因

学问学问，不是勤学好问，而是要想学，先提问。 学生不知道你面对了哪个问题，你讲的过程和成果「定义」了什么呢？ 技术会被人精通，而不绑架人们。 not even WRONG 就是指没头没尾的知识

我们要学的是专业知识，但它们存在的唯一价值就是服务于用户或供应链。 这是一种先进的减枝策略，因为是无数人验证一种知识，而非一个人孤证无数种“概念”

算法对CPU和内存降复杂度，代码生成对人的算法降复杂度，编程语言是二者的结晶。 单次运算、多点函数、多项式定义--从步骤建立抽象并非数学家的专利

>编程无关计算机，就像天文无关望远镜。 ― [Dijkstra](https://en.wikiquote.org/wiki/Edsger_W._Dijkstra#:~:text=art%20of%20organizing%20complexity), 他为尚未存在的机器写了五年程序

不像数学，编程是纯粹的数据工具，它的问题肆意跨越形式和领域的界限，你只学会“范围”“行表集长度”等类型，就能调用无数轮子帮你解题，并不存在高数,高中数的割裂，理论和应用构成了从不空转的闭环。无论这些类型投射到哪些术语，无论USB连接到哪个厂商，代码都有恒定的语意，这就是「扩展性」，也是数码界能持久繁荣，而人海战术的数学却崇拜天才的奥秘

物理和游戏，几何和CG，地理和GIS，它们都有自己的算法技巧，已经不是纸笔的语言所能传达和调整，为此，我们需要函数/字典接口等心智模型，只调整问题的“关键帧”，让电脑解决“终极问题”。

编程思维的具象化，就是给工具易用通用的UI设计,API分类(来奠基UX,DX)。为此，__请区分出创作式/定义式编程 和 跨端复制式编程__。 复制，就是说把SQL表和json、函数参数和URL/cmd参数，或者将{}和html 转来转去这样。

而创作是写稿、设计，是由生产力工具、编程框架辅佐的。

编程是预知问题的艺术(不是等着上StackOvf问咋除错..)，这个指标跨越语言、符号体系，一直美到图形界面。计算机不是科学或数学，但这正是它的广泛之处。编程和Web,AI圈就是“知识懒加载”的底气！

就像UI一样，文字也有内部一致性(自洽性)、体系一致性(解释力)。 __专业的诀窍让问题迎刃而解，体系一致的def让问题不刃而解__

你拜托程序做CAD做物理，但机器的世界观广于CAD、泛于单次推理计算。 

重点……是要象逃避瘟疫那样逃避 “聪明的技巧”。 GPT能帮资深用户改编程，v8能内联js的弱类型函数，编译器能做向量化，但API示例/Schema嵌套/矩阵计算 的贫弱，才是最缺优化的根源

编程，就是用类型与封装，把对公式的检验、对算法的直觉变成不言自明的事。 到最后不依赖机器点醒，也知道自己在设计什么。比起天分这更依赖合作，却会产生更多经济价值

### 软件工艺

假设HR是我，同等价位也会选择学历更高者，但这只是对教育成本回馈的公平，不能算考察。 我并不想让所有资源培育最高的叶子，但这颗浮空大树，没有根基

“百尺之绳日取其半 如何如何”，总是有人认为教育即筛选，人世间的智商总和恒定，考试是为了让有人“白领”钱，其他人安心扫大街。 其实劳动哪来贵贱呢？只是社会为了某些方向更光明，会抛下一群人。 你学的课本，还真是为业界学界的骄傲，所谓基础，真的硬核到用不上

小工程师 小文艺家，真的能被题海启蒙吗？ 牛顿、乔布斯真的是怕被看不起才用功学习吗？ 考贝多芬物理题，他能答上几道？毕竟物理也是乐理的基石啊？

先驱者很伟大，但他们的一生并不会比你更加多彩。人们总是用标签去转发刻板印象，却忽略身边的众多普通人，也忘记最开始，自己一生或许只是想有拒绝风险的自由。  

公元前智人的大脑，和21世纪的我们区别不大，但所成立的确实是两个文明。 科学的繁荣并不是靠筛选天才，而是因为所有曾在自己领域挺身而出的凡人；更是因为他们所需的价值，一些钱买不来的归属感，一些凭金条运不走的天赋

尽管工程和理论界的绝大部分人，认为“编程”只是翻译和推敲代码来“解决问题”，轻视编程，依然是灾难性的

我学的并非软件工程或C语法，而是软件工艺。要知道，`x+=1==2`、C指针和XML那些谭语言也是无关于计算机的

承认自己想了一周或“妙手偶得”的体系不好用、删掉无法自注释的，聪明的代码，而从头迭代，去追求更全局的最优解， 这是只属于编程的问题，是只属于人的。

>阅读数学书时，你总会在一段段中文碎片里，撞上出场次序随机，无定义就使用、定义后<3次使用、查重率60% 但从未外提为定义的声明和公式，可能相邻两行的n都不是同一种类型。 一般地，这叫读者缺少直觉或规范性。

这就是编程和单次推理里，“符号简洁性”的目标不同。编程时，STFT这样的算法只有一种def。 __当攻略到这种程度时，提问就是解答，结构就是算法__ ，曾经的难题，便消融为你创作的新“基本类型”

如果你支持「计算机科学」，那就要支持“所有发现过的公式和算法，最终都应该由电脑符号计算包代为处理”，因为不能被代替和简化的经验和直觉，违反科学规律；不是最普通的解法，对探索发现也是负面意义

“写法的意义”就是前端top2(Vue和React)间的根本差异， 「数学是增强逻辑」的美名，在无法被归纳、被代换/分层的现实前，在百年未变的理论前，如何站得住脚？

为什么OI/ACM界对同一组问题有那么多种提法，为什么AlphaCode最擅长算法而非工程问题，其实就是OI函数虽然抽象，但复用度很低，缺少泛化力。而AI正好擅长归纳解题模型，题解自然就成了训练数据

语言的简单，胜过符号的简陋(许多程序员,别再邯郸学步了)。追求理论，就是重复前人的对，剔除前人的错，像做科学实验般优雅；而非套用几百年里，被数不清的人做完了、丢弃了的存在。

用IQ量化人的大脑，和用1+1是否正确测GPT的智力那样荒谬。 70年前Fortran诞生时，逐条算术的汇编在程序员里就out了，没想到用“大脑超频”的概念理解智能的活化石，今年都还“正青春”呢！

人类，不应该靠全力奔跑，才能留在原地。装个轮子吧。

### STEM是种协作

>行百里者，半于九十。理论不重要吗？数学不是研究的根基吗？

理论“本天成”，妙手偶得之。数学与数学是不同的，这不会体现在知识点集，而是途径与价值观的根本差别。 不谈算法，字面间的距离就会比IPython和汇编还大

密码学，一门有着千年的理论基础的领域，却在近200年都没有人提出RSA；RSA公钥领域出现后，各种算法却如雨后春笋。 他们就开始说自己是RSA乃至整个密码学的基础了，和说Python是C的语法糖的人一样

- 我们所使用的工具(编程范式)深刻地影响我们的解题习惯，从而决定了我们思考的能力与价值。
- 根本不可能用一把钝斧子削好铅笔，升级成十把钝斧子，会让问题演变成大灾难。
- 优秀的语言用少量学习成本，训练通用的语意模型。 无论数学或编程，只要以语意为指标，都能孕育出新的“智能”与方向

__“九十”这道坎，最终还是落在纸笔密码学的“百里”之外啊。__ 对普通人来说，学习即是考古，复杂而雷同的公式，就是跨端复制式编程，反而会被Scratch,Desmos这些拖拽式编程所取代

我们要追求的是语意，而理论只能作为一个标签化的纽带。计科里，矩阵,协程(回调栈),树组合&解构 是60年前Fortran,Lua,Lisp 的东西，但今天 numpy,async,JSX 才可大行其道。 同样是半语句半函数式，各种流行语言的长处也不尽相同，(Van等新框架vs React)一个坏范式的鸡头，未必不如好范式的凤尾。 

上篇文的复数取代向量说明，一个领域不完整或仅仅不简明🧩，学界它长腿也会跑。造成，后续应用不易学不一致。 凭什么工科要为你们的内耗买单啊喂？？

- 我们需要一个能并联的“他山之石”，一个配当“编程的尽头”的高数，而非执着于无穷精度和字母发音的，歌颂头痛和苦难的历史包袱
- 不能编译的严谨 只会妨碍高层建筑的演进。工程师的时间和研究者一样宝贵，需要有人来引路，避免重复学习

限时的现实里何来无穷，就连电车难题的有穷都不能给你一个以少换多的合法性，而是提醒你事前绝不能出错。 上百次牺牲个人救同一队百人，如何？ 解答间各自独立吧？

- 无穷在 `<>` 上是存在的，比如空列表.max()<0 ，但这种边界情况比js的 `[]=='', 'ba'+ +'a'+'a'` 还扯，所以Python里都只能写 `float('inf')`
- [tch的计科笔记](https://github.com/tch0/notes/)
- [直觉主义](https://zh.wikipedia.org/wiki/直觉主义#参看)

__理科和工用间是连续的，是拼音和语音的关系__，不是非0即1的太极馆

把需求向上叠和向下拆，就是工科和理科，是学和思。 别忘记人和根源，却为“公鸡+太阳之死”抓狂。物理学的大厦无需建立，它只用给人想象力的浮云

- 倘若理论只是知其变，守其恒， 同自然界般死板
- 计算机就该去穷其变，链不穷， 赋予这些概念之孤岛，千万种意义
- 恰巧是抽象而不动画的文图，最考验逻辑转文字的语序铺垫

### 语意与文字

细想下之前让你指脸的左手XYZ。平行拇指的“cos线”，垂直于你才能看见起伏的。听懂时你要有脑补的成分。 __在自恰性与理解难度间，数学人总是选择只保一个__，这就是让代数太抽象的原因

就比如上一篇文章，我在提到分页算法 Markov链 PID弹簧时，几乎没有抽象的代词，全都基于示例本身的广泛性，我甚至偷偷用“导速”等谐音明示了步骤的意义。

对于日常语境下有意思的原理，我会做导论，而对信号这样没意思的术语，我也能把整个领域搬到工具语意下，然后做导论

这种好习惯，让你很难单纯把知识抄下来，而不与自己的专业领域产生联系；让你无法做GPT一般的“跨端复制式编程”了，而且，避免了公式推理的心智负担

数学是种"外语"，它不是用到再定义、无频谱可循的花体符号，更不是换写法就更合逻辑的知识。 我们需要多与物理、与计科的语言比较筛选，才是一种培养逻辑思维的准则。

如果一个人可以用工具优雅地写出没语意的东西，这只会是工具的耻辱。 啥叫语意？高于自恰叫、整条学习链都最高性价比叫。

如果为形式正确学习理论，你会学成「随机数生成器」，你的写作只能证明技术和脑力，而不能把问题泛化到比“抽象之初”更多的输入。 问题是得解了，但你的创作层次却被「局部最优解」锁死在虚空的世界里

比如反证法和纯函数编程吧，它们通过分支穷举来自恰。“A是无限大的圆，A含我” 不证自明(命题=条件)，如果用双重否定(∀=∄!)证明肯定呢？ 恭喜你发现了证明过四色定理的深先搜索，但那不是理论，只是算法

> `好玩:-昆虫. 昆虫(蚂蚁). 好玩(蚂蚁)` 是三段论, 也是深先遍历

数学命题“若p，则有q, p→q” 即 `x(R) :- [2,R]=[L,1].` 两边的语意。⇔充要则如 `bro(佩奇,乔治).` 猜猜 `sis(X,R):- 啥.`

诶，吐槽一句，`sis(X,R).` 写成 `Sis(x,ret)` 才更像“生成式”SQL表的行吧！ `main(int,[[char]], void). add([Int List], Str, void).` 又更像查函数重载

clpfd 允许遍历解集做∀∄ --`名:意 ∈in ⋀, ⋁; ¬\+`
- `forall((N in 1..5, label([N])), between(1,6,N))` 成立
- `N in 1..5, \+ N#=5` 无解
- `A in 0..9, labeling([max(A)],[A])` A=10个解

## 如何验证

不同领域的函数，有的可以对照。HashMap,BloomSet 也是“分频率桶”预判，但是按特征Hash,BitSet

再比如 `torch.Tensor` 和 `std::vector` 吧，明明就是NdArray和List，最多在DNN支持个自动求导

就像复数和向量是同构🖇的，`x:时域 X:频域` 间也有 `两换关系Eq(cat=FFT,cut=iFFT)` 。cat把输入解码到编程接口(二进制,字典,码点,wav,.)，cut将数据编码回专业领域(整数,json,utf,mp3,.)

变数关系对编程也很有用。在解集过滤式Prolog里，(0)+1 -1 嵌套和解构被用于定义加法，而[夯版PEG](https://www.metalevel.at/prolog/dcg) 能同时定义四则逆波兰的读和写--对LLVM,Vue.html而言太超前了

解集过滤，比如 `[X]=[Y], (X=2; X=3), Ret=Y` 只需要[“合一”unify](https://tca.github.io/veneer/examples/editor.html),DFS,抓取，比C语言还简单；但[形式化验证](https://ksqsf.moe/posts/2019-02-18-dt-fun.html)麻烦很多，.pl不能拿命题函数去=含变量类型，而Coq家族写个泛型比写SQL还啰嗦。

如果比含糊程度的话，高数<高中数学<编译原理 ，抽象度是爬不到顶的🙅‍♂️！


在谈到折线的简化时，Bezier样条也是种插值法，被用于SVG动画,CSS的[关键帧/缓动](epiceasing.com) ，而[WebGL](https://gl-transitions.com/gallery) 则有更多更酷的几何种类

`bzr=(ps,t)=>{let lerp=([x,y],[x1,y1])=>[x+t*(x1-x),y+t*(y1-y)]; return n(ps)==1?ps[0] : bzr(ps.slice(0,-1).map((x,i)=>lerp(x,ps[i+1])  ),t)}` //de Casteljau 算法,所有左的P都*t 至Plast

对了，懂了向量，写个很酷的命令行光标吧。 还可以猜猜怎么print ASCII Art？

```py
#sudo cat /dev/input/mice | python gpm.py $COLUMNS $LINES
import sys, numpy as np

P = np.array([0,0]); dk = np.array([.6 ,-.4])
L = np.array(sys.argv[1:]).astype(float)

while True:
  btn,*dP = np.frombuffer(sys.stdin.buffer.read(3), np.byte) #array('b', )
  P=np.clip(0,(P+dP*dk),L); x,y=P.astype(int)
  print('\x1b[',flush=True, end=f'{y};{x}H')
```

你可以试着支持伸缩旋转光标，甚至[粒子特效](www.websiteasteroids.com)。用一种很新的方式学游戏开发！

对了，应该看看那个分形！去 [ShaderToy](https://www.shadertoy.com/view/4ttBWM) 搜搜3D版吧(包括上面的双摆)，或者，看看[Taichi☯️ 物理语言](https://github.com/taichi-dev/taichi#run-your-hello-world)、[js1k](https://js1k.com/2016-elemental/)、[OGL 3D兔旋转](https://www.zhihu.com/question/430885980/answer/3076867653) 等信号处理应用！

- [Taichi用99行实现了向量粒子-水和果冻](https://zhuanlan.zhihu.com/p/158205579)

```js
julC=null
sdMandel=(nIter=60)=>(Px,Py)=>{
  let x=0,y=0, x1=0,i=0;
  if(julC){x=Px,y=Py; [Px,Py]=julC} //0,0+N(P x y) vs. Pxy+N C
  do {
    x1=x*x-y*y +Px; y=2*x*y +Py; x=x1
  } while((x*x+y*y<4) &&i++ <nIter)
  return i-1
}
//上手做? 想想啥是"CRT" canvas1.getContext('2d'); rgba=g.getImageData(xywh); for(i<w*h) y=/w, x=%w; putImageData(rgba,0,0, xy?)

三角=(l,n,u=2)=>{
let l3=Math.sqrt(2+1),a=[[0,l],[l/l3,0],[l/l3*u,l]], x=0,y=l //0点是三角左下， 向/2的层(下/右/右2下)分出许多枝，就含下位与细内
while(n-->0){let[X,Y]=a[随()*3>>0]; x=(x+X)/2, y=(y+Y)/2;  G.beginPath();G.arc(x,y, 1, 0,TR); G.fill()}
}
cfg={n边:5,l边:-200, r:.03*TR,P:[300,500]}
弦图=(nIter)=>{
  let {r:dr,l边:l, n边:N,P}=cfg,{sin}=Math,
  /*内角*/r=(N-2)/N*r180, kl=sin(r/2) / sin(r/2+dr)
  for (let 内=多边(N), r=0; nIter--; r+=dr,l*=kl) gPose(P,r,l, 内)
},
多边=N=>l=>{ for(let r=TR/N, i=0;i<N;i++){g.rotate(r);g.lineTo(0,l)} }
```

最后，再次感谢你学习信号处理领域的基本功！👏
