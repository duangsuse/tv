## 如何写字

在JS里，FT的可视化能在40行里完成，但如果真要用那么多公式讲这个问题，你就不太有编程哲学🧩
>简单性和清晰性不是奢侈品，而是决定成败的关键因素

先问为什么，后讲是什么。 缺乏这种思想的教育，一言以蔽之，简单的太肤浅，难得太空洞。


包括在AI潮里，我听到些奇怪的说法，类同“物理学的大厦已经建立，只有两朵浮云” 和 “物理不存在”

在编程里，无论if,for这些“现象”，还是逻辑函数(<,&&,||)与程序指针+-= 的“本质”，__是平行存在的，只是用户面向不同__。 倒不如说，if等函数跳转才是本质，而汇编是它的解释器；低频的filter{it>0}才是本质，“高频”if是冗余样板

你想创作的文章/视效是本质，代码只算外语，写得歪七扭八的摆π就更次了，甚至，缠绕转圈圈都不如xy各自“共振”更好解释FT的原理。

细想下之前让你指脸的左手XYZ。平行拇指的“cos线”，垂直于你才能看见起伏的。听懂时你要有脑补的成分。 在自恰性与理解难度间，数学人总是选择只保一个，这就是让代数太抽象的原因

>人类喜欢用“自顶向下”recursive descent 先给模型-参数再计算；而电脑在编译时就向下过了，自底向上，深先遍历：算法的意义只是组装结果，示例输入有多复杂都OK，找边界情况？关键帧？ 数学要无穷！

向上叠和向下拆，就是工科和理科，要思，先去学。 别跟随自恰的回环，去忘记人，忘记根源需求，只因为“公鸡+太阳的消失”抓狂。

机器，才是从生硬的晶体管、逻辑门发展到满街的触屏，从深奥的(1+1)发展到了浅显的(2)，从孤独的调用树发展成了字典的参数图。在代码里，多领域的联动 便是新的单领域。 你拜托程序做CAD做物理，但电脑的世界观广于CAD、泛于单次计算和推理。 

>编程是无关于计算机的，就像天文无关于望远镜。编程的艺术是驾驭复杂性的技术，是藏绌的艺术。

> `x+=1==2` 的谭语言也是不限于计算机的 ― [Edsger W. Dijkstra](https://en.wikiquote.org/wiki/Edsger_W._Dijkstra#:~:text=art%20of%20organizing%20complexity)：我没说过这话

阅读数学书时，你总会在一段段中文碎片里，撞上出场次序随机，无定义就使用、定义后<3次使用、查重率60% 但不外提为定义的声明和公式， 一般地，这是读者缺少直觉。

这也是编程和单次推理里，“简洁性”的侧重点不同。编程时，STFT这样的算法只有一种def。 __当优雅到这种程度时，提问就是解答，结构就是算法__

全局的简单，胜过局部的简陋(许多程序员,别再邯郸学步了)。追求优雅，就是重复前人的对，剔除前人的错，像做科学实验那样做理论；而非重复几百年里，被数不清的人学会了、丢弃了的存在。

### 心智与文字

如果一个人可以用工具优雅地写出毫无意义的东西，这会是工具的耻辱。 啥叫意义？高于自恰叫、整条链都最高性价比叫

比如反证法和纯函数编程吧，它们通过分支穷举来自恰。“A是无限大的圆，A含我” 不证自明(命题=条件)，如果用双重否定(∀=∄!)证明肯定呢？ 恭喜你发现了深先搜索，但那不是理论，只是算法

__所以理论不重要吗？数学不用研究吗？__

密码学，一门有着千年的理论基础的领域，却在近200年都没有人提出RSA；RSA公钥领域出现后，各种算法却如雨后春笋。对普通人来说，学习即是考古，复杂而雷同的公式，反而会被Scratch,Desmos这些拖拽式编程所取代

计科里，矩阵,协程(回调栈),树组合-解构是60年前Fortran,Lua,Lisp 就有的语意，但今天 numpy,async,JSX 才可大行其道

上章的复数取代向量说明，一个领域不完整或仅仅不简明🧩，学界它长腿也会跑。结果，后续应用不易学不一致。 凭什么工科要为你们的内耗买单啊喂？？ 我们需要一个配当“编程的尽头”的高数，而非执着于有无穷和字母发音的，歌颂头痛和苦难的历史包袱。

限时的现实里没有无穷，就像电车难题并不该给你一个以少换多的合法性，而是提醒你为什么工程不能出错。

数学是种语言，它不是用到再定义、无频谱可循的花体"文字"，更不是换写法就更合逻辑的知识。 我们需要多与物理、与计科的语言比较筛选，才是一种培养逻辑思维的准则。

__礼貌的说，理科和工用间是连续的，是拼音和语音的关系__，不是非0即1 太极馆

倘若理论只是知其变，守其恒， 同自然界般死板

计算机就该去穷其变，链不穷， 赋予这些概念之孤岛，千万种意义


## 如何验证

不同领域的函数，有的可以对照。HashMap,BloomSet 也是“分频率桶”处理，但是按特征Hash,BitSet

就像复数和向量是同构🖇的，`x:时域 X:频域` 间也有 `两换关系Eq(cat=FFT,cut=iFFT)` 。cat把输入解码到编程接口(二进制,字典,码点,wav,.)，cut将数据编码回专业领域(整数,json,utf,mp3,.)

变数关系对编程也很有用。在解集过滤式Prolog里，(0)+1 -1 嵌套和解构被用于定义加法，而[夯版PEG](https://www.metalevel.at/prolog/dcg) 能同时定义四则逆波兰的读和写--对LLVM,Vue.html而言太超前了

解集过滤，比如 `[X]=[Y], (X=2; X=3), Ret=Y` 只需要[“合一”unify](https://tca.github.io/veneer/examples/editor.html),搜索,抓取，比C语言还简单；但[形式化验证](https://ksqsf.moe/posts/2019-02-18-dt-fun.html)麻烦很多，.pl不能拿命题函数去=含变量类型，而Coq家族写个泛型比写SQL还啰嗦(虽然它证明了四色定理)。

如果比含糊程度的话，高数<高中数学<编译原理 ，抽象度是爬不到顶的🙅‍♂️！


在谈到折线的简化时，Bezier样条也是种插值法，被用于SVG动画,CSS的[关键帧/缓动](epiceasing.com) ，而[WebGL](https://gl-transitions.com/gallery) 则有更多更酷的几何种类

`bzr=(ps,t)=>{let lerp=([x,y],[x1,y1])=>[x+t*(x1-x),y+t*(y1-y)]; return n(ps)==1?ps[0] : bzr(ps.slice(0,-1).map((x,i)=>lerp(x,ps[i+1])  ),t)}` //de Casteljau 算法,所有左的P都*t 至Plast

对了，懂了向量，写个很酷的命令行光标吧。 还可以猜猜怎么显示 ASCII Art？

```py
#sudo cat /dev/input/mice | python gpm.py $COLUMNS $LINES
import sys, numpy as np

P = np.array([0,0]); dk = np.array([.6 ,-.4])
L = np.array(sys.argv[1:]).astype(float)

while True:
  btn,*dP = np.frombuffer(sys.stdin.buffer.read(3), np.byte) #array('b', )
  P=np.clip(0,(P+dP*dk),L); x,y=P.astype(int)
  print('\x1b[',flush=True, end=f'{y};{x}H')
```

你可以试着支持伸缩旋转光标，甚至[粒子特效](www.websiteasteroids.com)。用一种很新的方式学游戏开发？

对了，你也可以看看那个分形！去 [ShaderToy](https://www.shadertoy.com/view/4ttBWM) 搜搜3D版吧(包括上面的双摆)！ 或者，看看[Taichi☯️ 物理语言](https://github.com/taichi-dev/taichi#run-your-hello-world)、[js1k](https://js1k.com/2016-elemental/) 等信号处理应用！

```js
julC=null
sdMandel=(nIter=60)=>(Px,Py)=>{
  let x=0,y=0, x1=0,i=0;
  if(julC){x=Px,y=Py; [Px,Py]=julC} //0,0+N(P x y) vs. Pxy+N C
  do {
    x1=x*x-y*y +Px; y=2*x*y +Py; x=x1
  } while((x*x+y*y<4) &&i++ <nIter)
  return i-1
}
//上手做? 想想文首的"CRT" canvas1.getContext('2d'); rgba=g.getImageData(xywh); for(i<w*h) y=/w, x=%w; putImageData(rgba,0,0, xy?)
```

最后，再次感谢你学习信号处理领域的基本功！👏
