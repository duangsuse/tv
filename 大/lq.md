# 算法图解

这是本只有思路，没有图形表格动画和方法的书

## 于数/文值

定义 行=列表,组=定长列表,文=字串

### 1~100 FizzBuzz或1行文拼合

```
(1~100)去看，判，
  它整除3*5，"FizzBuzz"
  它整除3，"Fizz"
  它整除5，"Buzz"
```

问题很简单，`for(i=1;i<100;i+=1)f(i)` ，f=print(判整除15="FizBuz",3="Fiz",5="Buz") ，问题是怎么print (下文 P=printf)

```js
D1=open("","con").document; P=s=>D1.write(s)
P('<pre>') //.style.whiteSpace='pre'

let i=1,整=b=>i%b==0 ;for(;i<100;i++){if(整(3))P(i+"Fizz"+(整(15)?"":"\n") ); if(整(5))P("Buzz\n")  }
```

每次“拼接” P一个 i+"Fizz"+\n?+"Buzz\n" ，这很混乱，而且如果要给每行加点修饰(如让 Buzz 前也有i)，该如何？

```js
P=console.log
newA=(N,f)=>{let a=Array(N),i=0; for(;i<N;i++)a[i]=f(i); return a}

FB=N=>
  newA(N,i=>i+1).map(i=>{let 整=(b,s)=>i%b==0?s:""; return `[${i}] ${整(3,"Fizz")+整(5,"Buzz")}`})

P(FB(100))
```

没有用开头的3分判断，依然能优雅完成目标。 如果到处用P("hello world") 这种函数，反而不易写这个(a或b,a且b) 3情况了。IO缓冲(Buffer)是个好点子，切勿随处滥用 read/write (scan print) 操作！

善用函数，能使“奇怪”的写法也能自然调用。 正确设计的子程序，不需要文档就能展示用途

```js
并立=(q,q1, a,b,ab)=>{if(q&&q1)return ab; if(q)return a; if(q1)return b; else return "";}
并立=(q,q1, a,b,ab)=>q&&q1?ab : q?a : q1? b : "" //JS里定义是语句，没有同名多义(多态)等编译期“静态”规则

newA(100, i=>(i++,/*后得到*/ i+并立(i%3==0,i%5==0, "Fizz","Buzz","FizzBuzz")) )

名=i=>([/*0=*/"石头","剪刀","布"]) [i]
局=(a,b)=> 并立(a<b, a==0&&b==2, "赢","输","布包石头") //其实 (a+1)%3==b 也符右条件。

乘法表=newA(9, i=>(i++,newA(i/*每行i有1~9个j.从上往下看逐渐变长*/, j=>`${j+1}*${i}=${i*(j+1)}` ) )
```

你可以缩小算法输入来模拟执行： i,a,b 的值域都是 0~2 (即0止3)，(定义域是整数int)，选几个边界情况就能明白代码为什么能用。

边界情况与模拟输入，再怎么强调也不过分。 程序是流动的，无重点死磕或堆砌无涵义符号不是一种编程方法

选择简单有理由的设计、语序侧重与复用的智慧 ，不要临着报错去堆砌

### 2项1块计算器

```
变数ac=a[0]
(1止a的长)“(1~a的最右) (i<=a的长-1) (a的序号 始1)”升2 带其右去看，[是 x op] ac=算(ac、op、x)。
```

### 1~100 的和与积

项数* (b-a)/2

十进值“123” 就是用等比数列表示的。最右是 `3*1, 2*10,1*100`

>1e2表示1后有2个0，即1*(10**2) , 10**-2=1/100 。IEEE754浮点是不精准的 别弄“1.5元”(15角钱)，浮点rand()于闭区间0~1 ，整数rand于闭0~INT_MAX ，用%N 取<N的值(余数) int区内取值有限！

>(x**N) 求根x(sqrt)和求重复量N(log) 使用的算法没有数学上那么自由。with(Math){log(8)/log(2)==3} 。Math.log=ln, 而ln=log E;lg=log10 ，而 E=积分极限 `a=>a.reduce((sum,x)=>sum+ (1+1/x)**x/n(a))`

`i=1~a; sqrt(i*a)%1==0` 是整数，完全平方数；或者 divmod(i*i,a)

>`(1/x+1)**x` 是x次乘法于原数里每个“1”最大增长率，和圆周率M_PI一样自然，有 `e^{i\pi}=1` 公式囊括“自然”工具(虚数=向量,`-1*-1 =-1,0自正右左转90度` )。然后有log(x^a)=a 换底 (b^?)=x ?=任xa.(a^?=x)/(a^?=b) ; 如 x=100,b=10 ,a=2

看不懂没关系，一些问题作者也在学习，有缺漏甚至错误很正常。多学点相关内容，平衡前进吧

### 1~100 内猜数游戏

`[[1,7],[3,20]].map(([a,b])=>[(a+b)/2,a+(b-a)/2])` //相同. a-a/2+b/2 = a/2+b/2


不减枝穷尽搜索空间(可能解)的算法还有3行百钱百鸡：

>一定能在log2(100) 整顶是7 内猜出答案。(floor整底 round整取 ceil整顶)

和数位逆序：

### 十进值移位/+列表yyyyMMdd

2位10进制有10**2 种状态(组合), 任1位是 0~9

>低位称LSB(最不重bit 个位),高位称MSB 。人读数是高位在左“大端” 0b1<<2==2 即0b10

>一些文件格式是高字节(8位)在前，需1次8位的拼回x86的“小端”令机器识别，但这些和<<等运算无关

1987~2020 有多少个星期五？ (4年1闰,366天 百年1整)

另，罗马数字 IXCM=1,10,100,1k 而 VLD 表示它*10/2 。若大单位右则扣除否则累加(如IV=5,XCIX=99)

二的整次方：不断/2 if(%2==1)AC++; 即toString(2) 仅含1个"1"

### gcd最小分块

最大公因数 gcd 依靠分治法。因数指可整除x 的数，肯定在 `1~x` 里，但公因数怎知道？最好把 a b 视作两块地。

a%b 就是a多出的单位。现在问题变成在(b,多出的单位)里 找最小分块！直到没有多余单位，当前块a 就是最小块。

左补0满任何一个公倍数可以优化 2,8,16进换算

>Base64(basenc,btoa) 正是把3byte(2**8) 转4ascii(2**6) 的凑位编码，每byte余2位 3次1整

还有个找所有最大因数的和。也是分治 `n=>{let ac=0, i=n-1;while(i-->2/*4因数*/)if(n%i==0)n=i,ac+=i;  }`

### fib与99瓶啤酒 递推(伪递归)

递推是种写循环的更好方法，在变量更新复杂时尤其如此。

```js
//基线 : 递归
id=x=>x==0?x : id(x-1)+1
//递推法
id=(ac,x)=>x==0?ac: id(ac+1,x-1)
//等于
id=(ac,x)=>{for(;x!=0;ac++,x--); return ac}
```

递推让循环更明确 且易换为递归，但因为 Java/JS 这种语言没有尾递归优化(TCO) 或没默认参数重载，往往还是只能用 for

__相对的，能换成递推的递归无法自动优化为循环，会重复算 id(4)=id(3)+1 ,id(9)=...id(3)+1+1+.. 。__ 永远仅用递归进行「问题集可扩张」的计算，或选择网格DP

```js
fib=n=>{let a,b=1,c=1; for(;n-->0;c=a+b)a=b,b=c;  return b}//0,1时得1 。c是1,2,..

fib_=(n,a,b,c)=>n==0?b: fib_(n-1, b,c,a+b)
fib=n=>fib_(n,0,1,1)
fib=n=>n==0?1: fib(n-1)+fib(n-2) //递归。若把重算优化为视口缓存/留所有b 就有点像DP. DP内子问题不相互独立 缓存起很自然
```

```js
int C=0,a=0;
for(;;){ if(b>3){b=b-3 +1;} else if(a==0)break;else{a--;b++;} ;C++;}

let a=newA(5,i=>Array(2022).fill(1)),i=1; //整数拆分
for(let j,x;i<5;i++)for(j=1;j<2022;j++)for(x=1;x<j;x++)a[i][j]+=a[i-1][x]//实则所有左数和
//f(i,j)i==0?1 : sum(1~j, x=>f(i-1,x))
//但依旧有重复，j-1 是 <j选区的子集 +a[i-1][x] 即可
let a=newA(5,i=>Array(2022).fill(1)),i=1,j; for(;i<5;i++)for(j=0;j<2022;j++)a[i][j]=a[i][j-1]+a[i-1][j-1/*左*/]

a=newA(3,i=>newA(4,j=>i*4+(j+1) )) //z打印
a.flatMap((_,i)=>_.map((x,j)=> [x,(i*4+j)%2])).sort((a,b)=>a[1]-b[1])

let a=[],d=[0,1],  ad=()=>a.push(d),bend=c=>{  } //1,-1:1,0  -1,1:0,1
for(let i=2,j;i<4;i++){for(j=0;j<i;j++)ad();  bend(A);bend(B)} a.concat([0,1],a.map(([y,x])=>[x,y]))

线=n=>{let i,j,d=[1,-1],右=[0,1],下=[1,0],a=[右], ben=([y,x])=>{a.push(x==-1? 下:右);d=[x,y]}
for(i=1;i<n;i++){for(j=0;j<i;j++)a.push(d);  ben(d)}
return a.concat(a.slice(0,-1).map(([y,x])=>[x,y]).reverse() )}
穿=(a,d)=>{let i=0,j=0,r=[],点=()=>r.push(a[i][j]); d.forEach(([y,x])=>{点();i+=y,j+=x});点(); return r}
a=newA(3,i=>newA(4,j=>i*4+(j+1) ))
穿(a,线(3))

p=console.log
线=(n,f)=>{let 右=[0,1],下=[1,0],d=[1,-1], a=[],直=d=>{a.push(d);f(...d)}, ben=([y,x])=>{直(x==-1?下:右);d=[x,y]};
 直(右);for(i=1;i<n;i++){for(j=0;j<i;j++)直(d); ben(d)} a.pop();for(let[y,x]of a.reverse())f(x,y)}
{let i=0,j=0; p(a[0][0]); 线(3, (y,x)=>{i+=y,j+=x; p(a[i][j])}) }

Z=(N,f)=>{let A,B/*"/"扫描线,A竖B横*/, i,j, q=1/*"/"升序*/,nu=n(a),m=n(a[0]);//与线试交集
for(A=0;A<N;A++){i=q?A:0;j=q?0:A; B=A;do{if(i<nu&&j<m)f(a[i][j]); if(q)i--,j++;else i++,j--;}while(B-->0);q=!q } }//穿梭,翻转

Z=(N,f)=>{let A,B/*扫描线,A竖B横*/, i,j, q=1/*"/"升序*/,na=n(a),m=n(a[0]),P=()=>{if(i<na&&j<m)f(a[i][j])};//与线试交集
for(A=0;A<N;A++){B=A+1;if(q)for(i=A,j=0;B-->0;i--,j++)P();else for(i=0,j=A;B-->0;i++,j--)P() ;q=!q} }//穿梭,翻转
b=[]; Z(4+ 4/2+1, x=>b.push(x) )
```

要问拆解，都得非常清楚如何构造、子构件的限制

最长公共字串 是问文(a,b) 各自的所有后缀里，最大 与对方相同的前缀。比如 dish,fish ; finish,tinie ，显然是 nA*nB 次计同前缀，但会有重复计算

从网格的角度，横i=dish , 竖j=fish ，`a[i][j]=(s[i]==s1[j])? max(a[i-1][j],a[i][j-1])+1 : 0` （上左里最大的值，a[0]和a[?][0] 都填0）也实现共同前缀的比较。

横aaa,竖abc ，行1 都会是1 ，给了aaa,bc 子串累加前1行的机会；交换横abc,竖aaa，列1都会是1 ，给了累加前1列的机会 。填完网格，矩阵中最大值往左或上数 就是最长公共子串位置


>请用递推重写二分查找

杨辉三角：

```
   1
 2 4 2
3 6 6 3
```

每层数 层0=1 从1开始是前(n-1)*2 。左右对称， ~~以2项1块 3 3=6 6~~ 每项是上层2项或(1)之和，当然可用 a[i-1][j]+a[i-1][j-1] 指代俩6=2+4

```
4 9 12 9 4
5 13 21 21 13 5
```

但是观察左面 1, 2 4, 3 6, 4 9 12, 5 13 21 ，得每层 a[0]增1, [1]+=(1+层号) 4,6,9,13,.. [2]+=(2+层号) 12,21？ 好吧， 21=9+12, 所以 [1]+1 = 2,4 再[1]+ = 3,6,9 。即 a[i]+=a[i+1] ; a[右]=a[右-1]+a[右-2]

…好吧，观察右面！每次往右推个1 ，项i=1~最右 +=项i-1 ，先是项0 没有左边，它=右两项和

```
    1
  2 |3 2
 3 5| 5 3
4 8| 10 8 4
```

对称的部分在行[3] 是末2项。 裁掉i-2个，然后i-1个逆序

F(i)/F(j)*F(j-i) //F=阶乘 纵增大,横(中心远)减小

### 汉诺塔

任何递归(调用自身)解是由 __基线条件+扩张问题(视情况)__ 两部分组成的。如求值[op,a,b] 式嵌套列表 `['+', 1, ['*', 2,3]]` ，基线条件就是a|b 是数，扩张问题就是子树先求值。

而因为顶层也能是a|b式数，把“是否是数(叶/终点)”加在基线(能取t.a,t.b前)直接ret即可 。若“视情况”能加在基线，别给递归调用加if (好比 `JSON.parse('"1.0"')` 也该行 别if "[] {}" 内是不是数)。

Hanoni 是(A,B,C)3柱子和A柱N个圆盘下大上小构成的。 要把圆盘移到C，但过程中不能出现上大下小，问可行步骤

显然全部移到B柱是逆序的，但对小先2项 ab, a->B,b->C,a->C 是可行的。此步骤完成后 A实际上能充作B柱用，实现C->B (任2项自由移动)

推广到3项： 前2->B ，末1->C ， 前2->C  ；4项： 前3->B,...

```js
H=(n,A,B,C)=>{if(n--!=0){H(n,A,C,B); P(`${A}->${C}`); H(n,B,A,C); }else P(`${A}->${C}`)}
H(2,..."ABC")
```

在[DFS](#于图)里，递归用于有方向的扩大搜索空间(穷举范围)。 许多暴力用for或DFS 足矣

```js
split=(s,sp,...sp1)=>s.split(sp).map(x=> sp1.length? split(x, ...sp1) : x)
```

```js
搜=(酒,花,店)=>{
  if(酒|花|店<1)return; //酒<1||花<0||店<0
  if(酒==1)throw [花,店]
  搜(酒*2,花,店-1)//可把路点 push 一下，这两枝改
  搜(酒-1,花-1,店)
}
搜(2,10,5) //遇10次花，5次店，最后遇花正好喝完酒。找组合

//从1,1 做 +1,+1有多少到5,4 的路径
```

x,y为正且(*)不大2021

k=100000
(1+2~2021)升2 去叠(1)，(我*它)%k。
事 归(n：数)=若n是1，n。否则，归(n-2)*n %k。

商品内俩号组合去找极大，[是 a b、i] b-a。

再如走迷宫，每点要继续走上下左右4点，得出可行的路径。若4邻里新点是墙(=null)或目标点(=得[])，这叫基线条件，统一放在函数头部。 __没到基线，必扩大问题。 到了基线，也只是此点退出__ 其他可能还在搜，甚至可能重走这里。直到穷举可能组合

路点必须在递归前 push, 后 pop ，以模拟调用栈。或者可以靠返回值，若不空 把当前路点加上(回溯法)，整体再reverse。

### 函数图

你马上要熟悉列表处理，在这之前先从行和(每行长) 上分析下九九乘法表(不是81格的那种！)

注意这个图形上下左右都是对称的。一般要4*for ，把每行视为 空白((n-i)/2)+星号(i) ，中心i=n=7 然后i再降至1

如Z字形矩阵排序（从横A纵B 00 右滑连线 正走1遍 逆一遍） ，其0~1 百分比的思想也利于理解中心翻转(yx同时)和转置

额外了解： Session/Cookie vs. JWT, UUID, (Time/Count)OTP, DHT(dyn hashtab)

### 指针

指针是C对内存的不严谨建模。内存可以理解为 malloc/free 的 byte[] ，指针是可+-*/的地址，允许越界读写的发生。

C 里没有字符串或“数组”，因为一切都是无长度的(比如strlen,strcat 是基于 '\0' 字符，argv配对argc，列表增长要 realloc 或链表)

```c
int* f(int a){
  int* x; x=/*读作绑定a*/&a; *x/*或其=val 等价变量a!*/; return x;} //参数a 的临时空间 在调用栈上。 返回时已失效！
```

指针对Java,C# 乃至Py(new 都不必写出) 的用户非常奇怪，毕竟在C时代你要处理一些特殊硬件地址(比如BIOS CPU执行权入口0x7c00:"\x55AA..") 也没有OOP(C++iterator,foreach)那么好用的数据集封装方法。

那些语言用GC管理对象(数组,行,表,.) malloc和free ，没有在全局或栈参/局部引用(GC Roots)的，可随时“删掉”(解除独占分配. 所以警告但能运行 别随便信!) ；而Rc 则是受引+1 结束-1 ，为0即回收。weak_ptr 和 Py GC 模块解决其环形引用问题

>相关参考 C++ `using sp=std::shared_ptr` ， RAII(资源首访初始化)，《Ruby原理剖析》(M&S bitset未标记则清除) 《Lua设计与实现》(可暂停GC)

指针计算就是 sizeof 的计算。若 szInt=4, sz(int a[2])=8 ，  `a[1]=*(int*) ( (void*)a+1*4)`。 这也是0起始序号的原因(不谈 < 号和 % 取余的方便)

>C99 引入了临时数据体，任何需 `(struct {int a,b;}) {1,2}` 的地方都可提供 {} "初始化"，union同样(compound literal 组合常量)

x86给了C 以 1,2,4,8 byte 对任意地址做(有负)+-*/ 的能力，这就是 char,short,int,long (unsigned)类型 乃至 4,8字节 float,double 。而 movzx(0填拓宽) 是类型转换/数值提升，lea 和 mov rax,[a+偏移] 是取指针。 C __结构都是由内存片与地址引用织出来，每个访问语法都从指针起始算地址。__

struct{A a;B b} .b 代表其变量地址 +sizeof A “具名组合”，和 union 即列举强制转换 “无type标签 分支” 。二进制读写器和 Luajava 等FFI 就是在做这些的严谨化

> .rodata 只读常量(字面量亦常量,但字串外常可存指令内) .bss/data 段=static(初0?)量空间 .text 已汇编机器码 .got.plt LD动链dlsym跳转表 .dynsym/symtab-strtab 动静态链函数表

>(Linux)参见 memset(calloc会填0), memcpy,memmove , mmap / mprotect (shellcode)。 `gcc -S -o /dev/stdout -xc -` 或 `objdump -d x.so` 可试看汇编，strace 和 gdb 可 `catch syscall`(如堆增大的 brk)

## 于组

Map<K,V> (于Array, 预分组hash(K) 和Trie, Tree 恒有序集)

### Hash为组

想象你面前有排桶(桶=1行项)，要把手里的彩球扔出再看心情找回，最好是按大致颜色分组。 但这球色也许是相似的，桶数很多时，也许只集中在前几个；要是戴滤镜(hash) 打散整个色盘，球就不会冲突扎堆

`int hash(int x)` 类似 MD5,SHA1,CRC 等文件(字节组)摘要算法，它把 int 值空间均匀分散(意味着内容相似hash可能很不同)，getset时对其 %(取余N 得< N)当前桶数 即得其组位置，然后遍历找K 取/改V。

```js
class Map{
  get(k); set(k,v); entries(); [iterator](){keys}
}
```

`StringBuilder` 的存在是方便拼接文本，而不用 s+= 是因为内容固定的 String.intern 实现更利于 Hash 查表一些 Lua 也这样，所以 s+= 可能会生成许多临时文本

>许多语言里用join 和模板字串 `"a${1}" @"{1}" f"{1}" "#{1}"` (Kt/js反引号,C#,Py,Rb) 及 format/asprintf/sstream(Java,C gnu,C++ qt) 是个好习惯

>编码encode、加密encrypt、摘要digest 不一样，尽管"en"它们的结果都像(16进制)乱码/密文，"de"解码无需密钥/公私钥 而摘要根本不含原文！

### 二分找

那么要KV表按K值有序(如添加序)遍历，如何？ 你可以额外维护一个K的链表，但遍历要每项 get(k) 查一次，现在你也知道 Hash查表是有开销的。

C++ std::map .find 正是基于有序集二分找k的KV实现，unordered_map 才算 Hash

>当然维护KV链表就可以按添加序。TreeMap 主要的功能是取一个范围(最小不小,最大不大) 的KV ，它的效率往往也不比Hash低

### 二叉树

整二叉树(叶层之父都有俩叶,类似1+2**下层数)

### 前缀树

>按文件名排序是怎样？先 a-z ，再 aa, ab.. 也就是求前缀和 s[0] 的权最大，再是右位..

也叫字典树。层0代表 s[0] 所有可能字符:其后缀 至 层有K='\0' ，get 确定1字 `d=d[s[i++] ]` 即缩小范围，若层含'\0':v 代表有过 set("ab",v) 值。走到无 `d[char]` 了就是终层(有v则取 否则可迭代其后缀!)

惰性KV创建：

若添加 "ab"=1, "bc"=2 会创建1+4个{} ，b:{\0: 1} 即便没有后项也占空间！优化是在 get 遇非{} 值=无后项，set 遇k:1 切分为 {\0: 1} 再加右字

然后后缀树：

把同前缀连起来，创建时可按后缀切分。也是种路径压缩

### AC机

如果给前缀树的每点定义失配后回退到哪(显然是路径最右的“前缀”)，就能保证文内每字只见一遍就找到所有匹配。KMP(strstr/indexOf) 是单匹配的AC

简单strIdx(s,S) S是较短串，穷举 s.slice(i) i=0~(ns-nS) 若以S 起始则得i，会造成重复比较(S内指针回退)

#### Sunday

### 栈队序和链表

sysmon.exe 和贪吃蛇就是队列，但前者队长恒定，可以用 RingBuffer 环形指针增实现。心电图的“写位” 左~右 往复，若读位(视口0点)也跟随，就是环形缓冲“不断左滚”

贪吃蛇的蛇体是队列，每帧按当前向入1点涂黑、(若未吃果)出1点涂白，长=2 头部当然是“留最久”的

>队或栈像有 len 及  `add(x)` 和 `pop()` 的行，队是先入先出，栈是后入先出(像电梯)

在[C指针](#指针) 说了数组-内存的对应很简单，但在小内存设备上，是不能1下分配 `char buf[1024]` (1K)的空间的，最好的方法是1次1分配，再把内存片串起来- `[1,2] = [1,[2,null]]`

这样很适合每次完全访问的情况与后进先出序(善用递归的Lisp语言常用)，但一般只会用双向链表和 SkipList ，只应对输入量不稳定的情况

```c
#define data(T,...) typedef struct{__VA_ARGS__} T;
data(LList, int x; LList* xs;)
llEach(LList* o, void(f)(int) ){while(o!=NULL){f(o->x); o=o->xs;}  }
LList* llAdd(LList* o, int x){LList o1={x,o}; return o1; } // pop()= o.xs
```

再比如，怎么取链表N/2的项？快慢指针，快者到头就求出N了。

怎逆序print 1链表？ 首先 if(!xs)return; print(x) 栈，然后遍历链表 创建链表 也是逆序的


## 于图

有向图是箭头组成的： `下点：Map<K, List<K>>` ， `a->b->c ; a->f->c` 就是“歧路”的图

可不可以 for(a于图)for(b于图) 随便举两点的排列？那你在a点，箭头没指的点你怎么1步走到？

当然不必这么麻烦

穷举。实际点走迷宫，解集就是有限的很明显，每点的上家是唯一的。可缓存以加速

### dfs 于2D像素图.点邻

N项组合的所有情况，量改变间有规律约束，而不是有区间两项 __组合。__

>每项3可能的(不重复)2组合<= 3**2 ，像 a-b-c 1a:Nb 建立连线。 __所有排列"P"是__ 3x2x1 阶乘 3! 。在N项中顺序选择k项，有n!/(n-k)! 种可能(组合"C"则 (n-k)! *k! )

来实现一个列表乘法“笛卡尔积”..

```js
//1 map=1 for. N**2 组合只是 N*N 的特例，下12,34 =1212的情况
[[1,2],[3,4]].reduce((a,b)=>a.map(x=>b.map(y=>[x,y])))//1314 很好. 你会得到n=2 的二层数组. x=> 的结果是x*y 个数的[x,y] ，铺平呢？
split=(s,sp,...sp1)=>s.split(sp).map(x=> sp1.length? split(x, ...sp1) : x)

split("一依,生世",",","").reduce((a,b)=>a.map(x=>b.map(y=>[x,y])).flat() )

[[1,2],[3,4],['a','b']].reduce((a,b)=> a.flatMap(x=> b.map(a[0].map?/*若已组合2项,添加尾部!*/ y=>[...x,y]: y=>[x,y])) )

comp=a=>a.length==1?a[0].map(x=>[x]/*首项.只有N个可能*/): comp(a.slice(1)).flatMap(y=> a[0].map(x=>[x,...y]))
```

走迷宫是图搜索的(每点均4邻-边)特例，而 4=1+3=1+1+2.. 拆解也是对“含无穷点 图”的搜索， +3,+1 这些是点的边 以此达邻点

然后排列是输入1行。 每项在(余项的所有情况) 里每位置有出现，如 [1,2] 里 1在[2] 的0,1 有出现(1x2 阶乘)

有个缺点，就是穷举的次数太多，没有进行减枝。

因为每格是不能重走的，每点有确定的上家。比起创建 `已走：真假[]` 即 `已走：集<点>` 减枝，更好避免重复搜索的方法是 `上家：点? []` ，如果是空才把自己设进去，并在新点继续。 实现给p0搜单次 任意可达p1都能回溯出路径『记忆化搜索』

如果不用 `上家` 表，只有DFS能记路径(深/远于行最右才可维护步序)，BFS只能得出可行(全部)解。DFS全能也方便，但BFS 平均扩散，会更快达到靠近的解，且能在整个扩张集自由选择步序；二者都不一定达到最近的解

有种 BestFS 按每点相对方位决定邻步进序，而真正用于游戏AI的是AStar 启发式/JPS直线搜索

每点有四个邻居，不能重走。走到或墙或目标停止。 每点分出四个人向前探索，如果走死了就让它停(四面都无路 折返径也不能重走)，在进死胡同前还有人要继续搜索别处，就像for for 循环 break 了还有外层


>3=3+0=2+1=2+1=... ，求所有组合。

此问题就可以把“邻居”在 0~2 里选，剪掉重复的和(已走点)。 搜索和为3 的路径。当然(a+b) 如 1+1+.. 是可以随递归缓存的，没必要每点从完整路径算

>有2x2格 "爱我" "华中" ，求从0点走有多少 "爱我中华"

同样是地图问题，加了个 a[新步]==s[i+1] 的减枝替代 a[新步]!=墙 而已。 只要从s[1] 每步字都对，整个路径前缀至整体就是"爱我中华"，每点上家可能不确定 不必记忆

"爱我中我"
"我中华爱"

Dij

有个显然解 a 对 b 内每位置测试前缀相同长，然后取最大。如 "abc" "cab" 就只有 j=1 同前缀；但反过来 cab 试前缀 abc 呢，于是这是要把a全前缀与b全后缀配对，复杂度N*M

在尝试全缀比较时，a[0]与b[0~] 比较，再是a[1].. 得真假值行。某处相同 下行 这个位置就+1 。完整的规则是，左和上的最大值(或0)+1

## 排序

排序虽然花样多，但能解决的问题…… 也就只有按小先/大先(升降)序 遍历，没啥非“默写”的题可出

选择、冒泡

插牌

>冒泡&双向冒泡、插牌&二分找(左项<它)位 是优化版本

有序合并(merge)

>Shellsort是分组插牌，Py Timsort 是预规划N组合并

```java
//归并排序：细分4项=2+2 , 直至绝对有序的1项列表区间，有序合并 直至整体有序
class Main{static public void main(String[]ar){
排(0,a.length);System.out.println(java.util.Arrays.toString(a));
}
static int a[]={5,4,3,2,1};//需 a[i]<a[i+1] 的组

static void
排(int A,int B){
if(B-A<2)return;//剩1项 绝对有序

int iC=A+(B-A)/2;//A~B中点。
排(A,iC);排(iC,B);
并(A,iC,B); //现在 (A止iC) (iC止B) 各自有序，那么合并
}

static void
/*有序合*/并(int A,int iC,int B){
  int i, iA=0,N=iC-A, iB=iC;//输出、两边指针
  int[] a0=new int[N]; System.arraycopy(a,A,  a0,0,N);//左部可能被覆盖(因右<多) 故复制

  for(i=A; iA<N&&iB<B;)a[i++]=a0[iA]<a[iB]? a0[iA++]:a[iB++];  //小者优先。 若有剩：
  while(iA<N)a[i++]=a0[iA++];
  while(iB<B)a[i++]=a [iB++]; //注意勿在连续a[i++]=里判断两行是否有余项
}
}
```

二分深入(qsort)

>也有复制(非原位改)版，指针用的少很多

大顶堆

>堆是指整二叉树，不是 `malloc` 的堆

大顶是指1节点 (a b c) 里 a 比b,c下级的所有“a”都大，从这个角度堆排序很像二分版 Radix ，建完堆 后序遍历即小先， 先序遍历即大先。 易于解 topK(首K项)

桶

>这是种排序策略。先分桶，再应用子排序

计数

基数(数位)树

>Radix树是前缀树(K=int)的特例

先看一个bitset数字去重的例子。 整数都可视为 `0b110=6` 这样的位集合(bool[] )，用 a^b (xor) 可看出行里每1位出现奇/偶次(与首项同则偶.)

用位交& 搜重复，再二分看重复的哪些在左 哪些在右——但位可不止两个，最好是按重复位分组。第1位相同, 再 2, 3.. 检查这些里面有没有重复；实际就是基数排序， 它把某二进制位相同的移到一起，然后几区复制轻松删重

移动的过程可以理解为二分深入，左侧是满足 bit1=0 ，继续直到 bit31..

## 额外

### 浮点

理论上浮点没有 a==b (.1+.2!=.3)，只有 `abs(a-b)< Num.EP` ，所以 0.5 元应存为 50角钱，不要利用小数点。 ES6(Ruby,Py则默认) 还引入了 `BigInt(1n)` 大整数。parseInt,isNaN,isFinite 很常用 也有人用 Number或 +"1" 隐转换

Math. random abs min,max sign(-1,0,+1) 是比较常用的，pow(10,2) 是 10**2 ， floor/round/ceil 是取(低/中/顶)整，trunc 即 >>0 会直接去尾数(n-n%1 , -.9>>0==0)

整数：随机 rand()%b =0止b， 向上先除 (a+b-1)/b*b 向下除 a/b *b  乘除 `2 **n = a<<n  a>>n` 那么余数是 &`(2 **n-1).toString(2)` (勿用!)

```js
[1,2,4,8,16].map(x=> 2**(8*x) -1) //byte,char short int(/boolean,64位也4byte!) long, longlong(39位10进) 等 intx_t 最大值
//JVM [BSCIJFDZ ，Z=bool,J=long 因Ljava/lang/String$innerClass; C是2byte UTF-16 ，能编码大部分中文 以及双码单 字(CodePoint)。UTF-8 则更好与 ASCII-8bit 相容
//hex编辑 byte halfword word(字/精) dword qword/gaint ;gdb help x/4x
```

补码： 8位二进制极值 -256~255 (2**8-1)    ~n 位取反是 -(n+1) ，因为将左1位解读为负号，整体取反 ~0=-1 位交集就能实现+法，无需再定义负+- */

(a)sin,cos 和PI可用于向量(矢量,箭头)计算，exp(x) 指 `E**x` ，log(E**2)==2 ， log(100)/log(10)==2 ，是求乘法次数。底数只有2,3 次的 sqrt和cbrt

JS的隐转非常弱智，`[1]==true`,  `1..toFixed(2)` (分词问题的变通。正常人都加括号的吧.. 还有 `void 0=undef` 搁常量上做甚文章, Lua根本不允许 `{["a"]=1}.a` ) 。但幸好没有 `a=true; 1==a&&2==a` 或 `True,False=False,True` 这回事，不然可真行

### 复数

复数(complex. Py `实+虚j`)就是2D向量，只有乘法和“分量同算”的“自0点箭头”向量不同

共轭复数std::conj是相反向量. polar(abs长,arg角) 得原。p/长=同角长0~1的单位向量、p*p 后可比较长度。

>向量旋转(xy,r): XY=cosSin(r)  xX+yY,xY-yX 改于复数(xy,XY) xX+yY,xY-yX 是相同公式。

`with(Math){asin(1)/PI}==0.5` 圈(自正右向左)，所以 `-1j*-1j ==-1` (-1右转半圈),实部则 `(-1+0j) * -1+0j ==1+0j` 。要正上顺时针，XY=sinCos(r), xY+yX,xX+yY 即可，由初中几何“两角和差”证明恒等。

js角(弧度=0~2PI) atan2(yx)。上polar() 将点的座标以(长l角r) lcosr,lsinr从圆心表示换回xy表示

用于简化(函数)线条、插值的傅里叶变换也正是把震幅和“相位角”缠绕积分在不同频的圆上，(t=0~1 即buf[0~最右] )所有圆震位 相加得原信号

信号只有1D(y轴)，能用1D 的FT吗？

都说了是把波动线缠绕在圆心求各频震幅和相位，如果用1D 无复数/向量就不方便了。即便是2D 求与圆上点差还是能OK，但1D 就缺失了相位角信息，只能提取周期性的傅里叶级数

### 像素

声音(N*samp, npSec sampleRate, nChan) 和图像(w * h * colorMode nChan) 都是由通道-采样组成的，

声音是(响度=振幅,音高=频率,音色=模式 所以2x会变尖)振动，图像是由RGB的分量混成的(尽管灰度lum也能表示轮廓)。通道=向量分量=1个数值 ，点的所有数值和点位 组成原信号

位图像网格(Excel表行i格j) `xywh ijnm (i<n,j<m)` ，你可以先y后x  y=i行,x=j行内格 。信号的处理如高斯模糊会以块(buffer,window) 为单位，一般512以上，但太大延时会明显

Alpha 透明通道用于指导叠加模式，比如以灰度图实现“橡皮擦” destination-out 的功能。 硬件(GPU,SIMD)混成使用 OpenGL GLSL 等加速计算语言对大量散点进行相同运算，所以说“缓冲”批量操作的思想很重要，能整体就别单步

这种滤镜思想对“普通”程序员会很奇怪，比如画个圆，迭代 sinr,cosr(r=0~2PI) 难道不更快？然而 sin,cos 的结果都是浮点数，

舍入有偏差和"子像素渲染"，而且它靠一个 Blit() 缓冲叠加每步矩形填充，是天然依赖顺序(单线程)的。善用图层缓存能加速绘制

因此于p点长l圆 对整数 P(yx) `abs(P-p)<l` 即 `abs(P-p)-l <0` 来填色/描边更好 。着色器和DIP/绘制 不是一回事，很大程度上是范围参照精准度的思想不同。

### 工程界

不要给“速度优化”找理由，任何处理用户交互的桥段，你代码的耗时会远远低于平台框架的，而且就这人也反应不到。人太慢了，即便能，代码也没有 `%timeit` 跑分证明

copy 和抽象(各式语法糖)开销是要尽可能避免的。 深拷贝=整体的copy， 新对象(map,slice)=改写(sort,reverse,)在复制上 ；如果能批量操作 splice(0,1), copyWithin(2, 0,0+1) System.arraycopy 就不要手动for

前端有 debounce,throttle ：限频执行。 冲突则无视、冲突则再延时

+ router 记录新页到 `history` (可添加 #hash)，`onload onpopstate` 时以参数(uid,..)生成。主页也不例外
+ babel 处理语法AST(嵌套列表) 展开不兼容的“短”语法
+ webpack 处理AST定义和引用，去除未用定义，内联资源到JS
