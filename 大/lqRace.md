# 蓝桥杯小练习

>B欢迎大家。你是湖北工业职院的学生吗？在蓝桥杯Java算法赛前，要进行一次特训，不然很可能全军覆没的

>毕竟这次靠的不是单纯的「熟悉几行代码效果」，而是要知晓 __加速查找、路径查找、嵌套树、项关联集__(BSearch,DFS,BSTree,UnionFind) 等算法的原理，没有踏实的编程基础是AC(通过accepted)不了几道题的。WA(wrong answer)是思路问题，不是多试错运行就能改好

>B确实。所谓计算机，失之毫厘谬以千里，迭代的区间 +-1 就是正常和报错，如果不晓得这区间， `> < <= i++ i--...` 要试太多次了

>但如果你一开始就 __知道比语法更高的思路，就不会陷入这类泥潭__。老实说这不是考Java语法，而是无关编程语言的思考能力（但只涉及极少数学）

>B幸好，某同学设计了这个指南。尽管是比赛，这次它一等奖的目的也只是科普，经过30分钟培训后，或许你能提高几分乃至AK(完成all complete)呢。

## S1.JavaScript语法

>B即便你学过Java也建议“重读”此部分。 此处『语法syntax』是指从 __数据、计算到列表处理的一切__；因为算法根本不是由框架函数的调用构成的，需了解基元步骤(如 `a[0]="1st"` 列表赋值) 以优化

在了解Java前可以先看更易测试代码效果的JS，Java只是冗长的JS。按<kbd>Ctrl Shift I</kbd>打开审查元素。点选下框，然后按 <kbd>Ctrl 回车</kbd> 执行代码
```js
说=console.log
说("hello world")
```

JS有3种类型：数、文、真假；如 `Number(1+1), String("hello "+"world")`, `结果="付款"+(余额<钱?"失败":"成功");余额=余额-钱`

结果=的右值侧： `"前缀"+(q? "败":"成")` 里 `q=(余额<钱)` 是 `Boolean(真1假0)` 型，它不宜抛去if判定单独存在

>于是我就在这1言里混合了 `"首"+"尾"=="首尾", 1<2 ==true` 和 `q? a:b` 判断 3种类型-的计算

>B但是这个翻译对中国人真不友好！我们改一下

```js
let $Y=true,$N=false, NO=null//空值，待会讲
说(1,"不二", 1!=2, /*!即'非'*/!(1==2))
说($Y&&$N, $Y||$N, !$Y,!$N) //且或判断，即交集、并集 和取反
```

>别问为什么。告诉我这有多少 `a•b` 形式的运算符。

>B`-(1)`,`!($Y)` 则只有1参、`q? a:b` 有3参，故称三项(三元)运算符

>三目什么的都是瞎翻译，照此法 a+b 叫双目运算 !a 叫独眼计算 就算术起名贼多，像什么缺省(默认)、使能(启用)、套接字(收发线)、上下文(变量域)、透明(不用管理)、非侵入(插件化) 逗得要死

`let 名=言,名1=言1, ...;` let是JS的变量定义句，分号亦可为换行。 言可以是 `"你好" , 1+1,n+1` 的常量|算式，名若要数字开头只能 `_0=a; _1=b;` 这样。 下文(项重复)语法简写似此处： `let 名=言,`

>/*注释内容*/ 和 //(直到行尾) 在竞赛一般不使用，但正常程序员不会对代码故弄玄虚、含糊其辞，就需要给代码块有意义的适量说明。试 <kbd>Ctrl /</kbd>

以上是语法的基本规则。但刚才的 `结果="付款"+(条件q? 失败:成功);扣钱()` 有个bug，失败会给人扣成负数。把扣钱移到?判断——的成功侧

```js
余额=100
支付=钱=>{果="";if(余额<钱){果="失败"}else{果="成功";余额-=钱} return `支付${果}！`}
说(支付(50))
说(支付(60))
```

>任务：把 `if(余额<钱) 改成 if(余额<钱 == $N)` “余额不小于钱”

>任务：把 `if(q) return a; else return b;` 定义成 `若(q, a,b)` 的函数。但请别使用此定义

>B顺便：入职后不要用0.5表示5毛而要 *10保存 /10显示，也不要从用户输入拼接凑任何SQL,HTML代码，不然你会死的很惨

你看到了语句版的 `q? a:b` 即 `if(q) a; else b;` ，冒号切分言 a:b里a,b也可为语句块 `{句;}` ，以执行2个计算-赋值 操作。 

若if无else 则= `if(q) a; else{}`。
言都有值(像1+2=3)。 `名=>言` 或 `(参名,)=>{句;}` 是个函数，它有些许参数，1个 `return 值` ， `支付()` 的值就是最后 `return` 的文本拼接 “支付{成功}！”

### 何为编程

__舞蹈就是在合适的时间，对合适肢体做既定的动作__。程序是会对输入执行无数遍的舞蹈组合(compose)

__编程就是在合适的契机、地点 执行某计算，把变量(如a+b里ab)凑齐 结合固定量(1,'a'..)，算出来__。计算思路高于代码：上条任务里你把if-else “地点”翻转了，但 __功能完全没变__。契机地点的重排，就是『设计模式』

地点即作用域(和this等既知量)，契机即函数调用。而回调(callback)什么的，就是对方代码能找到你的函数： `f=x=>说(x,1) ;库=()=>f(2); 库()`；参数化 `库=f=>f(2); 库(x=>说(x,1))`

>要想不记流水帐、mian条代码，「善用函数」必不可少。不要害怕编程里看似数学的名词，它真能帮你「提高智商」的！

>B我们学会了数文类型(及+与&|计算)和基本顺序、判断“句”(及其 `言? 言:言` 形式) ，

__优美的程序既要算法高效“快”，也需推敲代码写法“易读”。__


### 嵌套树

句可以含言或句 `{说("这是言"); if($Y)说("if是句",说("我也是言"+"")) }`，好比列表 `[ [1,2], [3,4] ]` 里的项仍是列表。

>思考：用鼠标指着{}里当前执行的代码前进，探索树的遍历；你能从这1行代码里归纳出啥“语法模式”？

`if(言){句;}else 单句` 里 `{}` 就是种“组合句” “句的列表”，层次：`{句;}>句if >言+- >常量1,""` ，JS 的文件级语法就是无{}括号 的组合句。

Java 语法却以 package import 开头后定义单 class{} ，不能含if等不确定性，在 `void main(String[]arg){}` 里才类似脚本，称其『静态语言』，与之相对即『脚本语言』『动态语言』，能拿 class{} 内函数签名等静态信息称为『反射reflect』。

此外 Java 会区分整数和浮点小数，`let x=1,s="ab"` 必显式写出 `int x=1; String s="ab";`，称『强类型』；JS 则允许 `String("2")+Number(1)==String("21")` 这种瞎(了“双目”的)隐式转换，弱类型。 Java也有 `Number x=(long)2;` 的宽化隐转但不会在+,==里混乱数文真假等类型

Java 不支持 `[] {}` 数据记法，所以有人用 `new ArrayList(){{add(1);add(2);}}` ，这是错的。Java8 已支持 `List.of(1,2)` 。永远不要为用到 而使用语法


>浮点和整数是完全不同的。除了 `.1+.2!=.3` ，浮点0~1间含有无数个数，整数 `0<=x&&x<=1` 则只有0,1

>B举个栗子，你觉得计算机里有“0.5秒”和“坐标点”吗？只有 500ms 和 xywh=0011 的宽高1像素矩形

>B你可以用 `1e2==100`,`1e-2==1/100`，但在计算机上过度利用浮点简化“秒=1000单位,”是不好的。

### 二叉树

类似 `{句;}` 列表， `0? a:b` 含2变量ab，它实质就是二叉树。 `0? (0? 1:2):3` 里左树右值、`0? 1:(0? 2:3)` 里右树左值；注意每层左右都可能是值或另一个树！（根节点都可被再被“包含”，如 `xx=(0? a:b)` ）

像数学多项式一样，把有模式的代码换成“矩阵”： `[a,b] , [[1,2],3], [1, [2,3]]` 。三元运算符 q?a:b 有三个变量，但上文q恒0，如何从“矩阵”即树，计算它？

```js
vis=t=>t.at/*是[a,b]形式*/? (0?/*a:b*/vis(t[0]):vis(t[1]) ) : t
后序遍历=vis; //点的值依赖子树

[a,b]="啊波"
例=[[a,b] , [[1,2],3], [1, [2,3]]]
说(例.map(后序遍历) )//map是什么、[a]="啊"又是？下章揭晓
```

我们用左右节点： (是树?其 a+b : n) 来算这些二叉树。这便是编译原理里『解释器Interpreter』

代码是可执行的对象，树也可执行；所以树是代码的一种体现，可以当成代码用(树属于代码、代码可为树)。这便是『子类型多态Subtype poly-morphism』，即严格的『动态类型Duck typing』。

C 语言没有子类，只能用 `struct{C fields; union {A a; B b;} x;}` 强制转换来模拟 A,B 含有某些共同属性(交集) C，要知道其 Type 是 A还是B (`x instanceof A`)，就添加 `int type=0/*A*/` ，这叫分支类型 tagged union

C数据有单一组合 `int a[N]`、具名组合 `struct{int a; char b;}`、分支 `union`，enum是新类型。数值和N次解指针，很好做[链表](#链接和连续)；C++ 提供了自动解指针的 `set(int& x,int v){return x=v;}`

>全文我会给大家讲大量的故事(_学习才是比赛的意义_)，但别忘了下文还有题目！ 这些可以回看时再思考

```js
add=t=>t.at? vis(t[0])+vis(t[1]) : t
//进一步抽象罢
vis=(t,f2,f=noOp)=>t.at? f2(vis(t[0],f),vis(t[1],f)) : f(t)
noOp=x=>x//不修改
说(vis([1,[2,3]], (a,b)=>a+b))
```

>任务：忘了说1二叉树节点 除了左右项，还可以有内容。试着把内容作为 `t[0]` 加入，t[1],t[2]=左右项

N层“整二叉数”的节点数=`1+2**(N-1)` ，即 `Math.pow(2,N-1)+1` ，层0有1节点，以下每层内每点有2项。

在把整二叉树储为1数组时： `N=n**k` 是nk次方(n乘法并列k次)，对数 `k=log(2,N)` 即 `with(Math){log(N=16)/LN2==4}` 用于求N内n(=2)次数k ，例如 `log2(65536)==16`

这被称为堆(不是内存分配链表的堆! 却是堆排序的堆)。 实际上树状数组(1D行化-规整拓扑结构) 在OI里有许多，不必为此头疼。 根节点在 N/2 ，其左右 N/2-+N/4 ，这样。

实用上，二叉树可以用区间操作、查找减枝，例如二分查找、(字典树)前缀过滤。 红黑RBt就是一种始终左右体积平衡的AVL二叉树。

树实质是由节点和边(此即 `a[0],a[1]` 等行序号)构成的单向图，待会我们谈图的算法（游戏AI都会用到）。

>B总结：二叉树节点是由 `t=[x,a,b]` 3项组成的，其中 a 和 b 可能是又一个 `t`

>附加：利用 `['+'或'*',a,b]` 的嵌套做一个计算器； 目的：理解项x即t[0]的意义 。下文任务目的不再由我说

>附加：`uint16_t` 即正整数位宽16 的最大值是65536-1 (0值占1个编号) ，从65535这个常量求 `int16_t` 即整数位宽15 的最小最大值 `[-32768,32767]`

>B思考：为什么不同位宽整数在SQL,Java,二进制编辑等地有如此多的命名

### 条件重复(循环)

文 `s="abc"` 其实是由字构成的。 `s[0]=='a', s[1]=='b'` (`[s0,s1]="ab"`)，那么既然要把不定长的数据 算到一起，仅if就不够了

>`while(条件)重复句;
for(定义;条件;尾操作)重复句;`
其中 break=停下循环; {continue; b;c;}=略过bc句 (也有 `out: for` 的带标签)

一般仅使用更易读的 `for` 来定义重复处理。

```js
for(let i=0;i<5;i++)说(i) //i=0~4 或 0止5

a=[1,2,3]
for(let i=0;i<3;i++)a[i]=a[i]+1 //每项+1
说(a)
```

3是a的长度(项数)，但写死太傻逼了，我们完全可以聪明点

```js
n=o=>o.length//适于 n("")==0, n([])==0
map=(a,f)=>{
  for(let i=0;i<n(a);i++)a[i]=f(a[i],i)
  return a//会直接跳出map函数，返回跳入点
}
map([1,2,3], x=>x+1) //仍是每项+1
```

>B永远铭记：没有“聪明”的代码是必须复杂的，无论谁，__复杂必然是不成熟不广泛的体现。__ 物理科学是寻找规律，规律必然是简单的。__复杂源于堆砌简单。__

>不要背代码。代码只是在基础语法和函数上，做法的体现。学语言、背功能点。 不要背代码文本。

现在你认识了列表处理，它是算法的基元(最小单位)，你以后定义的“数组计算”不会和map这种函数有调用参数上的区别。 `[1,2, ...等项]` 我们称为 __『行List』__，它是长度可增的『数组Array』。JS 里数组也有行的功能，JS更简洁。

如果要将 `a=[1,2], b=[4,3]` 等位求和，就是把两行拉链成一行

```js
拉链=(a,b,f)=>map(a,(x,i)=>f(x,b[i]))//x,b[i] 是等位项

说(拉链(a=[1,2],[4,3], (a,b)=>a+b),
a)//现在a是多少？ 若需a内旧值，则要浅copy 行a，但这里不必。 许多算法首先是要减少多余内存分配

newA=(N,f)=>{let a=Array(N),i=0;for(;i<N;i++)a[i]=f(i) ;return a}
说(newA(5,i=>i*2) ,a=newA(3, i=>3- (i+1) ), a.sort())
```

>试着习惯“横着”读写代码，像看文章段落一样理解 `newA=(个数N,序号函f)=>`。

>B提示：把代码挤在一块或者拿中文命名是「不规范」的。为什么我还要这么写呢？
因为哪怕把newA写成5行， `newA(2,i=>i)`都只是 `[0,1]` 而已。 在极短和极繁外我选择了语义

>B任务：拉链不支持ab一长一短。下文再要干啥我不再多说。

>思考：[0,1] 的值域、 newA(3, i+1 里i的值域、 3-(i+1) 的顺序、寻找其与 2-i 的“合直觉”等效关系(可以数学 x-(a+b)=x-a-b ) ； sort 是干啥的？

```js
算链=a=>{let ac=0,op='+', x;
  for(x of a){ if(isNaN(x)) op=x; else ac=eval(ac+op+x) }
  debugger//思考： 模拟执行，举例测试 isNaN,eval 的作用
  return ac
}

说(
  [1,2].map(x=>1.2*x),
  算链("1 + 2 * 3".split(' '))
)
```

我们知道 1+(2*3)=7 。计算机科学(CS) 的学习路还很远。

#### 以区间思考

提示：在有值域的概念后，你可以视枚举 i=0; i=1, ... 在脑中模拟执行代码，观察边界情况(如newA里for"i<N" 于 i==N 表现)。

>B不幸的是，尽管值域(区间)很有用，定义域已化为与数学函数无关的“变量类型系统”，毕竟它在数学里意义也只是严谨。计算机函数不一定只是混淆了映射 `y(于x)=1.2x` 或数值关系 `y=1.2x` 的算式，它只是在复用代码

>其实 y=1.2x 在yx均为列表时也能运算(行向量)。试试 `import numpy as np; 1.2*np.arange(0,10)` 和 `np.linspace(0,1 ,10)` 。至于 y(x) 叫“映射”关系完全是想给x限界而已。本就只有等式关系

长度固定和可增有何区别？若实现 `滤([1,3,5,8], x=>x%2==1)` 奇数过滤，长度不易提前算。所以 C 不适合算法。

>C,Java,C++,VB,Pascal..随便配数学算法是对计算机的侮辱。明明Excel公式和[Desmos](desmos.com/calculator),Sympy,Matlab都能做的事，用一些无关痛痒的语言来表达，是把语言当批量产品吗。

```js
滤=(a,p)=>{let b=[],x;for(x of a)if(p(x))b.push(x) ;return a} //a去看，若试命题(它)，b添它。

说(滤(newA(10,i=>1+i)/*1~9 共10数*/, x=>2<x&&x<8))
```

>任务：我要 `<5或>7` 的项。 newA(10,1+ 实在太鸡肋了，我要 `rn(2,5)=2~5` 长4项 (rn缩写range

>B探索：`newA(10, i=>Math.floor(i/3))` 和 `newA(10, i=>i%3)` 有何联系，你能用它实现二维数组吗。


### 对应表

$Y和$N 是真假，123是数 "abc"是文，也即 `['a','b','c'] [1]='b'` 的列表， `NO` 的涵义却未揭晓

JS 的最后一个数据结构是 `文=>值` 的 __配对表__(pair,associate,Map)，称文为键K 值为V，即KV表 。毫不夸张，它是行以外最常见的集合数据

```js
o={天王:"地虎", 小鸡:"蘑菇", n:"没长度哦"}
说(o.n[0]=='没', o["天王"]=="地虎", o["老鹰"]==NO)

for(let k in o)说(k,o[k])
o.x=o.x||1 //空(NO)则1
说(o.x)
```

和树(嵌套行)一样，你也可以把它理解为 `取到=(k=='1')? '一' :(k=='2')? '二' :NO` 即 `switch` 的数据化

__优美的程序既要算法高效“快”，也需推敲代码写法“易读”。__ [^](#何为编程)

我建议大家尽量以『言expression』而非『句statement』的方法定义式(而非流程式)编程，Java也兼容。

可以写个“分组函数”，这个KV表 `表<K,V>` 也能是 `表<K,行<V>>`

```js
分组=(a,f)=>{let o={},x,k
  for(x of a){k=f(x);(o[k]=o[k]||[]/*若无则建*/).push(x) }//1k 1push
  return o//{1:["a"],2:["bc","cb"]}
}
//若无则建即： v=o[k];if(NO==v)o[k]=v=[]; return v

分组("a bc cb".split(" "), n)
```

>B学数据库的同学试着解读下Excel、SQL、{A:1,B:2} 间的差异，这个{} 的[]能转为 Excel 式n行m列格式吗？

### 完成

```js
//舞台交给你。刚才有写 map,过滤,拉链,newA 和 算链,分组
//自己测试下会不会“默写”

//修改a[i]
//若a[i]符合，b填它
//map, 但组合b[i]
//以f(编号) 创建N项行(0起始编号)

//变数ac初0；变文op初"+"；a去看，若它是数 ac“怎么”=它。 否则op=它。
//a去看，分组[f(它)]去添它

//有游戏FizzBuzz: 从1数到100，Fizz=3的整数倍 Buzz=5的
```

[直接动手](#算法开始)

>B你终于学会了 JavaScript (ES6 ver. 无浏览器DOM/BOM)，但这次的目的是算法。

>毕竟，如果一个人说话都还没学会，就教给他各种开场技巧和周旋方法，他肯定只能被动地接受所谓「进步阶梯」之书上死板生硬的讲法

>B然后照搬都迷迷糊糊。还把作者传递给他的头疼当成自己努力了，所以一定成功。 许多讲成功学的人，自己也很“失败”……

>[磨刀不误砍柴功](https://zen-of-python.info/#16)。 计算机的函数告诉我们一个道理：__如果你能尽早完整思考、分配好问题的代码，就不需要修很长时间bug__ 。如果你能解决A问题，A->许多B 也就砰地消失了。B不仅可能是个大麻烦，更可能是半辈子、5,600人的麻烦。你再多想2h，它就这么凭空没了。 软件界的发展是有道理的。它慢慢「懂」重复

>B如果再给作者一次选择的机会，还是要把精力花在写文好好思考上；而不是硬肝代码，最后却连怎么解的题都说不清。

以下是 JS 的语法，仅开阔眼界。 | 换行=分支、 ,;*=重复

```
文件 句;

函 (名,)=>言|段
  名=>言|段
句 言|段名| if(言)段 (else 段)? | while(言)段
  for(段名;言;言)段 | for(名 of 言)段
段 句;|{句;}
段名 let 名=言,

言 opChain(言名, "= || && +,- *,/,%") |函
言名 言(.名 | [言] | (言,) )*
单言 常言|名|'('言')'| [+-!]言 |言++
常言 true|false|null| "(.*?)"
  [+-]?[0-9]*(.[0-9]+)?(e[+-][0-9]+) -- -1.2e+2
```

你可以检查以上JS代码示例，是不是每一段都是以此为模板

### 弱类型和OOP

>B元编程、面向对象OOP相关。选学

弱类型的好处是一切皆数据，`JSON.stringify({a:1,b:[2,3]})` 能完成 Java 里大50行 内存对象“序列化”，因为 `({a:1}).a` 里 `.a=["a"]` ，一切都可访问，不必一开始就要完善的数据访改框架。

JS 里 `class A{f(){} f1(){}}` 是一个“构造函数”，o=被 `new A`， `o.constructor=A`, `o.__proto__=A.prototype` ，类型就是不同{} 上共通的键[^](#二叉树)(如 `[].push, [].pop`,`o.f, o.f1` ..)。

原型链最终查到Object：`A.prototype.__proto__=Object.prototype` ，后者proto==NO 。

其实 new 会让最顶(Obj)亲(super)类的 `prototype.constructor` 先 `.apply(onThis, args)` 初始化一个{}，如 `人 extends 动物`， `动物` 设叫声、`人` 设表情。

构造器里最好别访问可再定(覆写override)成员，它们可能依赖子类构造器设的值，而子类构造器在亲类后才调用。

#### OOP

继承,多态特性：原型链实现了继承和成员再定，而JS里一个变量本就可以是 string,number 等多类型(`instanceof java.lang.Object`)、

其上成员同名多义且“可再定化 接口化”如 `"".at, [].at`。缺点是没编译期解决的同名重载(overload)

易语言为何失败，因为它的作者连这点道理都不懂，只知道名词替换。其语法一开始就是错的，再怎么堆砌API(库函数)也只能制造缝合怪，无法体现中文之美

Py 和 Ruby 里对 OOP 思想的使用类似 JS， Py 里 `[].append`,`{}.get` 是 `[].push.bind([])` 的结果，Rb 里 `def v=` 是 setter，而 getter/0参def 调用语法一样

正宗OOP 都知道 `class{static X=1;}` 里X代表 `class{samename object{val X=1}}` ，class 也有 1:1 的同名实例。 Rb 里 metaclass 就是干这个的，`Enumerator`,`Hash` 迭代器和HashMap 的“静态方法”都是同名实例，静态“@@字段”也可以继承

#### JavaEE

繁杂。其实重点不在语言而在开源社区，反射+CGen 也能实现JS的技巧，但一个爱讲大空废话的Java社区才不把精力费在刀刃上。

当你花2~3h 写完简单结构的 read/write 发布mvn 还自以完美，隔壁 Py `from struct import pack,unpack` 早把GUI都完成了，所以统计和ML是Py的天下，Java羮都分不到 只能做 CRUD boy 充作PHP的上升，然后靠热度勉强和能实现数据库和NT内核的C++混为一谈。

这不是因为数据分析比Java简单，而是有你严严谨谨写什么class 再new什么玩意的功夫，Py 3个图表都出来了，还能分享、还能跨语言；JavaEE 呢？Eclipse 为啥不如 IDEA 了呢。还 awt-swing javafx ，都21世纪了H5+CSS比你强太多，而用户点按交互，性能本就不敏感

Py 的严谨性介于 JS 和 Java ，它里面有限或增强的“反射”轻而易举，不像 Java 名词贼多。 强行面向对象终将言之无物，可惜。 无论面向对象或过程，烂代码终究是烂活儿。思想错了，怎么讲最多言过饰非，不易修正。

```py
kf="get"
getattr(dict,kf) ({1:2}, 1) # 看看 JVM 要怎么“反射”

class A:
  def __getattr__(o,k):return k
A().wtf=="wtf"
```

Java11 JShell

```java
import java.lang.reflect.*
//import java.util.*;//旧collection框架

Method met(Object o,String k, Class<?>...pt){
  Method f=null;//哇哦，好严肃啊，得把f切开赋值呢。catch绝对消不掉，哪怕我保证k值正确
  try{f=o.getClass().getMethod(k,pt);f.setAccessible(true);} catch(Exception e){}
  return f;
}
var d=Map.of(1,2)
met(d,"get", Object.class).invoke(d,1)

InvocationHandler f=(Object o,Method f, Object[] a)->{return f.getName();}
java.lang.reflect.Proxy.newProxyInstance(null, new Class[]{Closeable.class},f)
```

如你所见，Java __非常不利于定义子程序复用__，连给类型或常量起简写这样的小事都做不到(C都行)。

可以说，Java 就是一个主打降智的垃圾。它的OOP理论是从200年前的 Smalltalk 那学的，既不正统也极无聊

那么功能点呢， Proxy 本来是delegate“继承自实例” 的动态类型版， 按理说它也能从既有o 创建，像JS `new Proxy({}, {get:(o,k)=>k}).wtf`

可它不仅没加 也不支持生成子类覆盖 就为了不被滥用…… `javax.tools.ToolProvider.getSystemJavaCompiler()` 呢

哦，`tools.JavaCompiler` 是抽象，`Tool` 是抽象，就必须用 Provider.getSystemXXX，get来putset去真是闲的慌。 Singleton 都比这强。 `getMethod getMethods` 弄成 `(MemberList)type(d).method.get()` 不好组合吗？

碰到这种语言，什么反射框架，如果懒得写成2k行代码(我写过不下4次2k)就得在js里代码生成Java语法的代码…… 笑死

当有人告诉你 Java 很强，别听他的。 Java 和 C++ 都是废话贼多的垃圾，它“强”只是因为它能用500行实现10句话说完的功能(比如 `std::span` 区间)，而浪费许多时间学习那蹩脚、低表现力的表达法。话都说不利索还在“编程”

如果不是因为许多人只知道一两门编程语言，或其他JVM语言，这种语言根本出不到13。

IDEA 家的 [Kotlin](kotlinlang.org) 才是世界上最好的隐式强类型OOP(面向对象)语言

### 算法开始


1数行，求其中和=0的数对的个数。数互不相同

```py
from itertools import*
R=range; f=len([0 for(i,j)in product(R(n),R(n)) if a[i]+a[j]==0])


```

由于题中没要求数对是有序的，答案就是有序的情况的两倍(ab,ba) 即 `for i=R(n),j=R(i)` 和乘2

可以使用桶1记录遍历过的数

```
met = [False]*2*n1
for i in range(n):
  if met[n1-a[i]]:ac+=1
  met[n1+a[i]] = True
```

1数行，求相同元素个数

可利用排序让相同元素相邻，再直接扫描。


闰年： `y=>i%400==0 ||(i%100!=0&&i%4==0)` //4年一闰，百年一整, (i/100 %4==0)也闰

## 查找和排序、大O计算量

多看几遍上文，或许你进步了许多，也或许你本来很强。 但这些都只是算法前的热身小菜——不过要注意——__它们从层次上和真正的算法并没有区别__。如果有，就是讲师不会讲中文却很会“数学”。

算法都可以拆成小步骤（不然你也无法在JS里写它们了，我说过 `0?a:b` 或 `a+(b+c)` 的本质是二叉树，代码也是嵌套树结构），下面教的是最常见的排序算法们…… 等等，排序调用 `[3,1,2].sort()=123` 不OK了？确实不够

复习列表处理，查找行内项位置 `find("草草草码草",'码')==3`：

```js
find=(a,x, i=0)=>{for(;i<n(a);i++)if(a[i]==x)return i}
```

>任务：泛化if `find("abc1df",x=> x>0)==3`

如果a有N项， `a[i]==x` __最差执行N次，这叫O(N) 。__

那么先玩个猜数游戏吧。我选个1~100 的数，你猜它是几，我告诉你大了、小了，还是对了。

```js
猜数=(n=mix(1,100, Math.random()))=>{let 答
  while(答= +prompt("猜猜吧"))说(`太${答<n?'小':答>n?'大': '对'}了`)
}
mix=(a,b,t)=>a+t*(b-a)>>0//取整(Java里自动)
猜数() //只是猜对也不break(
```

有个诀窍：每次选 __折中数(如50,25,..)__ 而不是从1数到100，你绝对能在7次里猜出n，因为 O(log2 N=100) =6.6

很有意思的游戏。让计算机“自动玩”，它就是一个『算法』。 __算法是解决(较独特)问题的一种方法，既是某一种方法，就能衡量优劣__——比如耗时耗内存、答案精确度。 贪心法就是耗时短但不是最优解版本的算法

待会认识 O(NN) 的选择排序，而我这有个 O(N!) 的算法：

```js
fact=n=>newA(n,i=>1+i).reduce((a,b)=>a*b, 1) //阶乘 1*2*3..*n
非常耗时=N=>newA(fact(N), i=>i*2/*O(N!)次*/)
```

__O(N) 代表1次遍历，O(NN)即O(N^2)代表有2层 O(N)__。它的唯一意义就是，O这个函数线越不陡，算法就越擅长解决海量数据。当然单次时间(常数项)也是很重要的，但我们懒得算那么细！

而NP-hard或NP完全问题(NPC)，是在一种不存在的(不是现在已有的量子)计算机上才能解决的问题。比如旅行商最优路径排列

>任务：仔细阅读 [OIWiki-复杂度理论](https://oi-wiki.org/basic/complexity/#_4) 里的希腊字母，回味和高中数学系出名门的「严谨」公式（选填

### 二均分

再说二分(bisect)查找 `bsearch(a,x)`。 其中a是对何 `a[i]<a[i+1]` 的行，x 是一个数。 你可能好奇HashMap为何基于红黑树实现，红黑树就是自动sort的[] ，而其内每项以hash有序(f=hash,对何`f(a[i])<f(a[i+1])`)，就能加快 get/set(key)操作

```js
二分找=(ary,/*行内*/X)=>{let a=0,b=n(a)-1, iC/*中分ab*/,x
  while(a<b){iC=mix(a,b,0.5),x=ary[iC]; if(x==X)return iC; (x<X)?/*向右*/a=iC+1 :(X<x)? b=iC-1 : noOp}
  return -1//没找到
}
```

>思考：你刚才完成过find()从固定值到「命题函数」的泛化，那二分找() 能不能应用在非数值的[]上？

>B探索：“自动玩”的引号真可以去掉，将 prompt,说, ary[iC] 3处换掉，x< X即"太小了",取-1, 有0,+1 依此类推 `(a<b,sign(a-b)=-1)`，它可以告诉你算法执行的过程！(其实改 `说(x=ary[iC])` 也行..

我做过选冒泡插入排序、快速/合并两排序的可视化，其原理看动画吧。

+ 选排对每i0 选择 i0< i (右侧剩余)最小项，把它“设”到 `a[i0]`
+ 冒泡 `for(i1=n(a);i0<i1;i1--) 令序(a,i0-1, i0)` ，它不断右移的最大值。最大值要横过整行才能到位，所以它是最慢的“常见排序”
+ 插排n=1止N ,i=n~1递减 `x=a[n]`;直到 `a[i-1]<=x` 持续右移 `a[i]=a[i-1]` （为避免右项被覆盖，得从右往左>>移），于是 `a[i]=x`

对何<我N>(其中N：有序)
类型别名 行=集合.行<N>

事 行.选择排序=(0止最右)去看(::右最小)
其中，事 右最小(i：针)=(i右~最右)去看，i必小它。

事 行.冒泡排序=(1~最右)降着去看，
  (1~它)去看，i左必小i。

事 行.插入排序=(1~最右)去看，
  量 删牌=我[它]；变数i初它
  重复若非 我[i左]“已”不小删牌，
     我[i]=我[i左]；“也”若i令置「其左」是0，停下。
  我[i]=删牌
  “(1~最右) (它~1)降着 若i左小删牌停下；i放i左”

```js
so=a=>{let n=1,i,x;for(;n<a.length;n++){for(x=a[n],i=n;i&&a[i-1]>x;i--)a[i]=a[i-1]; a[i]=x;} } //v试对比
so=a=>{let n=1,i,x;for(;n<a.length;n++){for(x=a[n],i=n;i-->0&&a[i]>x;)a[i+1]=a[i]; a[i/*<=x, 最低0*/+1]=x} }
//if(a[i]<=x/*找到位置了*/)break; else a[i+1]=a[i];  a[i+1]=x//默认 a[n]
```

再来玩个游戏，写个“得原数”的函数，但要装逼一点

```js
itself=n=>{let N=n
  while(n-->0){} for(;n<N;n++){}
  return n
}
//1行版
itself=n=>n==0?0 : itself(n-1)+1
```

这个“原函数”把 1变成 (1-1)+1 ，它是递归(基线:n=0 ,否则似死循环)，确切的说是递推(伪递归,0开销的特例)。 __把问题拆分为多个问题 再合并 称分治__ 递下去、触底、归上来(分解-基线-回溯)，递归是分治的写法。

同样的“指导性”概念还有『贪心法』，“先按降序排好再怎样选” “每次都选最大来传递”…… 它会是局部最优解，但也只是整个问题的可行解，可能因小失大（就像拿起手机忘掉焦虑的你）。还有权重和后悔思路

基于分治法(D&C)的排序才真正的快。Python 使用的 TimSort 是预规划归并排序；某UNIX大佬的 Shellsort 则是分组插入排序

+ 快排把行从中线分成 <中 >=中 的两行，对这两行继续此流程，至仅1项
+ 合排也是从中线分，但它先等至1项行，再开始把左右两有序行，有序合并
+ 选择和块排不是稳定排序(stable_sort)，相等项的顺序可能有变

>思考：脑中模拟 `[2,1,3]` 插排和冒泡。快排和合并 内两法的异同

>任务：插入排序里 `a[0~n]` 是有序列，利用二分找-整体移位 而非线性比较-单移位

>B探索：在两边正反冒泡(正找最大 反找最小)能大大加快冒泡排序，要不试试吧？

类似的分割优化还有[seg树](https://oi-wiki.org/ds/seg/)、[ST表](https://oi-wiki.org/ds/sparse-table/) (区间 minmax(x,x)=x 就属于可优化问题)、[四分树](https://www.shadertoy.com/view/lljSDy)

```py
def shell_sort(array, length):
    h = 1
    while h < length / 3:
        h = int(3 * h + 1)
    while h >= 1:
        for i in range(h, length):
            j = i
            while j >= h and array[j] < array[j - h]:
                array[j], array[j - h] = array[j - h], array[j]
                j -= h
        h = int(h / 3)

```

计数排序， 因为稳定，它可以作为基数排序(先按右0位、1位(10)..整体排序) 的内层。

```py
N = 100010
n = w = 0
a = b = [0] * N

def cntSort():
  计 = [0] * N
  for i in rn1(n): 计[a[i]] += 1
  for i in rn1(w): 计[i] += 计[i - 1]
  for i in range(n, 0, -1):
    b[计[a[i]] - 1] = a[i]
    计[a[i]] -= 1


a = [0] * N
桶 = [[] for i in range(N)]
def bucketSort():
    桶_size = int(w / n + 1)
    for i in range(0, n):
        桶[i].clear()
    for i in range(1, n + 1):
        桶[int(a[i] / 桶_size)].append(a[i])
    p = 0
    for i in range(0, n):
        insertion_sort(桶[i])
        for j in range(0, len(桶[i])):
            a[p] = 桶[i][j]
            p += 1
```

桶排序也是种组合排序，适用于数据均匀，内层可选插排。

设置一个定量的数组当作空桶；
遍历序列，并将元素一个个放到对应的桶中；
对每个不是空的桶进行排序；
从不是空的桶里把元素再放回原来的序列中。


建立大顶堆，然后将堆顶的元素取出，作为最大值，与数组尾部的元素交换

之后将堆顶的元素取出，作为次大值，与数组倒数第二位元素交换

以此类推，在第 n-1 次操作后，整个数组就完成了排序。

堆排序有种结合选择排序的“锦标赛排序”变体，较复杂

```py
def sift_down(arr, start, end):
    # 计算父结点和子结点的下标
    parent = int(start)
    child = int(parent * 2 + 1)
    while child <= end: # 子结点下标在范围内才做比较
        # 先比较两个子结点大小，选择最大的
        if child + 1 <= end and arr[child] < arr[child + 1]:
            child += 1
        # 如果父结点比子结点大，代表调整完毕，直接跳出函数
        if arr[parent] >= arr[child]:
            return
        else: # 否则交换父子内容，子结点再和孙结点比较
            arr[parent], arr[child] = arr[child], arr[parent]
            parent = child
            child = int(parent * 2 + 1)

def heap_sort(arr, len):
  # 从最后一个节点的父节点开始 sift down 以完成堆化 (heapify)
    i = (len - 1 - 1) / 2
    while(i >= 0):
        sift_down(arr, i, len - 1)
        i -= 1
  # 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕
    i = len - 1
    while(i > 0):
        arr[0], arr[i] = arr[i], arr[0]
        sift_down(arr, 0, i - 1)
        i -= 1
```

## KV表算法：前缀树、摘要分桶

你终于可以实现之前用来给行内项分组的结构了…… 桶是以整数排列的[]

`HashMap<K,V>` 即散利表，表是一种K-V 映射，它就可以用来缓存 `x=>x+1` 等函数计算，且 `行[i]` 也可解读为 `Map<Int,V>`。它是可编辑的 `if(x=='k')return b; else (x=='k1')..` 或 `switch{case 'k':}` 函数。

记得{}怎么把 `"苹果 茄 香蕉 黄瓜 梨"` 分成 `{果:"苹果 香蕉 梨",蔬:"茄 黄瓜"}` 吗 [^](#对应表)

>任务：先学如何利用KV表，再思考 Hash 桶和此示例 有何相通点

>B任务：设计可反向索引的 `bid({a:"xx"}).flip.xx=="a"`

在图形学 hash 把均匀的 1,2,3,... 打乱成 (巨大数),9032,123189... 所以叫散列，但信息学里只有 `hash("abc")=巨大数` 的摘要性质(值相等H一定相等，所以H可以预分桶加速查找 )，叫散利什么的完全是某些人根本没动脑子翻译，踩他。

桶的数量是固定的， `i%N` 能把i均匀分部在 < N 限制内(该回看[^2](#以区间思考)节末了?)， 所以直接 `a[摘要k%N].push(kv)` 就能set(kv) 一项，

查表则要对 `a[桶号]` 的 `([k,v])` 项进行 `if(k==e[0])` 的线性搜索。 一般1桶只有一个 kv ，一个坏的摘要函数不均地分布(例如只考虑第0字符等..)，让桶分配不均，拖慢性能

>顺便：hash函数的不均分布甚至被黑客用来 DoS 慢化攻击

如果加入的元素足够多致使桶高不均，就重分配一堆桶， 然后用kv迭代把既有项复制过去。

总的来说，就是按 `hash(k)%当前桶数` 分组kv对，设=直接添；取=在组里找(其k是k)

C++ std:: `unordered_map` 是哈希表、`map` 是在查找篇所说基于二分找的表。

>思考：编程语言、数学和算法间谁的哪点更像谁。不必答得很数学严谨，因为计算机比数学更严苛真实。

## D,BFS 路径和可达搜索、Dij狄图最轻径

在图前先复习一遍嵌套树，正好我写过一个“思维导图”软件，帮我测试吧。

有了KV表才易表示图结构。`Graph<T>=Map<T,List<T>>`

```js
a=[],_6=n=>{if(n==6)throw 0; for(let x of [1,2]){a.push(x);_6(n+x); a.pop()} }
//_6(0)=6个1 .n==6是成立条件(如达到迷宫目标,也可基于路径顺序a.) ，n+x 是某点->旁点
```

BFS可达搜索只用个队列、已见集 就能从链接图里找出自某点可达的所有点。

DFS也用已见集，但基于栈，可以找到 p0-p 的路径 ，它可以解著名的八皇后棋盘

搜索到边界条件(如墙壁)，即不再向下搜索，转而搜索另一条链；直到目标(如苹果)就回溯路径或 求得最终点

要链接用DFS，栈和队可支持BFS重试点排列 队在位图会平行扩大 栈会直线在边界重试

Astar 依据点-始末2点距加速与优化， 因为只有末点距偶尔会走到坑里慢速，就需要歪一点的新点 优先

### 队列和栈

队列这东西，比如贪吃蛇里蛇身就是。每帧动画往蛇向添1格记录涂黑，再泡1格记录涂白，它的长度不变却会“移动”。

任务管理器的CPU图啦也是这么干的，隔.1s 右放1点 左全左移，那不就是左 shift() 了右 push() 了1点么 ，它们的长度固定所以有环形指针缓冲区优化。可BFS里就是不同的“等待检查”队列

栈这东西， `let a=1 (a=>{说(a)} )(2)` 里a就像一个栈。进入 `=>{}` 即 push一层{a:2}，退出 即 pop这层，回到 `a[n(a)-1]` {a:1} 的变量值

>当然，“系统调用栈”其实就是一个栈。可以把冲突变量保存到临时{} ，退时再还原
<br>JS的“var提前undefined”就是因为块有头部预保留。中间可能重赋值。

注意：针对同图BFS(p,arg) 其实是可缓存的，就像Dij法。 这更像DP(但后者略含糊)，__记忆化搜索__

简单来说：对同一张像素图-目标点， 其左的格始终指向右… BFS不是只能对状态的「上下左右」搜索，它只是穷举而已

此外已有最优解、发现不可行时要及时剪枝

>任务：给BFS单格选向加权。 假设点在右上，p0=左下， 优先朝上右前进 (被称为BestFS)


### 狄图最优回溯

交通有拥堵的时候、以物换物有「值得(低开销/低负重)」和「不值」的途径，最轻径就是重之和最小的途径。


## A星

听说过“启发式”算法吧，它对选项估价，来优化答案。 A* 可算Dij的扩展

dfs 能找到路径，但未必是最短的。它的效率和“尝试方向”上下左右的顺序相关，但这不一定是最优解。为何不定义「距离函数、开销函数」，以将开销最小化？

f=g+h ; gh是格与起点和终点的距离，还可取曼哈顿或对角距，以应对特殊需求(如仅允许4,8向)。 若h=0 则A星=Dij

IDA 是dfs化的A星，不需要判重或排序，但易重复计算。 每个深度D实际有个DFS 。这叫“__迭代加(递归)深__”，是在拿DFS实现BFS

然后有种非常繁的DLX集合覆盖可解数独什么的， minmax-ab剪枝 是棋盘AI常用算法

```js
Procedure IDA_STAR(p0)
Begin
  dep := H(p0) - 1;
  ok := False;
  Repeat
    inc(dep);
    p0.g = 0;
    Push(todo, p0);
    Repeat
      p := Pop(todo);
      If Solution(p) then
        ok = True
      Elseif dep >= p.g + H(p) then
        For each Child(p) do
          Push(todo, Child(p));
    until ok or empty(todo);
  until ok or ResourceLimtsReached;
end;

```

然后 BFS/DFS 也可从起止两端同时扩张(__双向~~奔赴~~搜索__)，若相遇即拼接路径

## 并查集、加合并权

为啥集合 `Set<V>` 算法最后讲？因为它真的太废了。 甚至有人觉得 `Set<V>=Map<V,无用值>` 。

多集合可以把许多项关联，比常见的 Set 有用多了，许多图算法(如共同祖先LCA-Tarjan,最小生成MST-Prim)都得靠它(但我不会教啥图算法，因为拓扑是数学几何延伸出的领域，它的代码质量不咋高、公式一大堆 )

加压缩


## 链接和连续

C 算法里有种结构叫链表，它被JS/Java 给掩藏了，但JS也能定义(尽管会更慢)；你就把链表和数组当“刷抖音”和“看某人的视频列表”吧，速度一目了然

```js
ll=(x,...xs)=>n(xs)==0?{x,xs:NO/*"空指针"*/} : {x,xs}
llEach=(e,f)=>{do{f(e.x); e=e.xs}while(e!=NO) } //e.x 不可能是NO ，所以必先做1遍f()

llEach(ll(1,2,3), 说)
```

`llEach=(e/*抖音播放队列*/ ,f/*你怎么看(记录,+=1,删除..)*/)=>{重复，f(e.首)；“换视频”e=e.余。 若e不是空 “温馨提示：您要列表循环吗(不!”  }`

实现不定长数组：利用 `malloc(N)` 可以分配独占内存区，`realloc(a,N)` 可以增长它 (即列表,“行”)。

链表 `LinkedList` 适合遍历所有元素的情况(比如抖音就会刷半天)，因为它的 `a[1]` 等位置无法被直接计算，需要“爬”1次 xs 链接才能get到“不随机(机遇)访问”。 一般我们用 `ArrayList`

因为链表需要的连续内存块(内存空间好比巨大“字节数组”)很小，容易分配， 它是时间换空间(低内存高CPU)的结构，而数组则“空间换时间”。

C编程者(如Linux内核之父)会细心编写这个模板并考虑是不是每次都完整遍历，而性能差点的语言(Java,JS,Py)里这些是透明的。C++,C# 等语言则很折中，提供了较直接的方法让你操作内存


## DP动态规划

动规是一个非常笼统的“a[i][j]缓存”思想，常用来看它像函数调用缓存，但需手动设计各子问题的依赖情况

f=n=>n<2?n: f(n-1)+f(n-2)
fib=f //0,1,2, 3,5, 7,...

最长共同子串 mcs(s,S) 。s横S竖

ab ab , ab b, b ab ... ，对于最后的b(最大 `i==j` 的情况)，这个做法全都重复计算了，这隐含了它不是种好做法。其实用填充网格的方法更简单

背包问题——贪婪的小偷如何在重量内获得最大价值组合； 贪心法只需按商品价降序，取直到拿不下，而背包问题也是基于子问题划分的。

## K加密和base系编码、大整数

[对应表](#对应表) 的谜底揭晓——确实可以，结构相同的{}和一种csv文本(观感Excel) 是完全等价的。

K加密是非常naive(初等) 的方法，AES,Blowfish 是更常见的加密法

K:把行里每数对应 Moses:把行里每序列对应

栅栏:N个一组取内第0,1..  棋盘:字母转散数字

## RSA非对称密钥

在遥远..的8年前，有种工具叫GPG 可以保证对任何B ，A<-B 的传信是安全的。A发布，B持有公钥。 只有A的私钥能解密公钥，此外还有A身份的验证(分布式身份验证JWT 就是基于此"DH体系")

正如那个年代人们会用 ED2k 和 BT 分享文件、扎堆点到点P2P加速下载，现在却都靠数据中心DC，P2P和虚拟货币成了诈骗的代名词… 参与比赛的你们是不会怀念那个时代的，你们只在乎前程罢。 Internet 的用户群在下沉，但也在丰富其产品

刚才说，加解密是一种 `key=>{/*encrypt*/cut:原=>密, /*decrypt*/cat:密=>文} ` 的等价关系，一切秘密在key (好比PIN 密数)，而SSH 证书这些地方私钥才是。公钥却可到处乱发，比如GNU公钥服务器啊、Keybase.io 啊，让B给你这个A安全送信，美国国安都无法破译，在自由国很流行

那么棱镜门是怎么回事呢？它是复制公司数据库(包括Apple,真不知道果粉是怎么信库克的)的内部数据，不是加密数据。好比强盗式黑客行为(不拖库就制裁~)。 RSA不如DES 快，却是很知名的非对称密钥算法。RSA解密是某年真题

在数学上有种计算很奇妙：你可以轻易分配合规(256位,512位.. 64一个long 你算算)的 `[a,b]` ，从a能还原b 的结果，但从b求得a 难于登天；于是b公开、a私有。 至于为啥有一大堆ABCDEF ，完全是这 256-bit 数以 base64 编码了而已

精髓在如何分配[a,b]…

## 牛顿方根

杂项算法：开平方、最小公倍、最大公约、公平分地 、Hanoni塔、99瓶啤酒、鸡兔同笼、百钱百鸡

数学、几何和物理的一些图形公式挺有意思，比如 Mandel/Julia 集

平分矩形土地为正方形：按宽(较小值)将土地分成两份，再对两份重复如此，直到分得最小正方即是

Bloom/HypLogLog 过滤器，SimHash 查重，B树 kD树(kNN 最近邻-逻辑回归 机器学习) 这些也都是很有用的算法，我还写过一篇 FT(傅里叶变换) 的文章
