这是一期关于游戏开发必会内容的科普，你玩过这个(asteroid)吗？

这个(乒乓)呢？本期末就会教大家自己做一个乒乓游戏

请别害怕我的提问，这期很多问并不是乒乓游戏必懂的内容，但引发对同类问题的思考有助于更游刃有余掌握一类算法。

如果给你两点 p0 和 p1 ，怎么在宽高w,h的像素图上画线?

求黑色的点集，或者说哪些点是在直线内的

拿 xy 距离 lx,ly 算 ly/lx 求 dy 再迭代 x , 理:这隐含 dx=1, 是利用 y=kx, 也是最大公约数 gcd(lx,ly) (低精度)

那么，假设p0是只乌龟，角度r ，它爬行距离l 后在哪点

plusRL(r,l) (l cos r,l sin r)//sin 的肯定是r啊
rad(d) d*PI/180

好了，那咱可以来绘制这些有趣的图形

旋行成花、N角形 走l&转360/N

指针太阳系: rnR=0~360, l固定 多个步进vr的环路径

Koch star, 赵爽弦图

内部正方形的长度是沟谷定理啊，角度是 cos d, 或 -sin lC
这样的坏处呢首先是不稳定, sin lC 不总是得朝右上转这个锐角的弧度; 然后咱的方法其实对正N边形都有效，而且本来就不用旋转

果冻状的树: 每点 dep<n_dep时 分叉n 个<g>子点 line, 长l,角d 往复 也改变子p0点; 嗯再加个变色

首先咱有个初始点，就是某线的p1, 从它上分支出n个线，覆盖rn角度区间，这些线又变成初始点，直到圆形它没有新线为止
你可能觉得，啥咱不用p0点呢？[用p0是这个效果] ，我们是要从父层计算子项末点，而不是零点
那么如果你不给新枝条设置当前 p0, 就会[变成这样]，如果设置了你就会发现整个树好像只有源点在动，毕竟枝条只知道自己零点和全局角度 不知道父树相对角度，有个简单方法让它知道(*dep)

也就是 a(rnR,L) n*(p0+(r,L) a)

如果我们有个 p0, 然后有它的方向, 怎么求它方向与 p1 的相对角度，从而能让它朝向p1？

听起来很奇怪，点有方向、角度是两个数？或许你一直以为一个有方向的点应该由(x,y,r)三元组表示，但其实很多时候是四项！

向量是什么？它是一种源点无关的物理计算方式，你可以视其(0,0)到(x,y)的一条线，有角度也有长度

单个向量可以是点，也可能是速度或旋转方向，你可以把它看成一个能做加减和倍乘倍除的箭头；在作为点时它和普通(x,y)值没有任何区别，只是方便叠加速度、角度，从而得到另一点而已

咱是把零点给抽象成任意p0点，刚才 plusRL 的式子就可以变一下，你看这 + 是xy都有的，是不是说它是+了一个p0?

你可能觉得只用 CSS rotate(90deg) 或 SVG 就行了干嘛要靠向量计算？
rotate 并不能让你知道一个线段、一个正方形某端点的新位置，如果你要在那个地方再放啥咋办？
CSS 也不能给对象提供加速度(velocity)，它能做的极点就是固定路径固定时长快慢曲线，但定时曲线不是游戏的全部

class Vec2{
p,pp,m,mm //整数加减乘除,仅乘常用
dup,neg(), pxy(p1)//复制此容器,取负,相加

rotate(r)//旋转
get set r//向量角度
get set l//向量长度

norm()//等比缩小数值
limitIn(rn)//最大值裁边
cycleIn(rn)//最大值回滚
static dot(p1,p2)//点乘求和
static rrel(p0,p1)//p0相对角
}

有个程序我比较好奇，就是我能照鼠标位置画个直线，但如果我想它长于鼠标咋办？好像要先求鼠标到顶的夹角再用 plusRL(r, len(源点,鼠标点)+l) 吧，但用向量三行就能写完(鼠标=零点是左上角的向量)

p左上=Vec2.Z().p(1) //0长旋转无效
p左上.rotate(Vec2.rrel(p左上,p鼠标) ).l=p鼠标.l+10;
svgLn.p(1, p左上)

其实是一行 p鼠标.l+=10; svgLn.p(1,p鼠标) 啊，如果是右上角会用刚才的计算

如果不要右上角，要任意A点到鼠标的线段咋整？ 把A视作(0,0)点，这时你就发现，它左边的东西得减去。所以长度先 p-A 就行

假如我是在做游戏，玩家用靠键盘选中怪物 我要瞄准它，把它的位置当作鼠标位置就行；Vec 只是计算方式也有3D 版本，并且如果你要开发游戏，处理任何物理计算 哪怕只是玩家行进和跳跃，相关的资料不会少看的~

小红和小蓝,小蓝是丧尸,隔一秒瞄准一次,并且创建一个圆形子弹直线运动
如果红蓝间距<l射 且角度 <r射, 小蓝就被杀死了

在 l红蓝/v射 帧后, 提示小蓝已被残忍杀害, 允悲(秒/60帧,你说多久)

附:走l&转N-i 螺纹、箭头、重复走/转递减 螺纹成花

其实对于复杂的几何图形，最好是要算出顶点集，哪怕想不到你也可以先试试手画咋弄简单，用角度长度去画

考虑下刚刚N边形绘制与赵爽弦图，其实弦图的一次迭代只需图形的顶点，
但绘制时是知道点的角度，才知道内切缩小版(+lC)的顶点在哪，如果你想直接连线，内图形角度又不知道了，没法继续
如果你想继续用龟爬lC的四点，会遇到咋让它面向并爬到其一点(求点-点 角)的尴尬；但是现在咱有了既有位置也有角度的向量，在连线时可以顺带设置相对角度，从而能从 p+lC 直接继续迭代啦

具体步骤，看右下角至其左, 或者说 (-左 + 右下), 是不是负数? 向左的向量; 给它设长 lC 再加回右下，就是新点了

最开始咱就取个点集，每次迭代按顺序,回到首项连起来 项至后项 的角度取长lC, 就是新点集

刚刚咱谈了优雅的物理/数学向量，不是民科版C++的那个vector ，是各种小型游戏精灵绘制位置大小计算的必要建模

这里有个球，每动画帧它都会移动 p.pxy(vel.pp(帧时差dT)) 的距离, p 就是个点 vel 同时是速度和方向

现在给你 doc.elementFromPoint, 每0.1秒判断一下球的方向下是啥元素并施加对应力 (没错,可能穿模)
- 左右边界,算反射角, 就是 rrel-90度
- 球拍,按其中心距离设置反射角(<正负90-N 度) 和加分
- 上下边界，GG

其实上下左右边界是可以用区间判断的, 不过要算球拍是挺麻烦 还不如用通用方法 这样添加道具啊也方便些

然后你要注意一点：球拍是有左右边界的，倒不如说它的0点是有边界的 l拍/2<p<w-l拍/2，也即 -中(0,拍)<p<中(w,拍) ，  其实游戏本来就是只有绘制、媒体声效这些零碎的东西，那些物体，其实本是些有参数的，看不见的点罢了，就是有了各种计算和限制，每帧去重绘画才会变得如此有趣

具体内容下一期,别忘了跟着我呦~
跟动苏，别迷路!

祝大家身体健康、升职加薪、学业有成，别忘了把腿盘桌上压一压
你学会了吗？

彩蛋

这一期要给大家一个足够彩的彩蛋

首先在中央有个 p0, 它有角度r和速度l ，不过它是定点飞不动啊，但它的复制 p1 就会向到屏幕边界，直到消失；p1 是堆彩红糖豆
咱又有动画 anim(5000, [p0,{r: 即?N 2pi: rad()*N} ], copyPot,fastIn) ，其 fastIn 是一个起速极快后面慢的速率曲线, copyPot 复制 p0 并添加对应颜色；也可改下 anim.fps, 降低每秒发射数量即增大间隔
为让动画不单调，时长在 2.5~5s 浮动，且用 Promise.repeat(()=>转(1).then(delay(2000)).then(转(randQ()? 1 : -1)) ) 隔2秒考虑是再转还是反着来遍，就变成了这个

细节:p1飞出屏幕，也即(代码少)与p0距离>宽高最大项时，立刻移除；点的p1,色彩可以用两个数组的同位项存储，只有p1列表内点参加时差移位






理:d_xy 和 k_xy: 人造绘制滚动缩放/CSS overflow

如果我们有个 p0, 然后有它的方向, 怎么求它方向与 p1 的相对角度？ (然后这里角度就是 p1-p0, 各自xy相减)

听起来很奇怪，点有方向、角度是两个数？其实这个方向和点本身是分开算的，它像物理上的力一样，是从相对的基(0,0)到点(x,y)，有角度有长度。

接下来的内容我不保证准确。我是完全不懂数学，公式都是抄的，大家可以自己画图推啊。

既然咱是把零点给抽象成任意p0点，刚才 plusRL 的式子就可以变一下，你看这 + 是xy都有的，是不是说它是p0?

刚才谈了点长->点，很有趣，现在是点点角

第三次到数学系找到了答案，不妨试一下就知道这个相对角度对不对

基于我抄来的优化角度增量公式

有个程序我比较好奇，就是我能照鼠标位置画个直线，但如果我想它长于鼠标咋办？

鼠标XY可视作相对(0,0) 的向量，所以直接创建向量然后 dup.l+ 一下就算出 p2 了，它简化计算的能力不错吧。

但是我想要始于 a 点到鼠标的射线，这又咋整？ 把a视作(0,0)点，这时你就发现，它左边的东西得减去。所以 p-a 就行,取长度和原来一样

假设我是在做游戏，玩家用只键盘选中怪物 我要瞄准它怎么办？把它的位置就当作鼠标位置给这个程序！



初始方向0, 那咱试试让一个长l直线朝向鼠标指针，点点长

然后它面向 pApple 时提示下

点的一种编码,自然数与链表

以角度去计算一切很直观，但利用距离差 pd, 给出 p0 你除了能知道角度更能直接算出 p1, 是说长度也有了

初中数学「向量相等是角度和距离相等，不意味点相等」是这个意思,对它p0可以是任何点

当我们谈「点」，其实说的是点最符合人类直觉的形式
当我们需要点，只是需要它上面的角度计算、绘制输出方法，而不是强制点一定要有 xy

如果我们能求形状的交集,即碰撞检测，也能做按键控制绑定之类、音效播放的东西，实际上就是设计出游戏了

Canvas: g.moveTo(x,y)&g.lineTo(x1,y1); g.rotate(r)&g.lineTo(0,l)
距离都是 px 像素单位

参考:asteroids,lines,Worm curve
向量点乘是积之和,可求平行状态、normalize是与距离之商,可缩数值、叉乘是(AB排除当前位积的相减, )垂直于AB, 可求A-B的各轴扭距,必须有三项才可计算

---花絮

向量就是可能是点也可能是方向,甚至速度的(x,y)二元组:半对!，它是一种便捷计算方式，就像刚才的 plusLR( 里 现在 r,l 都可调差了

物理/数学向量，不是民科版C++的那个vector ，是各种小型游戏必要的精灵绘制位置大小计算

给你p0,p1 ,它们之间长l的线末点在哪

给p0,p1 求其 r? xy差&arctan ; plusRL(p0, relR(p0,p1), dist(p0,p1))=p1

刚才我说的向量本质上和(x,y)一样啊？就是操作不一样。向量是点和距离差(角度)的结合:错!；刚才你直接看定义不易理解其实是因为那个操作方式杂和,不太严谨

回到最初 p0+r 与 p1 相对角度的问题，它的结果仍是二元组

向量的世界里只有距离，没有 0~60 度的角度

不过这个方法却不能去枚举角度:错!，只能计算和差；要枚举相当于生成 dir 向量, 和点一乘, 精度不太好

addDrag=e=>{
  onMov(e, (x,y)=>_qMv?movXY(e,x,y) :0, isDown=>{_qMv=isDown})
},
onMov=(e,f,f_doup)=>{
  _mv.set(e,f);
  e.onpointerdown=ev=>f_doup(true, ev);e.onpointerup=ev=>f_doup(false, ev);
},_mv=new Map//免内存泄漏
_qMv=0
doc.onpointermove=ev=>{let f; if((ev.target!=doc||_qMv)&& (f=_mv.get(ev.target))) f(ev.clientX,ev.clientY,ev);}
