1
00:00:00,640 --> 00:00:07,000
用这种方法自底向上的学习语法结构无异于管中窥豹、盲人摸象，如果你想真正自由地重构程序，

2
00:00:07,180 --> 00:00:11,170
没对基础定义、程控、表达式 语言结构有个概念是不可能的，

3
00:00:11,410 --> 00:00:17,140
从关键字、不能咋给符号命名入手一门语言，一些人还真是有编译原理的心没编译原理的脑

4
00:00:17,380 --> 00:00:18,670
啊，咋整这么麻烦，

5
00:00:18,910 --> 00:00:20,799
讲半天一个完整逻辑没写出来，

6
00:00:21,040 --> 00:00:28,330
让你去菜市场买菜 跟大妈争议起微积分的微有几种写法，还觉得啊卖菜不懂微积分行不懂微机(微积)二字怎么写咋行，

7
00:00:28,570 --> 00:00:29,575
给爷整不会了都

8
00:00:30,400 --> 00:00:32,860
啊我还看见有人把三位数和三个数混淆的，

9
00:00:33,040 --> 00:00:33,850
也是个人才；

10
00:00:34,060 --> 00:00:36,370
那为什么三项最大值可以用这种淘汰法，

11
00:00:36,610 --> 00:00:38,710
因为 (>) 比较运算有传递性，

12
00:00:38,890 --> 00:00:40,321
若 a<b 且 b<c

13
00:00:40,600 --> 00:00:41,650
则 a<c ；

14
00:00:41,830 --> 00:00:42,760
大于号亦然

15
00:00:42,970 --> 00:00:48,160
编程的世界没有那么多对象，只有两种东西，「动词」和「名词」，也就是数据和程序

16
00:00:48,370 --> 00:00:50,260
那值是什么，值是名词啊，

17
00:00:50,440 --> 00:00:55,810
123 都可以叫名词，有了函数和+-*/计算，它们的参数和结果才叫「值」嘛 ，

18
00:00:56,020 --> 00:00:57,730
如果函数和计算都叫「动词」，

19
00:00:57,970 --> 00:01:05,950
那我们定义 1+1=2 规则; 然后在 加1(n)=1+n 里有两个名词，一个是可替换的一个是1，那是不是也说得通啊；

20
00:01:06,190 --> 00:01:07,061
当然这个区别

21
00:01:07,300 --> 00:01:07,990
其实不宜废除，

22
00:01:08,170 --> 00:01:14,290
我只是带大家看破这堆无聊的语法，变量是个东西嘛？变量就是可变的量而已，但是C里面任何变量

23
00:01:14,530 --> 00:01:15,340
都能 &取指针 ，

24
00:01:15,550 --> 00:01:17,380
它还真是个东西了 独立了，

25
00:01:17,560 --> 00:01:18,880
所以我说容易写乱；

26
00:01:19,060 --> 00:01:23,560
你某个计算都没想好 还要区分 int* 和 int , 是不是有点太烧脑；

27
00:01:23,838 --> 00:01:30,760
它还不止是个盒子呢，还能加减拿到相邻盒呢，你知道啥时有用的必要吗？知道它和另外啥变量相关吗？

28
00:01:31,000 --> 00:01:32,260
反正我是懒得区别

29
00:01:33,220 --> 00:01:34,450
再说可变性：

30
00:01:34,720 --> 00:01:39,340
变量就是一段程序内能重赋值的量，不变量就是一段程序内不能重赋值的量、

31
00:01:39,520 --> 00:01:46,780
常量和字面量是整个程序执行期都仅有一个取值的量；其实只有没啥用的常量是整个程序里取值不改变的，

32
00:01:46,960 --> 00:01:50,380
变与不变都是相对在执行的子程序、{} 而言的，

33
00:01:50,560 --> 00:01:51,970
它就是一种严谨的限制，

34
00:01:52,210 --> 00:01:55,660
毕竟程序生命的意义是处理随时可能变化的东西

35
00:01:55,960 --> 00:01:59,740
那面向对象是什么，就是给动词一个能不写的主语this嘛；

36
00:01:59,920 --> 00:02:05,050
世界上那么多人，每个人有头脑有心肝，那我可不可以这个人没头、那个人没胃，

37
00:02:05,230 --> 00:02:07,300
但还要我支持计算它们的健康指标？

38
00:02:07,570 --> 00:02:11,019
子类继承自一个类，它的动名词只能更多不能有缺少，

39
00:02:11,200 --> 00:02:13,119
词集上是超集，类型安全；

40
00:02:13,329 --> 00:02:15,640
相关的东西共享一个动词(方法)集，没毛病；

41
00:02:15,880 --> 00:02:20,920
那既然说主语不用显写，主语的类型是不是也可以是任何兼容它的类型，它的子类？

42
00:02:21,190 --> 00:02:22,149
于是有了覆写Override，

43
00:02:22,359 --> 00:02:25,179
同样的动词基于变量的当前类型，行为不同；

44
00:02:25,420 --> 00:02:27,100
比如 点击监听.执行 (A.f 即 A上的动词f) ，

45
00:02:27,309 --> 00:02:31,989
网页里是不是有很多点击监听的实例，

46
00:02:32,170 --> 00:02:33,910
它们都仅有 执行 一个动词，

47
00:02:34,089 --> 00:02:38,649
但通过创建子类，我们可以让被调方API接受它后，有不同的行为

48
00:02:38,890 --> 00:02:42,549
刚刚讲的前两个是封装、继承，后两个是抽象、多态；

49
00:02:42,760 --> 00:02:45,850
有 构造器与名词+动词的封装才有继承，

50
00:02:46,089 --> 00:02:48,760
有子类兼容超类、超类名词能被赋上

51
00:02:48,939 --> 00:02:52,390
任意子类实例的值 的这种抽象，才有同名不同义的多态

52
00:02:52,750 --> 00:02:58,929
要是没 `o.fn(x1,x2)` 这种中缀语法有没有 JQ 这样的链式调用？有，

53
00:02:59,109 --> 00:03:02,709
但要写成 `f2(f1(a1),b1)` 这种逆序嵌套的形式，

54
00:03:02,980 --> 00:03:04,480
那可真是一点都看不懂了

55
00:03:04,720 --> 00:03:05,829
刚刚谈的「动名词」，

56
00:03:06,010 --> 00:03:08,290
真正的意义不是教大家理解面向对象，

57
00:03:08,500 --> 00:03:12,250
老实说我挺看不上现在有些人滥用面向对象进行过度设计的，

58
00:03:12,429 --> 00:03:14,049
冗长的代码一套又一套；

59
00:03:14,230 --> 00:03:15,489
刚刚的『点击监听』类，

60
00:03:15,850 --> 00:03:20,529
其实就是把几个值(点击目标,时间..)变成一个值(Void) 的操作，不就是一个函数吗？专门起个名字，

61
00:03:20,769 --> 00:03:23,350
大家都不得不用 class 去定义一个能分段执行、

62
00:03:23,799 --> 00:03:28,269
与人共享变量函数，把它的参数写在构造器里、用匿名子类(现已有Lambda)，

63
00:03:28,540 --> 00:03:30,519
实际造成了很大冗余语言结构

64
00:03:30,820 --> 00:03:33,970
语言结构越严谨，思想和过程的实质就越匮乏；

65
00:03:34,209 --> 00:03:40,600
正如一个人越是总爱侃侃而谈，背后的积淀就越少；如果你老想着服从这、规范那，这些表面功夫，

66
00:03:40,779 --> 00:03:43,480
是没法真正感受程序运行时各名词的变化的，

67
00:03:43,690 --> 00:03:45,790
很不巧，无论是算法还是应用，

68
00:03:46,000 --> 00:03:50,350
它们的实质都不是某语言的代码，而是我们能一分为二逐步解决的问题，

69
00:03:50,529 --> 00:03:52,929
是我们想要代码带来的结果和副作用，

70
00:03:53,170 --> 00:03:58,809
比如删掉用户输入里的脏字、或者开启一个窗口画布不断响应用户输入与交互

71
00:03:59,922 --> 00:04:03,940
而程序的实质，不在任何具体的值、不在任何单个的变量，

72
00:04:04,329 --> 00:04:07,480
正如 1+2=3 ，两个数字就只有个结果而已，

73
00:04:07,660 --> 00:04:11,230
(a+b==c)，是加号这动词，结合了两个名词，得到c这个加法结果，

74
00:04:11,410 --> 00:04:17,079
才有 c-a=b, c-b=a 等一大堆衍生操作和性质；

75
00:04:17,320 --> 00:04:23,440
单一的名词、单一的值意义不大，是因为一个动词把它们组合起来，它们才能赋予彼此意义；

76
00:04:23,680 --> 00:04:25,960
多利用函数抽象几个变量间的逻辑，

77
00:04:26,169 --> 00:04:28,400
你的程序就会变得优雅易读又简洁

78
00:04:28,750 --> 00:04:31,700
算式的结果是没有名字的，也不该有名字；

79
00:04:31,870 --> 00:04:37,870
直接插入下一步计算就得了，像不像软件背后的程序员；隐姓埋名，却做了真正了不起的东西

80
00:04:38,140 --> 00:04:41,260
那些赚大钱的游戏背后有无数程序员的辛苦付出，

81
00:04:41,440 --> 00:04:44,800
从界面、物理、电子机器到框架设计的各种部分，

82
00:04:45,010 --> 00:04:48,099
哪怕是抽象美工也没有一刻是离得开计算机软件，

83
00:04:48,340 --> 00:04:49,479
他们却不求回报，

84
00:04:49,659 --> 00:04:51,640
只有软件的名字却被所有人记住，

85
00:04:51,909 --> 00:04:55,360
人们只想知道那些赚大钱的建模技能和少年天才等噱头；

86
00:04:55,599 --> 00:04:57,849
没有任何理由，只因为想而编程，

87
00:04:58,030 --> 00:04:59,020
这就叫工程师，

88
00:04:59,229 --> 00:05:00,640
这就是科学人的精神

89
00:05:00,940 --> 00:05:02,950
我们再来谈谈『对象』的概念

90
00:05:03,159 --> 00:05:04,270
把(这堆箱子) 数完

91
00:05:04,510 --> 00:05:06,340
把(这堆箱子)今天内 数完

92
00:05:06,610 --> 00:05:09,130
「计数」是不是一个对每个箱子都有的动作

93
00:05:09,430 --> 00:05:13,840
但是一个是立刻，一个是它有一个时间范围，可以暂缓插入其它动作，

94
00:05:14,050 --> 00:05:15,940
它的范围我们称为生命周期

95
00:05:16,719 --> 00:05:18,550
前者是 int i=0;

96
00:05:18,912 --> 00:05:20,919
for(箱子 项 : 箱子堆)

97
00:05:21,159 --> 00:05:22,060
i+=1;

98
00:05:22,270 --> 00:05:23,830
后者是 class 计数器{

99
00:05:24,039 --> 00:05:24,252
int

100
00:05:24,429 --> 00:05:26,887
i=0; void 增(){i+=1;}

101
00:05:27,159 --> 00:05:31,060
} var 计=new 计数器(); 箱子堆.forEach(计::增);

102
00:05:31,390 --> 00:05:34,240
这个 forEach 有没有定义它数的每项耗了多少秒？

103
00:05:34,479 --> 00:05:35,020
没有吧，

104
00:05:35,289 --> 00:05:40,300
所以对象引入了扩展性。我可不可以边数边发声，或者同时数几堆箱子？

105
00:05:40,719 --> 00:05:42,550
单个 for 循环的行为是确定的，

106
00:05:42,789 --> 00:05:48,370
但当我们把数箱子的动作，拆成「从0数」和「对每项操作」两个部分，就有了很多新的可能；

107
00:05:48,570 --> 00:05:50,469
我可以边遍历边 println ，

108
00:05:50,650 --> 00:05:52,810
而这个修改对『计数器』是兼容的

109
00:05:54,130 --> 00:05:57,520
函数提升一级变成类，它的参数变成构造器参数、

110
00:05:57,700 --> 00:05:59,530
局部变量变成字段和属性，

111
00:05:59,740 --> 00:06:04,300
它的执行被分成几段，对它的调用变成实例创建后，其上方法的调用；

112
00:06:04,510 --> 00:06:06,849
面向对象就是把一个「立刻数完」的即时动词，

113
00:06:07,060 --> 00:06:10,180
变成一个可以改变参数、插入其它操作，例如

114
00:06:10,347 --> 00:06:12,880
Iterator.next() 后对单项处理，的开放性动词

115
00:06:13,150 --> 00:06:14,680
如果我们这样理解面向对象，

116
00:06:14,979 --> 00:06:17,590
是不是能更好的在建立函数和 class 间取舍？

117
00:06:17,800 --> 00:06:19,750
刚才的把字句，主语是什么，

118
00:06:20,027 --> 00:06:21,310
可不可以认为是 ForEacher ？

119
00:06:21,520 --> 00:06:22,479
但刚刚的代码是

120
00:06:22,690 --> 00:06:23,440
箱子堆.forEach(

121
00:06:23,800 --> 00:06:24,039
计::

122
00:06:24,219 --> 00:06:24,490
去增1)

123
00:06:24,760 --> 00:06:25,810
，主语是一堆东西，

124
00:06:26,080 --> 00:06:28,599
大家切忌过多 XXer XXor

125
00:06:28,840 --> 00:06:31,808
各种干啥器 主语的面向对象，那叫过度设计

126
00:06:32,080 --> 00:06:33,669
「面向对象」编程是编程，

127
00:06:33,940 --> 00:06:35,770
不是粗制滥造不必要的对象。

128
00:06:36,010 --> 00:06:39,130
能不把单一动作变成对象，就尽量别这么做，切记。

129
00:06:39,430 --> 00:06:44,330
编程没有正确与否，只有简洁协调与否，因为它只是我们达到目的的手段。

130
00:06:44,650 --> 00:06:49,360
死死盯着你的最终目的，不要沉溺于代码，为解决问题制造更多问题

131
00:06:49,570 --> 00:06:52,840
现实生活中的持续性动词是不是比即刻动词多？

132
00:06:53,080 --> 00:06:59,409
一条跑道两个人比赛，是不是我先跑你再跑，看谁耗时短，直到有人赢了两次，啊欢呼；

133
00:06:59,680 --> 00:07:02,110
这个比赛者是不是对象，跑是不是动词？

134
00:07:02,349 --> 00:07:06,400
不过比赛过程中「跑」会执行很多次，「欢呼」后它的生命周期才结束；

135
00:07:06,580 --> 00:07:09,520
所以面向对象比单一过程式更适合写软件应用；

136
00:07:09,760 --> 00:07:12,940
程序员可以只把对象提供给框架，来修改它的行为，

137
00:07:13,150 --> 00:07:14,919
而不必考虑整个软件架构；

138
00:07:15,219 --> 00:07:17,110
比如事件-重绘制的主循环

