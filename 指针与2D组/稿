你能知道! 当思想与现实碰撞，会产生怎样的“怪物”？

初学C语言的你肯定经常看到 *& 两个符号，不论程序体还是函数签名、结构体数组里都有 mo?

int* 是一个指针类型，它的+操作要用 *x+1 的这种 (*解引用)形式，那么移植 Java 里的 class Person{String name; int age;}

new Person("dse",19) 是指针吗？是、 p.age 是指针吗？它是一个 int 但也可以是, 只要变 &p.age

那 &p.name 是指针吗？这里有个问题，C stdlib 是没有字符串定义的，甚至连动态增长 buffer 的定义都没有，很多人用 char* 来实现字符串，这样的话它就是个双重指针 char** (和 char* argv[] 一样的欸)

mo?? 准确来说，一切可被计算机表示出的东西，也就是计算机能存储的一切东西， 0, 2.5, "" 这些全部都能是指针

但首先咱来看看二维数组，它是 a[i][j] (其中 i<n,j<m) 形式访问的一片存储空间，a内有许多i 行，a[i] 内有许多单元格，注意不是列，行列都是其内的一个范围，行0是a[0]里的所有j、列0是a[i][j=0]里枚举所有i

这个模型本身没什么的，Excel 里 行i是编号而列j 是ABC ，当然SQL里也差不多，做学生成绩单时就可以分门别类做排行和统计了，给定i 你能知道某个学生的数据、给定j 你能知道某个学科的数据；关键在于其上的操作

我们知道像素图、Excel 本质都是有宽高的一堆格子，给你张图片，让它转90度咋办？先看这个表格，列数m=3, 行数n=2 ，那是横着的；转过来 n=3,m=2 ，原第一行就成第一列，那行1列2 就变成行2列1，把 a[i][j] 变 a[j][i] ，同时 n,m 也交换下就行了

而且现代计算机里代码也是种数据，所以就有了函数指针 run(int op(int), int n);

你可以把指针理解成装在盒子里的一个值。
简单来说很多应用需要序列化，C 语言可能不需要，因为它从没把数据对象从内存里拿出来过。给个Point{x,y}你直接算好 size 去 write/read 都能保存加载

在 C 里，数据=多项数据=内存=指针 ，C里 数据=局部分配/new分配, 多项数据=始末指针/始指针+长度/多项容器内指针 好多啊 mo??

链表是这样的结构，直到末项 xs=NULL ，每项都有个 T v; ，啊实现添加和遍历操作 llAdd, llEach

然后还可以把这个链表每项值直接存在 struct 里，就是说把 xs 这个 next 指针放每项数据里，避免多余 malloc 分配，针快(哔

我们来看看它都联动了哪些：
Lisp的 car/cdr =首寄存器内的指针
Java的 Integer,Long 等装箱类型
\0-终止的字符串, 只是 next 永远=指针x+1

《大猩猩》

而且这居然是 C 的作者觉得比它的前辈 Fortran 处理得更灵活的地方，当然灵活是真的，但不严谨，所以你只会看到 C 程序出现 SEGV, 内存不能为(cannot be) read/write 

所以什么说指针难讲，它混合了 存储分配、数据引用读写、数据生命周期(堆上/栈上)、复制与装箱、数据多项 ，是个整数蜈蚣啊，那既然难讲这期会多啰嗦几遍喽。

这么小小的一个竟然横跨计算机的半个世纪

刚才说 char** 另一种写法 byte* [] ，那 byte* 自然是没有长度的 buffer 喽，应该知道 strlen(s) 是算这个内存到 \0 的 byte 个数，嗯 C 用的是零结尾字符串，一般都用 asprintf() 填写不能直接写入/终端的本

C++ 的在于散乱。stl 的 vector,list,stack,deque 都是列表状数据，很多人喜欢混用， 也没有所有人统一的 foreach 写法，尽管 for() 是 C++17 早就引入的

咱说数据其实是靠其上所有操作定义的，除了 int a=1; &a 还有什么方法能带来一个 T* 指针类型？局部数组、结构体。这也是 C 程序员从 main() 函数开始就不得不被指针模型扭曲的数据集/和对象

几乎所有小白初试 C 都会写出 int xs[]={1,2}; return xs; ，而且看到警告还很困惑，语法和意思都是对的啊？甚至偶尔程序还能正常运行

那么不能正常时 比如你把这个结果指针拿去调用另一个函数 而不是返回后立刻取值；实际上 C 对不规范的程序结果几乎不作保证，强制你对每个数据/集知道何时 free()，它的高性能就源于此

指针是对有效数据存储位置的引用，其上有 *x, *x=val 读写两个语法，当然也有 +- 和 == 的基础计算，如数组 a={1,2,5} 是不是 a[1]==*(a+1) 也 =(byte*)a+sizeof(int) 的 *((int*) x) 解指针呢？ C++ 是不是经常判断 for x!=end 呢？
引用是自动取指针、指针赋值的特殊类型，如 int f(int&i){i=1}; int age=10; f(age); 实际设置了(&age)，它是指针的语法糖

把指针按生命周期分成堆指针、栈指针

总而言之，只要读写指针的是被调方就可以，或者说它俩分别是 2,1 ，那读写(比如函参数,数组,变量) 2>1 就行，越小活的越长，也就是 Rust lifetime 的入门

分配就是内存的区间，或者说切片

智能指针 Rc 是带了个引用计数的分配，比方说它被存入全局数组和某个函参数里，函数返回 -1, 全局删除 -1 变成0 ，那就立刻 free() 掉

缓存可以用 eakMap

malloc, calloc, alloca; realloc

系统提供 mmap() 分进程虚拟地址空间，libc 提供 malloc() 堆算法地址分配/即内存分配，GC 算法和语言提供对象引用图/根节点自动 free() ，你的应用才能随意创建各种[]对象。

C 里是没内存对象的概念的，只有地址区域独占，即内存分配。

注意 Python,Lua 是用了全部的这些“虚拟化”的，它们相对低层，有 bytes() 但那也带 GC 的!


*(&1)=2; *(&"")="wtf"; 不仅在语法上没错，甚至可通过编译

32位机是不能很好支持4GB以上内存的，FAT32 也不能存储单文件4G的情况

只有 ABCD sp bp 六个常用寄存器(后面加x)，还有复制操作源至指针的 si di ，那么位长度 ah/al, ax,eax,rax 分别是 8/8,16,32,64 就是个简写啊。

code/data 啊，不过汇编术语 code 叫 text, data 是存在的，但很多人只用 .rodata .bss

.plt

