1
00:00:02,160 --> 00:00:05,640
下面的内容是关于涉及到二进制的 C/C++ 编程，

2
00:00:05,840 --> 00:00:10,099
大部分JS/Py的应用侧程序员 可作为强基的知识点去了解，

3
00:00:10,320 --> 00:00:12,959
毕竟你保不准要和C编写的接口交互呢，

4
00:00:13,160 --> 00:00:17,720
我会尽量以大家能理解的顺序去细讲，希望你能坚持多刷几遍哦

5
00:00:18,240 --> 00:00:22,830
WASM也越来越多用于浏览器里，可以轻松移植处理工具，

6
00:00:23,000 --> 00:00:27,170
制造基于 SDL,FluidSynth,VOSK 等AI音视频应用、

7
00:00:27,360 --> 00:00:30,000
高性能做到普通网页完全想不到的功能，

8
00:00:30,200 --> 00:00:31,610
如果只是靠照猫画虎，

9
00:00:31,760 --> 00:00:36,080
不懂C数据类型的区别，写JS的你敢做WASM EM_ASM() 应用吗？

10
00:00:36,440 --> 00:00:40,910
比如 xch-ceb.github.io/xch-web/ ，就是移植了一个 Rust 控制台应用，

11
00:00:41,120 --> 00:00:45,500
只需交接两边的字符串，就能直接从浏览器调用C兼容的程序、

12
00:00:45,720 --> 00:00:48,420
在浏览器端执行 ls, cat 等命令

13
00:00:48,680 --> 00:00:50,870
你可能看到谭某强一流的教程，

14
00:00:51,040 --> 00:00:52,120
这些教程告诉你

15
00:00:52,280 --> 00:00:55,129
表达式内执行顺序与等号,赋值操作的值，

16
00:00:55,400 --> 00:00:58,930
还有计算机只认二进制、用补码去支持含负数加法，

17
00:00:59,120 --> 00:01:01,309
还画蛇添足的教人咋做进制换算，

18
00:01:01,560 --> 00:01:03,779
但他们都不会告诉你为什么得是二进制，

19
00:01:04,000 --> 00:01:05,710
计算机又是如何利用它的。

20
00:01:06,000 --> 00:01:08,070
让我们从计算机的来源谈起吧。

21
00:01:11,080 --> 00:01:13,510
人类的思维有没有极限？

22
00:01:13,720 --> 00:01:17,270
倘若把咱的思考扩大到整个宇宙，肯定会找到一个接近无穷大的数，

23
00:01:17,600 --> 00:01:20,509
随着规模的扩大，肯定有些数是无顶限的；

24
00:01:20,720 --> 00:01:23,869
倘若数一个数只耗1微秒，要数完也是不可能的；

25
00:01:24,040 --> 00:01:25,450
但咱都不是火星人，

26
00:01:25,640 --> 00:01:25,850
你

27
00:01:26,040 --> 00:01:27,741
一天吃几顿饭？有几个朋友？

28
00:01:27,920 --> 00:01:32,420
现实的问题是有数目的，而有顶限的现实问题，才是计算机的问题。

29
00:01:32,720 --> 00:01:34,100
如果你要表示一个文本，

30
00:01:34,280 --> 00:01:35,420
就说是一串字吧，

31
00:01:35,840 --> 00:01:40,520
比如是两个 长度N=3 的列表，每位从 "abc甲乙丙" 里随便选，

32
00:01:40,720 --> 00:01:43,070
N能不能是无限的，不能因为内存有限；

33
00:01:43,400 --> 00:01:45,180
那这个 abc甲乙丙 也不真实啊，

34
00:01:45,440 --> 00:01:47,379
中文有三字经、百家姓、千字文，

35
00:01:47,680 --> 00:01:50,139
新华字典里出现了多少字也不可能就6个吧，

36
00:01:50,320 --> 00:01:53,600
但是人能学八门语言。不考虑它们间交流时的一致性(协议/规范)，

37
00:01:53,920 --> 00:01:58,300
计算机能不能无限制扩充字符集，也就是字串里每位置的可能性？

38
00:01:58,600 --> 00:01:59,469
扯点有趣的，

39
00:01:59,720 --> 00:02:03,860
外星人来地球，靠一根火柴杆，怎么把我们的所有文化记录带走？

40
00:02:04,080 --> 00:02:07,260
我们可不可以把这些东西表达成一大串二进制？

41
00:02:07,560 --> 00:02:13,260
如果浮点数是无限的，只需在它 a% 的长度划道杠，而a编码了这一串二进制；

42
00:02:13,480 --> 00:02:16,899
是不是可以说a这个巨长的小数等价人类历史和文化？

43
00:02:17,240 --> 00:02:20,930
但是计算或测量都是有精度限制的，这只是理论物理；

44
00:02:21,080 --> 00:02:22,010
我们刚才强调，

45
00:02:22,200 --> 00:02:24,210
计算机的问题是现实而严谨(即限制明确)的

46
00:02:24,480 --> 00:02:26,100
刚刚谈的不涉及编码，

47
00:02:26,280 --> 00:02:29,009
编码是字符列表和字节列表间的等价关系，

48
00:02:29,280 --> 00:02:30,840
一串长文本是可以压缩，

49
00:02:31,040 --> 00:02:32,480
也有不同字符集大小的，

50
00:02:32,720 --> 00:02:38,600
只有文件才有编码的区别；而在它的字形显示在屏幕上之前，都只是一串数字编号而已

51
00:02:39,760 --> 00:02:44,269
刚刚我们每位有6情况，最低需 log2(6) 位二进制去表达

52
00:02:45,160 --> 00:02:49,780
之所以要用二进制，因为它是唯一每一位非此即彼的『位置记数法』(好比 if,switch)，

53
00:02:50,000 --> 00:02:54,800
我们知道记数法只是数值的表达，而数的实质是「加减乘除比大小」的这些运算 方法，

54
00:02:55,120 --> 00:02:57,194
可不可以说内存、闪存、磁盘磁道上，

55
00:02:57,360 --> 00:03:03,240
哪位有电子就是1、没电子就是0，可以吧？可不可以说电线高电平是1低电平是0？

56
00:03:03,440 --> 00:03:04,459
那电子和时差是不

57
00:03:04,720 --> 00:03:07,001
是物理对象、物理值，是不是有限的；

58
00:03:07,280 --> 00:03:13,280
所以计算机的核心，存储、运算、程序跳转，不仅行为是可预测的，存储规模也分型号

59
00:03:13,520 --> 00:03:18,460
如果没有这种对每个1 的作用锱铢必较的心态，很难利用二进制编程，

60
00:03:18,720 --> 00:03:22,259
因为计算机的世界只有0和1 ，0就是错1就是对，

61
00:03:22,440 --> 00:03:24,570
没有一个缓冲区让你知道错在哪；

62
00:03:24,800 --> 00:03:28,880
C里的许多片段许多陷阱，没有调试器让你知道是从哪一步开始错，

63
00:03:29,240 --> 00:03:33,050
一旦执行，成败在此一举，有时候错了它也能正常运行(检错,如索引越界耗CPU)，

64
00:03:33,240 --> 00:03:36,000
但这种对处理过程迷迷糊糊弄不清楚的程序，

65
00:03:36,200 --> 00:03:39,049
你会让它运行在日访问千万的服务器上吗？

66
00:03:39,320 --> 00:03:39,829
所以

67
00:03:40,000 --> 00:03:42,899
如果你想用不断改参数，重试的方法写C程序，

68
00:03:43,880 --> 00:03:47,511
我建议还是先学了JS这些调试友好、便于观察的语言再来吧

69
00:03:47,840 --> 00:03:50,510
虽然一些教程对这些细节分割不合适，

70
00:03:50,680 --> 00:03:52,630
但了解它们的重要性并不夸张

71
00:03:52,880 --> 00:03:58,550
如果以一堆数字表示字符串，或者说文本；显然有个长度，也就是说在何处终止吧；

72
00:03:58,760 --> 00:04:02,000
C 选择了 '\0' NUL 字符结尾的流(无关长度)式字符串、以 argc,

73
00:04:02,280 --> 00:04:03,331
argv 按参数

74
00:04:03,640 --> 00:04:04,089
分离长度信息，

75
00:04:04,480 --> 00:04:08,680
而 C++ 则将字符串长度和编码、列表指针与长度组合了起来

76
00:04:08,880 --> 00:04:11,250
其实编程的许多问题，例如序列化(如二进制读写)

77
00:04:11,480 --> 00:04:16,670
都是对这些单项有多长的胡乱计算；不同语言、不同人有不同的写法，可能都对，

78
00:04:16,880 --> 00:04:19,399
但清晰度和可复用性会有很大不同；

79
00:04:19,600 --> 00:04:23,220
输入的一类参数改变了，有的人只用改一行代码就能兼容，

80
00:04:23,440 --> 00:04:26,410
而有的人 要支持，得改100行，不要也得改100行；

81
00:04:26,800 --> 00:04:30,640
可配置与否高下立判，更统一，是 C++ 更常用的原因

82
00:04:31,720 --> 00:04:36,380
计算机的存储，就是把读写速度快慢、掉电易失非易失的内存和外存里

83
00:04:36,720 --> 00:04:40,110
可能是01 的一堆二进制位，按照某种结构进行解释，

84
00:04:40,280 --> 00:04:42,200
解释的最小单位称为『原始类型』，

85
00:04:42,400 --> 00:04:44,739
它作为计算和转换 的参数也叫『值』。

86
00:04:45,080 --> 00:04:48,230
比如 32位一个整数 int 或者真假值 bool,

87
00:04:48,440 --> 00:04:48,950
8 位一个 char,

88
00:04:49,360 --> 00:04:52,630
或者一个长度跟一块独占的内存片构成的列表、

89
00:04:52,800 --> 00:04:54,510
一个标签跟一个内存片指针，

90
00:04:54,720 --> 00:04:56,250
或者尾随独占的内存片，

91
00:04:56,480 --> 00:05:00,350
把它依标签进行解释；它们也是值，因为只要有『计算方式』，

92
00:05:00,560 --> 00:05:01,880
就有相应『类型』的值。

93
00:05:02,160 --> 00:05:03,630
C 里左值意味变量，

94
00:05:03,920 --> 00:05:06,050
或者存储位置；右值意味(字面)常量，

95
00:05:06,200 --> 00:05:07,609
只有左值能被重赋值，

96
00:05:07,800 --> 00:05:09,839
比如 i++ 就对、 1++ 就错 (除const i=0

97
00:05:10,120 --> 00:05:11,080
正是因为对内存

98
00:05:11,280 --> 00:05:13,229
位置(=指针)的暴露过于赤裸而不严谨，

99
00:05:13,400 --> 00:05:15,739
对组合、分支类型的存储方法不统一，

100
00:05:15,920 --> 00:05:18,260
对存储器和编程思维的区分太小，

101
00:05:18,680 --> 00:05:18,951
C 语言，

102
00:05:19,160 --> 00:05:24,530
是相当容易被误解的二进制语言；C 语言何须序列化？它操纵的内存就可以被存住，

103
00:05:24,680 --> 00:05:31,484
它甚至能直接在外存里计算、读写传感器等外设的信息共享，所以现今操作系统、文件系统 C 一家独霸，

104
00:05:31,800 --> 00:05:33,690
但，它不会是门好的『编程语言』，

105
00:05:33,880 --> 00:05:36,880
过度的自由和技巧，势必导致难懂和混乱，

106
00:05:37,080 --> 00:05:39,359
当你只是要把 [123]的每项+1,

107
00:05:39,560 --> 00:05:45,289
为啥要在意它遍历的索引(项编号)区间、存储在什么地方、何时解除分配、乃至每个数几字节、

108
00:05:45,520 --> 00:05:48,004
内存地址是不是连续的(链表,..)，这些无关细节呢。

109
00:05:48,240 --> 00:05:49,140
程序代码、机器码

110
00:05:49,480 --> 00:05:54,145
也是这种列表和分支的结构体构成的，其实计算器也算计算机，

111
00:05:54,320 --> 00:05:56,810
但它的程序是写死的、功能是固定的；

112
00:05:57,000 --> 00:06:01,950
而基于几行指令和常量数据，读写存储、进行运算程控 传感器IO，

113
00:06:02,120 --> 00:06:06,409
得到新数据或副作用，就是现代存储程序型 电子计算机的全貌，

114
00:06:06,680 --> 00:06:14,420
无论各种操作系统还是能下载的软件，在那个时代都是不可想象的，直到程序即数据的『冯·诺依曼计算机架构』出现。

115
00:06:14,720 --> 00:06:17,870
所以现在我们知道数学和编程最大的区别，

116
00:06:18,080 --> 00:06:22,280
数学是一套思维方法，而计算机是思维和现实交融的那个点，

117
00:06:22,520 --> 00:06:25,460
既足够抽象而广泛，又步骤分明，可以实现

118
00:06:25,680 --> 00:06:29,850
把一类现实中的问题，严谨地分变量、分类型、分规模去讨论，

119
00:06:30,040 --> 00:06:33,190
就是计算机科学……中接近电子科技的部分，

120
00:06:33,440 --> 00:06:38,599
但这现实与统一的思想却横贯整个计算机，而数学，恰恰是不重视限制的

121
00:06:38,920 --> 00:06:43,810
那么计算机有没有无穷大？有的，毕竟我们只是严谨化了数学运算规则而已，

122
00:06:44,040 --> 00:06:46,440
有一个 Infinity 不小于任何数、

123
00:06:46,640 --> 00:06:47,930
(-它) 不大于任何数，

124
00:06:48,080 --> 00:06:50,719
加减乘除对它意义不大，它真正的意义是，

125
00:06:50,920 --> 00:06:56,860
任何数>Infinity 恒为假，所以，在任何时间你都不可能解决一个规模为无限的问题，

126
00:06:57,080 --> 00:07:01,040
比如刚刚的数完宇宙里所有的星星，那不是计算机讨论的问题

127
00:07:01,280 --> 00:07:07,009
现在还在对除和除以锱铢必较的人，可以考虑下，除数不能为0 ，被除数可以，

128
00:07:07,160 --> 00:07:08,690
但是在浮点里 1/0

129
00:07:08,880 --> 00:07:09,510
是可以的，

130
00:07:09,680 --> 00:07:14,210
因为任何数里都有无穷多个0 ；我读作0除1好还是1里除0好？

131
00:07:14,480 --> 00:07:17,270
说程序是由常量、变量、运算符构成的。

132
00:07:17,480 --> 00:07:22,100
不是，如果教的是 Ruby 这种表达式语言还算对吧 arc=2*r *PI ，

133
00:07:22,400 --> 00:07:22,639
但 C

134
00:07:22,800 --> 00:07:25,555
文件层 的语法结构是很死的，也没有 REPL

135
00:07:25,760 --> 00:07:28,063
这样方便的调试工具，你这么说？

