https://visualgmq.gitee.io/other_pages/wasm_sdl_demo/index.html
http://main.lv/writeup/web_assembly_sdl_example.md
https://blog.csdn.net/leafrenchleaf/article/details/106794571
https://blog.csdn.net/leafrenchleaf/article/details/106880622
https://cloud.tencent.com/developer/article/1133982

https://atsushieno.github.io/2021/05/18/ktmidi.html MIDI
https://github.com/mmontag/chip-player-js
https://github.com/ccoreilly/vosk-browser

rundll32 user32.dll,LockWorkStation #还不如直接上 bat,ps1 脚本
rundll32 powrperf.dll,SetSuspendState #锁屏、休眠(rundll 限制不能调睡眠)

$sh=New-Object -ComObject WScript.Shell
$sh.CreateShortcut("a.lnk")
$sh.TargetPath="sysdm.cpl"; $sh.Save()

最大(a,b)=a>b? a:b
最大3(a,b,c)=最大(最大(a,b),c)
折叠(合, 列) {值=列[0]; for(i=1;i<N;i++)值=合(值,列[i]); 回 值}

和商余
异或_按位交换
闰年(n)=4,!100, 4*100

/[我个]?草[爸妈奶你]?/g[
Symbol.replace]("草",
m=>"口".repeat(m.length)
)

用这种方法自底向上的学习语法结构无异于管中窥豹、盲人摸象，如果你想真正自由地重构程序，没对基础定义、程控、表达式 语言结构有个概念是不可能的，从关键字、不能咋给符号命名入手一门语言，一些人还真是有编译原理的心没编译原理的脑啊，咋整这么麻烦，讲半天一个完整逻辑没写出来，让你去菜市场买菜  跟大妈争议起微积分的微有几种写法，还觉得啊卖菜不懂微积分行不懂微机(微积)二字怎么写咋行，给爷整不会了都

啊我还看见有人把三位数和三个数混淆的，也是个人才；那为什么三项最大值可以用这种淘汰法，因为 (>) 比较运算有传递性，若 a<b 且 b<c 则 a<c ；大于号亦然

编程的世界没有那么多对象，只有两种东西，「动词」和「名词」，也就是数据和程序

那值是什么，值是名词啊，123 都可以叫名词，有了函数和+-*/计算，它们的参数和结果才叫「值」嘛 ，如果函数和计算都叫「动词」，那我们定义 1+1=2 规则; 然后在 加1(n)=1+n 里有两个名词，一个是可替换的一个是1，那是不是也说得通啊；当然这个区别其实不宜废除，我只是带大家看破这堆无聊的语法，变量是个东西嘛？变量就是可变的量而已，但是C里面任何变量都能 &取指针 ，它还真是个东西了 独立了，所以我说容易写乱；你某个计算都没想好  还要区分 int* 和 int , 是不是有点太烧脑；它还不止是个盒子呢，还能加减拿到相邻盒呢，你知道啥时有用的必要吗？知道它和另外啥变量相关吗？反正我是懒得区别

再说可变性：变量就是一段程序内能重赋值的量，不变量就是一段程序内不能重赋值的量、常量和字面量是整个程序执行期都仅有一个取值的量；其实只有没啥用的常量是整个程序里取值不改变的，变与不变都是相对在执行的子程序、{} 而言的，它就是一种严谨的限制，毕竟程序生命的意义是处理随时可能变化的东西
(const,final 是可变性、static 是全局的生命期, const int* 是不可 *x=v; 赋值,写入的指针, int*const x; 是不可重赋值,改变的指针变量)

那面向对象是什么，就是给动词一个能不写的主语嘛；世界上那么多人，每个人有头脑有心肝，那我可不可以这个人没头、那个人没胃，但还要我支持计算它们的健康指标？子类继承自一个类，它的动名词只能更多不能有缺少，词集上是超集，类型安全；相关的东西共享一个动词(方法)集，没毛病；那既然说主语不用显写，主语的类型是不是也可以是任何兼容它的类型，它的子类？于是有了覆写，同样的动词基于变量的当前类型，行为不同；比如 点击监听.执行 (A.f 即 A上的动词f) ，网页里是不是有很多点击监听的实例，它们都仅有 执行 一个动词，但通过创建子类，我们可以让被调方API接受它后，有不同的行为

刚刚讲的前两个是封装、继承，后两个是抽象、多态；有 构造器与名词+动词的封装才有继承，有子类兼容超类、超类名词能被赋上任意子类实例的值 的这种抽象，才有同名不同义的多态
(interface 就是只有成员类型签名的 能被 implements 的 abstract class, 它和普通 class 都是类型，但不能 new 出值,实例)
(static 成员和构造器变量无关，是全局变量； final 成员不能被覆写再定义)

要是没 `o.fn(x1,x2)` 这种中缀语法有没有 `$(".wtf").each(e=>{a.push(e)}).attr("id")` 这样的链式调用？有，但要写成 `f2(f1(a1),b1)` 这种逆序嵌套的形式，那可真是一点都看不懂了

刚刚谈的「动名词」，真正的意义不是教大家理解面向对象，老实说我挺看不上现在有些人滥用面向对象进行过度设计的，冗长的代码一套又一套；刚刚的『点击监听』类，其实就是把几个值(点击目标,时间..)变成一个值(Void) 的操作，不就是一个函数吗？专门起个名字，大家都不得不用 class 去定义一个能分段执行、与人共享变量函数，把它的参数写在构造器里、用匿名子类(现已有Lambda)，实际造成了很大冗余语言结构

语言结构越严谨，思想和过程的实质就越匮乏；正如一个人越是总爱侃侃而谈，背后的积淀就越少；如果你老想着服从这、规范那，这些表面功夫，是没法真正感受程序运行时各名词的变化的，很不巧，无论是算法还是应用，它们的实质都不是某语言的代码，而是我们能一分为二逐步解决的问题，是我们想要代码带来的结果和副作用，比如删掉用户输入里的脏字、或者开启一个窗口画布不断响应用户输入与交互

eBtn=doc.body.children[0]
计时=(e,f)=>{let t0;
e.onmousedown=时(t=>{t0=t})
e.onmouseup=时(t=>f(t-t0))}
时=f=>ev=>f(ev.timestamp)

计时(eBtn,dt=>alert("秒差"+dt))


class 聒噪(xz:迭代器): 迭代器{
int i=0;
T 下项(){T x=xz.下项();
out.println(i+" "+x);i++; return x;}
}
for(int i:聒噪(List.of(1,2,3)
.iterator()) ){}

def 聒噪(xz):
  i=0
  for x in xz:
    print(i+" "+x);i+=1
    yield x

for 项 in 聒噪(iter([1,2,3])): pass

而程序的实质，不在任何具体的值、不在任何单个的变量，正如 1+2=3 ，两个数字就只有个结果而已，(a+b==c)，是加号这动词，结合了两个名词，得到c这个加法结果，才有 c-a=b, c-b=a 等一大堆衍生操作和性质；单一的名词、单一的值意义不大，是因为一个动词把它们组合起来，它们才能赋予彼此意义；多利用函数抽象几个变量间的逻辑，你的程序就会变得优雅易读又简洁

算式的结果是没有名字的，也不该有名字；直接插入下一步计算就得了，像不像软件背后的程序员；隐姓埋名，却做了真正了不起的东西
呵那些赚大钱的游戏背后有无数程序员的辛苦付出，从界面、物理、电子机器到框架设计的各种部分，哪怕是抽象美工也没有一刻是离得开计算机软件，他们却不求回报，只有软件的名字却被所有人记住，人们只想知道那些赚大钱的建模技能和少年天才等噱头；没有任何理由，只因为想而编程，这就叫工程师，这就是科学人的精神

我们再来谈谈『对象』的概念

把(这堆箱子) 数完
把(这堆箱子)今天内 数完

「计数」是不是一个对每个箱子都有的动作

但是一个是立刻，一个是它有一个时间范围，可以暂缓插入其它动作，它的范围我们称为生命周期

前者是 int i=0; for(箱子 项 : 箱子堆) i+=1;
后者是
class 计数器{
  int i=0; void 增(){i+=1;}
}
var 计=new 计数器();
箱子堆.forEach(计::增);

这个 forEach 有没有定义它数的每项耗了多少秒？没有吧，所以对象引入了扩展性
我可不可以边数边发声，或者同时数几堆箱子？单个 for 循环的行为是确定的，但当我们把数箱子的动作，拆成「从0数」和「对每项操作」两个部分，就有了很多新的可能；我可以边遍历边 println ，而这个修改对『计数器』是兼容的

函数提升一级变成类，它的参数变成构造器参数、局部变量变成字段和属性，
它的执行被分成几段，对它的调用变成实例创建后，其上方法的调用；面向对象就是把一个「立刻数完」的即时动词，变成一个可以改变参数、插入其它操作，例如 Iterator.next() 后对单项处理，的开放性动词
如果我们这样理解面向对象，是不是能更好的在建立函数和 class 间取舍？

刚才的把字句，主语是什么，可不可以认为是 ForEacher ？但刚刚的代码是 箱子堆.forEach(计::去增1) ，主语是一堆东西，大家切忌过多 XXer XXor 各种干啥器 主语的面向对象，那叫过度设计
「面向对象」编程是编程，不是粗制滥造不必要的对象。能不把单一动作变成对象，就尽量别这么做，切记。

编程没有正确与否，只有简洁协调与否，因为它只是我们达到目的的手段。死死盯着你的最终目的，不要沉溺于代码，为解决问题制造更多问题

现实生活中的持续性动词是不是比即刻动词多？一条跑道两个人比赛，是不是我先跑你再跑，看谁耗时短，直到有人赢了两次，啊欢呼；这个比赛者是不是对象，跑是不是动词？不过比赛过程中「跑」会执行很多次，「欢呼」后它的生命周期才结束；所以面向对象比单一过程式更适合写软件应用；程序员可以只把对象提供给框架，来修改它的行为，而不必考虑整个软件架构；比如事件-重绘制的主循环
