


身份ID验证无论设计用户系统还是外帐号绑定(可能靠WebHook) 都需要，在一些小网站或单机上只需输昵称就能保存设置，我还能自称雷军呢！可要防伪造，“密码”性质的东西首先得长、每位情况要多，而且不可枚举或爬取；如视频网站，UID被“视频、评论”所引用，就需要帐号+密码两部分供 makeVideo(uid,tilte) 等校验限制，但明文发送密码就无语(数据库内密码也该靠相等hash)；往往以UID-“临时令牌”保证UID是本人，令牌(指向可信数据)由密码等验证方式签发，下例中服务重启时吊销。总之会话『验证』是指对每次请求都可取「可信」身份。被百度使用的 Session-Cookie有个全局 Tok-UID表，而JWT 利用密码学签发UID-私钥的限时令牌，利于分布式；至于2fa、限期换密码、单次密码 啥的就有点杂了，但都是靠服务端临时存储或密码学

举个例子，验证码提供方会生成图片和其临时ID(即cookie"饼干屑")，只有还原出ID-图内文字才继续流程；OAuth等同样是临时ID存储取代每次收密码


四种排序文字动画、.got.plt动态链接hook、曼德博集与隐函数绘制、正余弦-心电图动画、S表达式转思维导图、BIOS汇编API+C链接

因为想学『编程语言』而离开的这段时间我一直在努力搞懂解析器和AST、范式与技巧、浏览器API，追寻程序和数据间的等价关系、追求与之俱来的表达优雅性，我正视之前的历史如GeekApk.. 正是从那时我感到心有余力不足，当然它是可实现的，只是尚需我写几个框架

所谓「元编程」，正是从你开始了解class,new 这些语言结构都能拆成啥，有啥可修改开始的。元编程就是编程，只是自语言成为你的语言，编程就不再只是从惯用法堆积，总能以技巧避免冗长重复的代码、让等价变形破除对道听“规范”的迷信；而当推倒再来的重构达到一定次数，就能从整个软件的活流程与死结构中看到「更大的东西」——那些最常用的动作与参数、低频但不可少的东西；历经洗礼变形却仍未破败的宝珠，值得我们用最大的精力和创新去优化。

现在去IDE化等因素确实不利我创建“大型”“实用”项目，但同时 JS,Py 等语言暴露的领域基本操作和REPL草稿工具也利于我重复实现些语法/结构复杂的东西；同时项目式管理也不过是细节过度的文字模板，一味强调自身体系的宏大性、仅提供片面多冗余的示例，甚至丢弃了GNU-make时代的简写灵活性


就像17年说的，我会始终坚持开源精神 求知若愚。有我懂一颗螺丝，就有你们的一颗螺丝。
但现在我知道菜确实是原罪，但那些清醒并正在自我救赎的人，都摆脱了大环境的恶和人性的惰。对技术人始终待人和善

当然啦，以后我讲一种流程可能不会细到具体API名动词，因为需要的人毕竟是少数；更多是以领域输入输出、动作-状态、流向-数据分片 等概括法和链接、搜索词 去写些工程小科普

现在时序,设计模式,class结构元编程 已经因Range和举短例模拟,函数式,JS等动态类定义 不成问题；我也不再是需要逐括号背代码仍易语法或API错误的人了——设计只在脑内进行、组合与复用平平无奇。如果它难看散乱，就把它封装得好看点；因为语言既有层次和语义 也有易读性啊。有自信完全理解了编程语言结构和系统进程级流程的人，才敢于用自己的想法和语序实现一切，走过五年，我很想回来多写点应用。

计算机科学实在是太多了，我只能收集有趣而不太难的部分科普(几何绘制都有十几种混成模式...虚拟机也有几十条指令，不举用例不排序归类等于白讲，这些东西对实际编程是潜移默化的，因为你始终需要自己动手灵感或翻阅)
泛滥框架而非通用理念、API和套版代码，冗长的 ret= return ret 这种命名狂魔，把核心与私货(如Map/HashMap,HashTable..)混为一谈，看到 Kotlin 等语言的趋势、Py 的火也容易发现是与编程目的相悖的。我的分享不是为它们，最终是想打破这些无关思想的文字游戏
实际上JQuery那种工程，我也只能说是有它的选择，没有高低上下；因为想最优雅地完成编程目的，即便不考虑用法兼容，只有融合许多东西的优点才可，没有优点是低贱的。

说话就是编程，只是没有细到数据类型、程序基元的程度，如果能把所需最小API也视作基元，编程就有了系统性，并非从示例拼缀堆砌。若站在平台作者同一层次思考，而不是被动记住他人对问题的理解，能找到属于自己的语序和详略度。
说到底元编程与编程、各编程语言、人与计算机语言间的区别本就不存在，只是因为繁杂性；如果语言的美能战胜繁琐、涵盖繁琐，相信就有一个更统一、易用的系统能出现吧。

去除文件的所有空格 (bash cat a|sed 's/ //g' >a)，若扯到 File read write 乃至 byte[] buf 和 Stream,Charset 就能写10+行，如果说 File("a.txt").pipe{it.replace(" ","")}.out() 就会看出很多可参数，各人各时期会有选择，但若你经常用、改配置，每次写全是不可取的，为性能也不行。
定期截图网页可用 DevTools 协议(CDP)，完整周期 最后 data:base64 发回 png，再由/etc/crontab 执行 $URL/`date -I`.png ，如果只见框架名词反而会更难

输出彩字JSON
对"",Num,Bool,null 直接写缩进+彩色文本区间(span)
对{}[]内每项以缩进+1 继续

对单项得span文本
对{}[]内项重写为缩进+("k":+) 继续(缩进+1)，末项尾+=上一层缩进 给} 换行。

在生成序列时是write拼接还是每层 ""+"" 无谓，只有输出嵌套结构才需返回值指定；求值是只依赖子树的值再计算的，所以叫止常量深先重写。1+2*3= 1 23* + 这些才有算法图论里的前中后序遍历

因为对『编程语言』感兴趣关注我的人，感谢你们的兴趣。尽管我还没经历太多实验，在这里我给你较完整的词典：
>ps. 我一直认为好的代码是横着写的，但密集到这个程度也很可怕吧…… 毕竟是因为内容本身就广啊

宏=宏大的代称。以短实现大，一般指像PHP始于小问题的预处理/录制回放语言。此名词太含糊
元=基础的成分。如元素、基元、元循环；往往不可再分
元编程=重写算符语义、利用执行前结构信息(如序列化器,待注入成员,IPC函数)的编程。因框架概念和行复制泛滥，以及对列表操作的不熟练，变成需额外学的东西
列表操作=流操作=文档数据库=映射map 过滤filter,first 排序sort 组合zip,flat,chunked(paged),groupBy.. 归纳reduce,join,all,any..
SQL=抽象点的Excel列表过滤。如 N:N 关系(无属从1:N) SELECT a,b,time from user_follow where b IN (SELECT id from user where name="某")
绑定=让领域概念(SQL,XML,DOM,Widget..)对语言更易访问和区分
代码生成=输出到src/buildDir 以合规的文本/二进制结构
主循环=消息循环=任何不是(询问并)执行完就退出的软件都需要响应交互，如UI、httpd、pygame游戏，这时由事件-效应器 构成产销队列会利于UI重绘等代码复用或多线程，是种阻塞poll队列；而消息队列会处理重试、死信记录
依赖注入=通过构造器、属性(注入点) 按类型乃至所处模块隐式提供某值，例如各种数据库,JSON,Zip,上传下载 工具的配置.. 框架对用户对象基本先用注入器，无论动态静态类型语言
注解=Annotation=JDK术语，@interface ，可以保存些编译期数据并作为APT 的标记，如 @Override 来进行些额外检查、代码生成。Java里乱眼是因起名太长、使用过度频繁(无默认值式设计 烂大街)，仅使用单个不影响APT预处理能力
事件=主循环能访问到的函数值，用于灵活扩展(如+网络API调用进度)。 HTML-DOM 支持冒泡(父元素代处理)和捕获(反向冒泡)，多框架上都可理解为待调用函数列表。
回调=扩展函数功能的参数。函数值，单次调用现称 Promise 或 Future，其参返类型比在哪方代码调用多少次重要！如forEach(x=>) 替代 Iterator, map(u=>u.name) 替代 List b;for(x:a)
await=协程=断续函数=yield Then(fn) 式函数待fn被调用则恢复， awaiter 调度器执行 next() 到的任务并在结果时交给 z 恢复，所以await只能在断续(yield)函数里使用。z=asyFn();2==z.next(1/*==yield 2*/) .协程间上下级(非对称协程)利于分步任务
grid=横纵方向个数手动的flex，对行排版的补充。靠换行对齐与溢出/浮动排版基本写 nav-main-footer ,3列布局都要大量的宽高计算；利用 template- rows columns:repeat(3,33%) 及 gap,grow,dense 等参数就切分好一个大区域，也支持 align/justify。
响应式=基于@media 判断改布局网格来兼容resize， viewport 和 2x pixrate 等就是这边的术语；此外 % rem 取代px、box-sizing:border 也常用
异常=SEH=非局部return。try catch-throw finally 块(尝试接迎抛下皆有)，finally=trycatch内皆有，Py throw=raise Rb begin rescue ensure JVM线程可设默认捕获；非RuntimeExc异常在Java是调用即检查的。throw=带错误JSON直跳回最近的catch
类型推导=类和函数可以基于<T,R>等特定类型定义如 List<E>，型参默认无extends 限制，即只有各位置(get,set,T->R..)唯一性。泛型推导是对含参类型内参的归一，如 <AB>f(b:Box<A>,op:A->B):B=op(b.x) 对 f(Box(1),Int->Str):Str 各处AB有交集且其符合API。运行期JVM只能在元数据拿到型参实际class(泛型擦除)。
型变性=子类型兼容/out-in extends-super PECS(Producer-E,Consumer-S) 原则即 Func<in A, in B, out R>,Func<?super A,?extends R> 。out只在get，in类型只在set位置，这样定义 Get<Number> 就兼容其 Get<Int> Get<Long> 实现.. 而 Assign<Int> 反向。
ClassLoader=在首次用到类(static成员,方法调用..)时按带包名、Listener$内部类 的全称类型名(qualified TypeID)获取其byte[] .class文件定义，否则NoDefFound，系统级是找CLASSPATH；最少有隔离不同框架代码插件、reflect.Proxy 动态成员实现
invokedynamic=(lang.invoke 即旧dyn/mh)=你可以实现JS的 f.call(this,arg) 如调用被覆写的方法，对JRuby,Groovy,Jython很友好，轻量级反射如 MethodHandles.zero(int.class)()==0 以函数组织出脚本语法(利用unreflect优化)。
Lambda实现为this被metafactory转化为目标SAM interface代理的“动态脱糖”，其内"CallSite"调用点，建议用新动态this invoke指令实现（不过说实话咋实现和应用层有关吗.. 就是它等于匿名子类也仍不如Kt有格局啊
外提 static MethodType,VarHandle 如 lookup().findStaticGetter(System.class,"in",InputStream.class)。话说 List.of, Map.size,int[].length,Console 啥的，字段很少了...我的Java6丢了
「编程」语言=以祈使句无助词 语气词、不以感情滥造同义词、严格区分数据类型和相应命名与语法、条理范围明显 的人类语言；也存在简洁与啰嗦、易读与冷酷、通泛与刻板，有易改变(工程化:可扩展)、多态(同名不同义)特质。
中文编程=合适编程的中文子集以合适中文的语法排版+合适现代的i18n。
符号执行=不以「值」为目的的程序(树,栈..)变换，比如本来 (Op "+" 1 1)=2 ，但也可以 1+1="(1+1)" ，或 a*pow(n,2)=a<<n 、n+2*3=n+6

编程语言=由(顺序|情况|重复)形式化字串的规范+stdAPI
解析器=从字符流收集出嵌套、逗号列表、算符链-单项后缀 栈、能划分"",/**/123等词条区间 的工具
解释器=深先树重写(后序遍历)求值器+解析器+嵌套作用域，计算器和实机CPU也可称
提一句。如果你会 '1', "+3*2".split() 的计算器(等于UI打键的自动版)和命令行 echo 1 2; ls . 这种的，解释器就是把命令行“嵌套”化了，比如 if(Expr){Stmt;} ，Stmt=if|for...|Expr ，难点在于从前缀读取{}()到列表，很多人只会split 甚至找()开闭位置去substr，其实递归下降是不需要立刻知道闭括号}在哪，它读完内项列表确认尾部有} 就够了；此外+-*/的算符优先级与 .k (x,x1) [] 这单项后缀 受BNF冗杂的影响很多人不会写(正确做法逆波兰,用递归只1行)，最后先有值、语法规范再有虚拟机啥的，以及 Java,C 少数 int x; int x(){} 后缀确定语义(非Kt val/fun)、跳空白注释(加过滤流OK) 这些递归下降时较麻烦
如果已会，建议是 (a (b c)) 的语法 P=(word|(P))* 甚至 P=(word|'('P )~')' 而非 P1=word|(P1*) ; P=P1* （这么说挺傻，我再举） 1-2-3 的语法 P=num(-num)* 而非 P=num|(num-P) 即 P=num (-P)? ，即尽量少预判

REPL=读取并执行1语句，应是配合解析器读 从而可在之间换行；应需C-readline,node-repl,py-cmd 等stdin单字回应(tca VTIME,VMIN, win _getch)的行编辑，以支持按Tab补齐事件
算法=realloc数组,x:(xs/Nil)链表/双向,list KV表,hash桶KV表,DFS路径搜索,BFS可达搜索,Trie前缀搜索树-Radix字节前缀/AC失败转同前缀/KMP单子串AC=strstr=indexOf/编号K-V表,排序和二分查找 BST二分树,较子项最大/小堆树:平铺N叉树,Skip链表/malloc空闲链表,动态规划(可缓存递归),p-q关联集/带权重合并,贪心法与O(N)等复杂度,..
实用算法=不要过度区分解读函数值(带参代码块)、元编程简写设计、JS防抖和节流(debounce,throttle)=限调用取代或响应频率，冲突只留新/旧次参数
t-t0>dt: 保留旧次(无末次) setTimeout: 新次(防抖/独占时间片), 或dt内没调用过才调用(防抖留旧)
实现可把 eval,show 等操作放ASTNode外的对象Eval,Show里：用重载+覆写Node.visBy(Visitor模式)，方便操作间隔离
嵌套作用域=动态域=内层{}变量对外不可见。规范C支持覆盖for(i)for(i)无冲突。实现调用,let-vars-in语法
实现法有 eval(t.copy()+)、Map+Stack<Map> 、 Map<List ; List<Map

函数=涵盖几个量变化的量，由算式得出(函数式语言)；些许参数1个返回值的代码块，占局部存储区(子程序栈帧)，由计算过程指派调用结果(过程式)
函数值=闭包值，不止需C函数代码指针，如 (a=>()=> a) (1)。
求值序=收束表达式为值的时机。如调用里传名传表达式 by-name(Lazy) by-expr(inline) 仅首次求值,直接展开-宏(实际上都要调用方的变量闭包) 和 && || 的(惰性)短路计算；PHP不能 iff(a==1,echo A,echo B) 仅得A但老语言可以
词法作用域=支持闭包的动态域。一个变量有其运行期绑定"&Binding"而非“局部表”，如上i级函数j号局部量(含参数)、全局名key
闭包=内存对象。包住了上级局部量的代码块，其局部量=this变量。JS/Lua函数、Java匿名类实例 都相当于闭包
实现可全复制 t.copy ，或分配 kotlin.IntRef 等空间:指向栈上/保留栈量 (Lua同,op_closure getupval~close)
状态机=NFA->DFA 啦都是手动更新状态的(而非指令 pc++即iptr++) 有限状态号:单步转移 自动机，投喂1字可能前进1步直到末态ret。闭包+iptr 可以让子程序暂停在某一步，或者用TS的switch case123实现for(;;)等结构喽
(但JS无goto,if while跳转都得内switch)，或者用CPS面向调用-尾步骤编程。表达式内yield还要外提左变量如 if(1+yield 0)a; 变 v=1; st++;ret 0; case 2: if(v+_next)a ；for(;precond;tail)等还要展开

编程=以语言提供的基础数据类型和流控/定义结构，和平台+库API与事件，按所需信息量 组合出程序，实现目标
程序=数值结构与流控。数据值/变量暂存位和判断流程的文本、(语言虚拟机)二进制形式，通过暴露函数名等进行N到1链接
编译=把调用变量、重载(+-数值宽)等语义引用固定、转化掉括号和字串内插和new等顺序流程。生成紧凑文件，避免可静态项重复查找(解释器开销)
编译器=输入语言格式+前端解析器+前端填命名重载,跳转地址+中端优化+后端指令选择寄存器分配+目标虚拟机 或编译单元链接+ELF/PE等代码格式+实机GNU/MinGW Crt运行时,ld
多线程=并行=通过pthread等下层要求内核多CPU调度，会弄坏libc用了全局变量的函数。可利用Mutex(单入锁),Sem(等待计数),Atomic_incAndGet(乐观并发)等基元防止竞争修改出错。即便只有单核也能靠时间片抢占多线程，但只会更慢吧(指Python GIL)
Base64=Eqv<Str“A-Za-z0-9+/=”,Bytes> 3/4的字节存储效率，二进制位的把戏。 公倍数lcm(log2 64,log2 8)=lcm(6,3)=24 ，即(24/6=4)AZ:(3)Byte；简单说把Bytes=8位连起来再按6位分块对应到AZ(=Radix64)后，若末字符不够8位补1~2个'='(如6+2b"a"->"YQ==")；反时串联低6位。一般用预保留低(8%6=2)位 换给右byte 高2位，然后输出内几个6位的做法，可按4,8字节为一次操作。可不移掉2位若i%(8/2)==0,即尾部2字节2+16位凑整，否则留2位,尾== 会多余1字节
请勿滥用Base64，文本文件也可内嵌二进制，只要临时越过字符集编码。也有 %2 /2 (即>>1) 硬核toString(2)，当然也有1次2,3字符表的优化法。
Base64=64进制多字节。3/4字节表达效率，即串联8位字节并按6位(6=log2 64)分块解释从而避免乱码。把1字节视为6+2位，6位对应Radix64=AZaz09+/，2位移到右侧并再>>2；第3次正好凑满6位=1字；若n*8%6==2,4 则添上冗余尾缀 ==,= 。可一次操作4,8字节，解码拼合 6*5=32位；亦有 Base32/16/2,URL-Safe 等变体，base16 及其 4a:be:cc.. 的形式在各种通信和密码上常见
XML=EAV结构，tag attr=v child 和内文(纯文本节点们)构成的树结构，无child的tag不需斜杠如 <br/> ，而 <div/> 则是无效的，勿滥用XML容错而 &amp; amp,lt,gt等字符ID转义在早期PHP里用于避免用户注入JS脚本；XML比 JSON,YAML 仅易写「子项」概念
SQL注入=JS注入:XSS=由于把SQL语句、HTML排版模板当作字符串与用户输入拼接，导致用户文本变为代码的漏洞。旧时PHP等“预处理模板语言”(字符串语言)常见。任何注入的可能均是编程错误!
HTTP= Get,Post,Put,.. URL (参数)带 Header-Cookie存储,Body-ContentType 的文本协议，HTTP/2 SSL 性能提高，它还支持身份验证和 Multipart 上传 octect-stream 下载 keepalive 通知(短期版WebSocket)，只是SOAP等魔怔协议的时代人基本只用它传参
Server((req,res)=>).listen(8080)
Socket=套接字=收发线=主机间的字节流,fstream 可用 ss,nc,ip-r 指令调试
UNIX bind&listen accept:sendto/recvfrom..shutdown 客户则 connect
二进制= [Share/c/BPUcal]
Cookie=饼干屑=服务端存储表上的键，它指向的数据是可信、可限期、可无JS由HTTP(请求头内)设置的，可以保存用户名作登录凭证(饼干屑长随机,难暴力破解)，因它代表服务器曾主动为用户生成。
JWT=分布式只需共享公钥，各自靠私钥签名的可信、可限期数据(如用户UUID)。
UUID=分布式，带生成时间随机的唯一ID。ID 在无外引用时等同密码，是可信存储
公私钥=非对称密码=PKI体系=SSL证书、apk签名、HMAC等安全信任所依赖的公开验证方法，公钥可加密但仅私钥可解密，靠解密验证私钥身份。比如篡改文件hash清单 靠私钥才能验证
hash=散列函数=文件摘要 如md5,crc,sha ；摘要相等一定相同，HashMap里起到预过滤分组，好比大小超市的商品分类
URL= 协议://路径 或 相对路径 或 //同协议路径 ，路径一般含主机(Host)部分，DNS(域名->IP地址)中 example.org 被称为2级域名，1级是 .org,.com.cn (Java包名倒着来没错)，x.example.org 级深是子域名，网页不允许(CORS Allow-Origin,或提供lib.js)AJAX访问跨域名；但1主机可通过Host:请求头绑定多网站域名
URI= 协议:描述符 ，如P2P种子下载:文件hash
PJAX=SPA=单页应用地址栏编程 history.push/onpopstate location.hash#，如跨页播放器、浏览计时
PWA=激进Web应用，可以安装到桌面、发送通知/触控、利用ServiceWorker缓存HTTP响应来离线使用；此外还有 OpenGraph 扩展html>head 头图
SVG=矢量图=基于XML的填充描边几何、线路径(交并差)规范，如 svg viewBox=xywh ellipse cx,cy,rx,ry 。可用设计器或程序编写<animate>，其体量>HTML 类似Flash
Vec2=三角函数计算。向量可存储位速旋等需加乘、修改距离l/角度r 及与0~2pi弧度转化 的物理量 [点计算1]
三次贝兹=缓动平滑=贝塞尔曲线=4点 P0~P1 P2~P3 构成可由距离/向量 绘制的曲线，动画里固定 P0=0 P3=1 ，对 t=0~1 [x,y]=anim(p01(t),p23(t))(t) 就是3次方贝兹函数的图像
碰撞检测=取最近点所属的几何，检测。最近邻算法基于kD-tree 的多维距离特征预划分。
AI补图=waifu2x,javplayer 等像素平滑算法。颜色补间在放大和(线形遮盖黑边,水印..)使用，但它们不能保障锐度、高对比度的边缘；AI放大尤其对手绘有很好效果

这么看我4年学了个寂寞... 排除最开始入门1年就只会抄拼代码
以后更新就会以足量低频 的方式分组，可能不会太关注tg方面的更新了，偶尔有新东西就分享下。

h5shim norm.css BS JQ
context-menu callout
webkit tap highlight 即:active 整体bg

