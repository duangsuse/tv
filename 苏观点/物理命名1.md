# 不提代码谈谈编程、动态语言、编译原理

作为一个懂点编译器的爱好者，我也偶尔问自己，编程是什么。 我不是说有代码基的工程，也不是说“猿命贵”，而是你会欣赏哪样的代码、向哪里游荡

代码有很多种啊，定义 过程 描述、片段(函数)有没有主语 变量有多强类型、XML TOML YAML、数学的几何的向量一次算一堆的，可视化所见即所得的，还有描述产品和功能的纯粹的汉字

都是抽象程度不同的代码，只是很多人不把花括号大箭头 用成自己的母语，就像如今英语学科，它只是我们完成任务、挥之即去的工具，没有走心，但我还是要去问，属于我的那个答案该固定在哪里？

- 初学：编程是用英文理解，靠dnSpy修改既有程序的反编译结果，体验脚本效果
- 也是创建模板项目，排开UI设置点击，一周里在CSDN上搜索些即贴即用小功能加进去，反复打包安装、调试print 的机械化过程
- 删掉 this.mXX 的m不行，不用 System.out.print/sleep 做也不行，除了alert()都不知道、需try{}觉得很烦人，一个for(:)add觉得自己悟了、成功http觉得终于出息了。只明白要找剪贴板所需的变量和平台、偶想魔改别人的源码

可能你对运行环境的功能历史、为何要有之类都一窍不通，因为很酷，踏上“面向运气编程”的第一步。 如此平淡，但你终究触及了dev的圈子。

其实今天想想，我在算法上也没啥进步 ，主要是从不承认“工程”本质是做堆脚本，到保证既有功能、且永远只爱简明函数式而已。

以前会在卡线程的问题上烧脑(以为intrrupt后还能恢复,提前理解协程了hhh)，当然按部就班CtrlCV就大抵不关心这些了。 只是网上很难找到系统性的示例书籍，学校默认的教材也未必圈点，所以我发展的慢也未必落后

## 时间线

- 面向对象是以发送者给接受者发送参数消息为模式设计，过程式是以函数和流控、structs、运算和IO 实现程序

“X者向X者发送”这句乍一看废话文学，其实一些老师挺喜欢说，最重要的是JavaEE圈自己酷爱100行 class Actioner{} 实现30行 action() 的功能

函数式最机灵的算式(函数作)参数，OOP可完全没继承到，只是弄成了(含编译期)多态。像 Python3 就把这些继承的比Ruby好，易扩展低代码，所以科学界更喜欢；作为元编程爱好者我也会写@Processor代码生成，但Py,JS对Java这方面可真是降维打击。

语言骨子里繁复的傲慢，是Lombok这种东西消除不了的。好比明明Lom做的就是 java 级的模板化，却偏偏要像Kotlinc一样改 jvm 级的代码，好像汇编个aload_0;putstatic比Kt自己造IR更不得了一样。 Java和Qt就是娱乐圈的刘浩存和黄晓明，花瓶做作和油王装B还是能区别开的

函数式确实不适合弱算法多键值(且更配弱类型)，而Py就解决了构造=>执行2层函数亦难封装配置性的小隐晦。但往历史看，env表(Kt 1.6的with)比依赖注入(声明性赋值)优雅的多，可以说 __虽是贫瘠，却治未病__

再往前沿看，Vue CompositeAPI 以0class(变量引用)实现原本照class UI{}的建模，其实也是一种复古的现代美。 FP从来不比OOP差，只是愿意把它做通俗的人少，当然我没吹Vue能把它做好

- 是用所选语言的语法/数据结构 +目标平台API，顺常规的业务流程，组织能解决问题的程序

那段时间我开始从JVM转向脚本，写了PromiseJava(主要是列表处理,是我“无限重写”的起程碑)，也看了《Kotlin极简教程》，作者是阿里的P几?，还有阮的《ES6基础教程》

阮和张鑫旭这些人都是非常有见识和个性的JSer，玩过很多好玩的片段，不过人无完人，即便对他们的代码纸也最好加入自己的重构(比如张写过js版easing函数，10+项,复用0%..虽然都是早年)，毕竟不改无进步

- 是用与数据明显相呼应的程序，描述问题之间的关系，并处理转化从API拿到的数据

[Daniel Friedman](http://www.yinwang.org/blog-cn/2012/07/04/dan-friedman) 的书确实很巧，虽然我对Scheme数据类型不感冒(链表LIFO,不善行数据,但我最讨厌的是前缀符算式)，书90%内容也如轻舟过万山 (虽然我用20行也能描述出:P) (天哪，我居然一直在评判..虽然也没很严厉)

## 如今

- 是让人与算力、领域与领域融恰，以使有物理类型的信息肆意碰撞，解决眼下和未知、用户和同行、语法和蕴意的问题

两年前我开始用 var 首字母区分变量的用途含义，且在函数名里使用 To,By,If 等介词，少用getXX这类历史遗留写法，降低语句/算式等结构性差别，只注重语言参数化与连贯性。

__解决未知 叫设计与健壮，解决同行 叫复用和扩展，包含蕴意 就易用易维护。__  我从不明说这些，因为乏味的名词不能代表产出的进步

堆砌代码、搬弄术语太容易了。在“代码”上，很难做减法—— 没有一张频谱图，算出每堆def贡献了多少功能，没有一种排序法，标齐几句解释带来了多少顿悟，你以为多重构，但重写总能大变。只有对功能点-片段有先验，才知道属于哪的计算值得被怎样写，而不为了酷 一股脑地换风格，亦不束缚于专业

专业的人不少，但称职 就一定要从业吗？ 走了7年，从极客到业余开发者，到没人看的lib作者，最终我选择做软件工艺师，自诩的也好，反正我已圈定心中“编程”之限界。

我写的(多是)单字符命名对大家不友好，但我一眼就能瞄见一大流程里有何关键变量和API。省字数不是让人不明觉厉，相反，是为了压缩1个项目里非重点思路占用的理解难度。

毫不夸张的说，我利用数字和大小写的命名无视了当今流行 Code Style 甚至汇编、Win32/MFC 时期习俗(在函数式不罕见呦)，我就敢。毕竟，能被机器生成的排版都是莫得灵魂和语义的。

为了表达效率，再极端的进步也要开始做——要合规大不了改个语法树加个宏，详略得当才重要！ 有比这些都重要的：你为何选择某些技术和API。不删万恶之源，再多补丁都虚有其表。

实际上，恒定缩写表的单字符类型名，节约我起名的时间和心力，让我把眼力移到拆分函数上，一直决定性增多了软件功能点。 人的智慧很有限、业余时间很宝贵，一定要100%耗在核心逻辑上；不要觉得自己聪明了就可以既酷又易维护，那些无法预测的成本终会给你的下游带来麻烦！

## 碎碎念

关于领域。但知道你学的那些术语，本应属于更广阔、更具体的故事后， 才发现编译原理出尔反尔：明明只愿让人读懂机器，却又带来含糊的概念与少许历史遗留 。该学吗？到底是那些头疼的链接，把人引荐给更适合的地方

直到今天我才明白，我追求的技术所谓“质的飞跃”，都是在临摹70年以来各种IT文化和领域的老路——创造是从这些或对或错的碎片，从信息差和执着点，而非纯粹智商里得来的。

__短的时候你不把它当体统雕琢，写成mian()条了，就更成不了体统__

我不想当程序员，而想作为少用“黑话”，执笔所既想故事的创作者。 方便大众使用“算力”和流量的软件，只是我所追求方向的副产物。对副产物的贪婪，会让人无视挡在问题后的前路，也会让人忘记失败质疑与未加思索的差距

__程序员的输出，是宏大微眇代码里没有人名却层次分明的思想，是经验与哲学、工程和理论的协作，是构筑通识与方法论的领域。__ 这些藏在各语言和社区的思想接地气，但智慧却不输于任何领域，因为计算机说到底是人的用具；不制造问题的工具不聪明，却承担得起
