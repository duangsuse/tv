# 绝句底稿

Hi 我是动苏，绝句的设计者。 下面从常量到文件级，自底向上，讨论绝句的语法和代码生成-语义。

语法的所有细节不会都展开来讲，一些简写性质的设计，好似 f("?") 等价 f("?",1) 的默认参数，不必太注意。 暂只谈 ju=>java 必要有的临时数据、生成转换、预判。

要了解如何实现 `juec x.ju x.java` ，你要能理解数据集计算（如 Excel）的目的 而举例输入输出、 `eval "(+ 1 (* 2 3))"=7` 的步骤和“拆分”模式 -""内顶层的语法、再内的语法 分啥情况 =什么；只要能举例，读懂就只是时间问题，毕竟 __编译器是从文本=>“脱糖”后低级语言 的普通处理程序__

学习本文能帮助你更深刻、且简单的理解编程。 它不会谈太多编译原理(compiler theory)与优化、谈框架或“构建工具” “指针”等众议纷的内部细节，但所用技巧都会十分务实。

__对何时机、目标与领域，思想>途径>每一步，是绝句的核心思想__

如，开发社交app， “独有点/市场面” 思想、“数据共享-API和UI” 途径。“编程语言/框架/格式协议” 以及其用法每一步，最次要。

>但另一方面，绝句的恒、列、0控制流，更多编译期处理 的特性对现有编程语言很陌生，文章的受众也不只“知识分子”“高级爱好者”， __我尽量只对功能点的用法与树转化，画龙点睛__ ，力求给人山穷水尽右，也柳暗花明的描述

## 套娃

绝句的语言层次：言句段词构书 =__Expr Stmt Block Def Thing Pkg__

比如，`val x get()=1` 就叫『词』 Def ，`val x get() {return 1}` 也是，那么形式语法 =`val Name get"(" ")" (=Expr|Block)` ，|表示多可能性 *表重复。非大写的都是字面代码“关键词 运算符”、仅有出现顺序

>不熟悉？可先看[小科普](#科普)篇，做几个解释器再来

段=List<语句>，相当于{} 块。 它能被句所包含for(){}，不过绝句里『段』是特指函数级，有 `事 f=1 “即事 f() 为 “(换行+缩进)” 回1”` 简写或不写，写在 (事)为……其中 或逗句块(造于,其中,量,变 读|写) 的代码片段。

```
“那么排版就类似这样：”
物 嘴巴(名字：文) 为
  造于()，
    说("受造吧")；造于("名嘴")
  量 待写 读，抛下错("TODO")。
  事 说 =舌去说 其令为，"[$名字]$它"。
  其中，量 舌：舌风=毒舌

thing Mouth(name:Str) were
  made(): say("objMade() will"); made("wtf")
  val TODO get: throw Error("TODO")
  fun say=tou.say  itLets{"[$name]$it"}
  where:
    val tou: TouSty=uglyTou
```

```kotlin
class Mouth(name:String) {
  constructor() {println("init{} will"); this("wtf") }
  val TODO get()=throw Error("TODO")
  fun say()=run {
    val tou: TouSty=uglyTou
    tou.say().let{"[$name]$it"}
  }
}
```

在西语上读着可能有点黏糊，但写中文时，绝句松散的语法会带来很大红利，这是一小段例子包含不了的。 中文乃至CJK书体里，1字可以与许多西方书体的1词 同样涵义（因此英文弹幕站 影视字幕 不会火）

另外一个细节，固定 val/fun前缀『词』级定义是利于速览代码的。(){} 初看非常规整，但完整阅读其实是碍眼的；尽管() 的有无不齐， __其位置上却更符合生活常识，这就是绝句对排版大布局的抉择__

我是希望绝句能成为一门能独当一面的语言，有创新，但创得不刻意、只为简洁创新。

__绝句里过程式有其职责、函数式有其地位，不高也不低__ ，二者不容却暗暗相连。  绝句里许多词都起到关联的作用： `事是、量是、带号，[是x i]、判是 ，事物其中 对何<N>(其中N：可序)`

绝句曾对同流程多造词，如 `constructor():this 和 init{}` 曾是保留 `造于()：我() 和 初，` 的。现在 `made():made()  fun objMade` ，类同的还有 `main(many args:Str), "Hello %" %arg("Mike"), ManyItem(=Collection)` 取代 varargs(不定长)和*符号

## 对编程

函数式的问题是，简洁却无法简单直白。 __只有数学、缺乏符号语文和感性描述的世界当然是零散的__，绝句不纯但够定义式，移植 Haskell,Coffee 里的用法还是方便的。

呃，比如匿名递归 Y Combinator “不动点性 组合子”Yf=f(Yf): `Y=(\c.(c c)) (\c.(c c))` 这个，死递归。 懒化 f(c(c))= `f(x=> c(c)(x))` 得 `Y=f=> (c=>c(c) ) (c=>f(x=> c(c)(x)) )` ， `Y(f=>x=> x?f(x-1)+1:0 )(9)==9` （约1步就和 `Y=\f. (\x. f (xx))(\x. f (xx))` 等同

链表/组合子/“高级类型系统” “推导 演算 广义”问题 绝句是不便去支持的。不过像单字符名无确定义，我有个[物理命名法](#科普1)

补句，`(f=>f(f))` 仅向f提供自身，其递归时也要 f(f,..) 这样。最好的做法是，给f提供，代理到f1= 变量的可() 对象，运行前必填 f1=f。 __这不实用了很多？（虽然也没多少蟹蟹..__ 可以试试拿JS实现尾递归：f()=注册后返回；while里新参数再调原函

>坦诚一句。我可以在这教 [Lambda 演算](https://lambdacalc.io/)的那些词(a b eta 啥子) 和其typeChk一法，但没有任何意义：lam 的重要概念连 VBA,易 这样纯靠API硬撑的语言都有， lam 的核心（词法域和bind:半满参调用）Ruby 乃至 JS,Py,Lua 里用的更严谨。正常人根本不会搞 g=\x.fx; g=f 或匿名递归,Peano,"链表"数  这类迷之规则，卖菜都知道 还需要专人发明？

Kotlin 的绝大部分关键词背后的功能，绝句没有造在语法上就实现了；Kotlin 几乎所有概念性API，绝句仅加了1/2的词汇。

编译的一些玩法，对它们是慢慢发觉的，但绝句可没地浪费时间在“代码工程”， __丝丝缕缕都在为处理找用法，多1个都更值得。__

- 它的时间浪费在“光说不做”里、均摊在“胸有成竹”上，思想>步骤 ，因为中文，善于如此、必须如此。
- 如果这个虚岁5千年的文字不行，不是它不够， 是你的问题。
- 如果文科低人一等，不是聪明定输赢，而是绝句放下眼里的赢，获得生长的自由、浪漫的真实。

绝句抄了 [JetBrains](kotlinlang.org) 的这个语言，但越来越不完全。两年前「为|逗句 你 记法」就不是自 Kotlin 的既有语法改的（中文排版所必须）， __后来，绝句不再刻意复现 Kotlin 对编程和JVM的视角、执迷对初读者自然，它对编程、代码与如何运行，自己有视角。__

>应该说，拿预处理器/乃至改编译器语法 造“汉语编程语言”并不稀奇。把缩排转{}、顺带汉化Kt,Lua关键词、标准库名词不太难，甚至有人学易语言(=VB..)的机翻，问题是，编辑起来方便吗？迁移容易吗？

若你连洋文都没学好，“大概”不是正经程序员； __若你已经习惯那些语言，中文名词、{}或缩排 浪费时间。甚至不如给软件加功能简单。__

>绝句敢搬出不同的文体，是因为它所认同的世代里，即便用中文这种直白精炼的载体，也不会让编程语言自身的死板性暴露无遗。 美的编程范式、多多益善的功能、直而统一的中文，才配得上『编程语言』而非『字面替换』的名号，它不是“中文编程”而是人言。讲人话。

如果你对编译原理有所了解，就会发现绝句的每个词、每个语序都在照映“更低层”的运行期结构：

+ 量、变 里"量"既是量取、计算，也是保存结果值 ；`量(名)(：类型)?(=言)?` 许多时候是可内联的，和 `变(类型)(名)(初 言)?` 根本不同
+ 集合、列表 =`些许项 ManyItem<T>, 行 Ln<T>, 列 LnBy<T> 以及 Map<in K, out V> =for<set K get V> Map` （实际K也回作返回值所以不止set） 还有 `事 main(些许的args：文)、 main(arg("0",建组("1.txt")))`
+ 『人称』简写了许多无聊命名： `事 原(：数)=此数 ； 物 主 页面 = 物 主页面：页面  ； 量 a 写，a=它+1。  尝试，。接迎错，你去说“printStack”。 ； 物A物事B 事f=我“B”+你“A, =我[^1]”`
+ `重复若，。 重复，。若。`  里"重复"实质就是 loop: 标签，没有“更自然”的 do while(cond) 和 for(init;cond;tail) 循环，甚至没 for(i in 0..2)
+ `尝试，。接迎` 里"接迎"暗示了调用栈向上增长和 landingpad 链表, longjmp() 的存在
+ `重复回()` 照映出尾递归(tailrec)变跳回开头的本质，函1<函续<数>> +自动传尾操作 而非 suspend ()->Int 消减了许多“基元”概念和库

对中文的善用：

+ 类物例，1物属于1亲物、N大类，能量取N例 或1单例，造于几个值。「事」比 函数func、流程proc、子程序subroutine 乃至 `interface class Singleton`(=class thing insta) 那些直白太多
+ 物事(inner class)、类例(class interface-隐转)、储例况标(data enum sealed annotation)、公私族组(public private protected internal/pkg-protected =same same-0 same-type same-pkg )
+ 物|事 为 were 和可定性(既可未终=impl impl? impl?? impl! = override open abstract final) 与段级.逗句块不同，代表 OOP.子类型多态
+ 书、引、引单(不止 `import static`) 定义了易于使用的全局符号表
+ 没有控制流。 只有若判[你]句，还能 判属于、判存于、判是、判[无参]。 若判没否则 ，才不能作表达式

「为」和逗句块、人称文法、记法，这些并不是被硬生生加在语言里的。它们编织交错成了语言的身体，而语言也是跨文化(i10n)的

自己的，未必需标新立异 “领域独一 愈难愈专”，但肯定是终日为伴、知根知底。

## 范式

>JavaScript 并不是绝句编译器所需的语言，中文才是。

绝句还为算式量大的情况（如物理计算、OpenGL着色器），提供了 `事[公式单字参]=、 量，a 1；b 2。变数，a 1；b 2。 变任，a；b。` “仅按首次赋值确认类型”  、`事=……其中 、“量纲类型”  对何<>针=数「它>0」、俩量<数> (Vec2)`，

`定义域“令 令为 其令为” 值域<数>、对何<数值>模板` 的便利用法。  `恒物 可变量、值最新、懒、同一、其一(与跨平台、试)、代者(恒事 受继承)`  也能实现惊艳的0开销简写-却不局限于编译期可用， 行<可变量<数>> 当然可以

从对 OOP 的理解来看，绝句认为 __“对象”是强类型、分段执行的函数值“闭包”__

『我this』只是其内名字 可直接用的参数0，(仅需编译期)作用域策略。  __物与事的最小构造，都是“函数签名”。__ 实际上『函续』也完全是把事+执行指针 物化 为内存对象/可序列化

只是 物可以继承修饰、多实例。比提供不同函数值，导致API行为差异-“更自然”。 OOP-FP 范式本为一体，能严谨也可富于表现，才能写好软件内的所有组件

绝句所用并非 Smalltalk 或 Java 20年前的 OOPs ，而是『名动词面向对象』。可以说这只是一堆重命名（包括代词：你 它），但对 `函、函我(事量扩充)、对何<>` 的升级也是绝句范式的一部分。

范式(paradigm) 不是 __对象OOP,函编FP,表述式PP,无结构asm__  里单调的1个，更不是“一个茴字有4种写法”的所谓4GL、只能查询的描述式。而是它们所有，各不相干却默契如一，融合成有烟火气、没重复却易读懂的东西。 __是所有，却看不见摸不着，空气般自然。__

## 对数学

>不必认为绝句是天才或傻缺设计的语言，它只是有科学素养的普通人，对程序的主观认知

我的数学从初中不及格—如同90%的程序员所设计的代码，游走在将要不知自己在写啥的边缘却 "It works!"

计算机“科学”是工程学科、 __永远有探索目的、易于复现调整，但不意味着它不究原理、不思考、爱乱凑数。__

人与人的差距>人与猴子的差距 ，有过“专业人士”身份的人都会懂这个：无论历史何时 __流行的永远是一小部分，它不是全貌__ ，而不流行 也未必皆“沧海遗珠”，各有各的点，我觉得这是从业者都应意识到的。

跟随或引领或默记，每个人不同时期答案有不同，但肯定有尝试 触碰，甚至多元化的解读。无人生而知之 菜不是原罪，无法坦诚了解才有错。 作为人，了解对方性格才能缓和好自己。 了解领域概况，也是对其尊重。

__计算机、电子、物理、数控学科，__ 在手心/盒内/监控..、各种“微电脑”用具乃至变声器 电音、高塔 太空 深空电镜 CT、在工厂 俯瞰镜头…… 为无数人提供几十年都在迭代、市场下沉(便宜流行)的现代生活，越来越容易的4K画质低延迟、扫码附近生活化，这些 __技术、知识与研究、发明，属于诞生与孕育它们的领域-交叉。__

对分子物理的学习，不能取代在医学药学的涉猎乃至工作训练，甚至无法有捷径帮助 __；而若身处交叉领域，也没有谁的尽头/根源/至高是谁一说，这就是数学与任何工科的关系。__

任何一个有人生观的人，都不会觉得「理工文美娱做」有高下分别， __因为少一个你都不完整。__ 以资历评价无关领域，是种民科行为； 什么都仰仗天赐和一通百通，是对知识的怯弱。 盲目的道听途说和因果信仰，恰恰是反科学的。外国人数学烂，但前沿 首创却属于他们，为何呢？

>我想这节本就有更高的议题，数学迷信其实是切入点。

你的高等教育，比英美大学内卷；可是你的诺奖 哪怕发明专利，赛不过小日本。陈述句。以至于消费者偏爱进口。

怪我们自己喽？ 只能怪拜金“合群”让爱好者不发现并自由主导他的人生和设计、怪教研照本宣科，狭见本本上扭来扭去的符号，无法激发教条计算外的智慧。 幸好在今天有改善

教育的目的是为国培育人才、或资源竞争，无论孰轻孰重大家都是极重视，且认可经历与知识必要性的。 只是该有哪些知识、何种写法练法？ 此是 __二者间均衡的点，中国一直能体现梯度(第一梯队,985,211,.)__

>..因为他们那数学不是“不学立掉100%”被神化、歪曲片面的 智商“利器”，而是 Desmos/GeoAlgebra/GeoSketchpad, Matlab 拿来探索和建模世界的专业工具、“娱乐项目” __。有时讲的越多所获越少，大音希声__


无关抽象或实用，这个过程其实“真理和问题”是放在第二位。只分档次去看的，那么我们就忽视了问题间联系与语文表达上的“微小”问题， 因为你是在把问题当作甄别“算术工具”人  理解和算力的东西，在死用。 外国Wikipedia 和百度百科功能全同的公式，你能看到教研，是没有进步与抛弃的。但我一点不意外 没差的。 __它不是死学活用的问题，它是“卖唱与艺术”的差异，__ 你很难不给“纯爱好”的东西找正经理由而去积极投身

就像，如果你把人理解为计费机械手臂， 就失去了他能给你一些正面情绪的，作为人的独特点。 对知识同样，会失去所有触类旁通规律调整的可能 ；一个领域的现在，是它过去流行 叠加的结果

在中国数学被浪漫化、或成为噱头和苦笑，其实就与它在人心的用途是匹配的。 数学是卷王 1point 刷千人 的战场，而不是理学的另一面-设计学 。气象模型、手写识别 这些也是数学，却未必高难“数学”。数学题可以刷，但你不愿哪怕从简单开始，拥有设计者的视角。 __每个知识点都是“抽象”独立的、数学和语文是“对立的”催命鬼、世界由9门功课组成，并不是因为真理如此__ ，而是人们的出产，必然受其观念影响。

“应用”活了也未必让知识互相联系、“推导”出更多讲法了。同一个逻辑问题：

- 跳伞员要降落在A、B两岛之一，A岛的居民只讲真话、B岛只讲反话， 他提了一个是否问题就知道自己在哪。他问了什么呢？
- 有AB二岛，A岛恒真 B岛恒假，若你降于其一，以是否问题区分。
- A=p(A岛), B=not p(B岛)； 求p(x)=? 使二者不同
- AB是非此即彼的(相对另一个有意义)，因此 B=p(A岛), A=not p(B岛) 交换也成立

这些讨巧未必算数学，但你会发现各种的“问题”都和它一样，有“超纲”的做法。 纲其实是善意，但毕竟应试选拔教育思想下， __“提升 补充”很值钱，知识却不值，这叫市场选择、人心所向。__ 成功、“分数”、钱并不是评价行为的唯一考量。流行的永远是一小部分。 如果说中国需要『国产操作系统』『自主CPU』『红芯浏览器』，在这些词被提出前，它的实意就被定向培养、金钱和流量至上的心，杀死了。真正的国产系统(如Kirin,Deepin)，不咋在乎国产的高帽子。

你儿时梦想是科学家、研究员还是太空人？ 如今哪怕做业余科学/科普家的胆量，存在吗？

大师的心永远仍是学徒。建议大家去B站看看罗翔的知识论

说回来。即便是在本领域，“多元化”的参与者，小孩Scratch和“不入流”易语言，都能写出他独一无二的设计。尽管许多在皆为利往、尽管好的作品不一定挣钱， __各色新人会带来新灵感、新的做法 方向与死角，这也是绝句的一个初衷__ ，不是争高下深浅，是扩面积 填色彩 ，如果只有金色，我会很失望的。

__数学在编程从未重要，更不像科幻电影和公众风评里，“所有学科的基础”。__ 数学不是门理学(=科学)，尽管一些表示法(1+1这些) 直观验证、符号有“约定俗成”律法， “高等”的一切概念是从哪来的？几何关系式哪来的？人凭空想出来的。

其思想和文本，无法如物理 轻松验证与复现、换掉，偶尔能造出 "Not true or false, it's null" 的教条

同时被俩人发明的微积分(线-细分采样) 或许有意义，__但数学在“物理意义”上扩张的东西太多了。__ 傅里叶频谱、数组和2D数组(比"线性"矩阵泛)、统计、恒等变形 尽管广为流传，都不是数学首发或独创的概念。 __思想是不独立于语言而存在的__，如果说程序=思维=数学 ，可以说是空中楼阁，忽略了根源的美。

如果说数学是语言是工具，它也只能与各家编程语言并立：因为单靠数学贫瘠的“基础”表现力、百家争鸣每一片面的百年揉杂；它每演算机器不需写步骤、它每讲解对机器听不懂。 计算机是自动化工具，能解决有实意且严谨到死板的数学问题，不存在草稿纸和用完即焚不打磨，但不只会做算术！

数学家聪明，但不会给你绝句，哪怕你假设他啥都懂或能“启发未来”。  你爱国，但没当志愿或兵。

如果只知用文字游戏，翻译照搬改名，就别做学问和设计。 那不是在求真上的努力，是在知识生意上的。

## JSON到言

### 言常

常量= JSON+Java 1L,1.0F +ES6 \` \` 变 '' 。绝句的恒事使得 '\u0000' 不必仅用于表示单字符，也能包含跨行文本-自动移除前空白；这个方法在 sh 脚本里执行命令-`'dir ${"."}'` 是对『语义单引号』的调用

`"${""}"` 应该是可以， ““”” ‘“”’ 即 `/*/*Kotlin*/*/` 也该可以。 `名=[_$\p{Letter}][_$\p{Letter}\p{Digit}]*|『.*』`

"${}" 内插表达式其实并不是常量，但解析的目的只为语义。只要能生成对应代码，这些归类认真你就输了。

### 言单

是言常和 的[] 去<>() 构成的访问链，需要注意 (言常|言单)去(调用) 只是给调用指定『我』以外的主语

言单= (名|言常) (调用| 的(名)|去(名 调用))*
调用=("<"类型、 ">")? ("(" (名=)言、  ")")?

"=" 其实是言的一部分，作为内部算符被检查(1=2, a=b=1 是可读的 但要报错) 。另外绝句没有 *(即...spread运算符)，只有 arg(1, 键组(2,3),4) 组拼接

### 言

优先级，+大 *小而先算。 逆波兰算符重排的递归版（Lua同款），内层遇 `"+* +-"` “+>*撑破” 才去算+- 级的左2项成1项

`mapOf(1to a, 2to b)` 都是分的开的， 建表(a到b、c到d) 里 a到b 也是个名字啊？

```
例 某 UI 为
  变任，A；B。
  量 布局=竖，
    横，按钮()为A；按钮()为B 。
  事 初 为
    A被点，说("A")。
    B被长按，说("B")。

对何<T>恒事 T.「为」(它：可变量<T>)=令，它的值=我。
```

这里也体现「记法」对绝句的重要性

语法读取的第一个难点， 即便 x() 知道首项是(名) 也对其分词，所得xo入队；每次优先出队、校验左部的xo 空才真读取。

>另一个大概要看半本书才触到，先插播点语义上的

## 函

绝句有「事」作值的函数类型(0~8参)：

```
“Runnable 和 FnPipe<T>”
函做
函新<T>
“函n 有n个参数”
函0<R>
函1<T1,R>
“函我n 有n个参数 1个主语”
函我0<T,R> “与 函2<T,R> 互换”
函我1<T,T1,R>

像这样用：

数::去文 “函1<数、文>  函我0<数、文>”
函0<文>，""。 函0<文>「""」去受调用()
函1<数> “void 函数”
```

函做是 函0”无<>“ 的别名，省略的型参视作『空(Unit,void)』

## forEach 的故事

还有一点就是绝句的 break continue ，软构词：停下略过。 绝句不是很重视“带标签的”控制流，都是 停下[^0]=break 等层号

```
重复若真，
  重复若真， “许多“内外循环”的内层都应作函数..”
    若真，停下[^1]。否则，停下[^0]。

Y=true
_1:while(Y)
while(Y) if(Y)break _1; else break
```

就是自动加标签而已。但咱知道绝句没有 for ，只留 恒事 看(：函看<T>) 。几乎可以说，绝句只为自举（自编译）“语言完整性”而保留重复若句、尝试接迎句

在 建组(1)去看 的「控制流内联」里，其实 `略过[^n] =回[^2n+0]；停下[^n] =回[^2n+1] 。` 类似有 `物 A 事 B.f =你是 我[^1]作A`

```
a去看，
  “回[^2] 是到这里”
  a去看，停下[^1] “=回[^3]”。
  “回[^1] 只是到这里”

非常隐晦，因为每“看” 都能跳到 for{} 的首和末。写这样：

a:for(x1 in a) {
  b:for(x2 in b) {//continue 或回[^0] 到此
    f(x1,x2)//^在此事里
  }
  f1()//break 或回[^1] 末
}
```

相当绕！降低for,while的权重、完全依赖「令 看」类块函数是绝句的重要设计之一。幸好绝句不必处理 `x.takeIf{true}?.let{return it}` 这种默认不 return@let 的情况（若你x是你“真”，回你。），也禁止乱套娃 令，回[^]。..

但，处理方法也很粗暴…… [^n] 引入一个栈，  a去看，f(它)。 生成f 前会引入 [1,0] 俩回[^]的位置，对应  重复若i<长，f(我[i])。 的 break,continue

顺便一提，为了方便「重复」里 回[^0] 回[^1] 和这个是共用的。恒「事」必须兼容回[^n] 地址才不能直接内联…… 所以 回 和 回[^0] 是不同的，前者才会无视外层「看」「重复」

唉算了，考虑  令， 若某，回[^0]。 再计算() 能浅嵌套，用 while(true){fn; break} 和「表达式外提」翻译局部跳转。

重复若真，f()；f1()。 里 f的跳转依旧基于 break ，f1 要跳转得另建一层 _0:while(true){break} ，回[^0] 回[^1] 绑定到另 break continue ，^2^3 和f()里的^0^1 是同一个

### 实现

回[] 栈的项只包含 name:while() 句，若^号 2i+0=continue, 2i+1=break ；停下略过也是基于[i]。给 while句默认(name= i!=0? at_i)。 除非重复若句内 首f() ，要在 while(true){f; break} 的新绑定跳转并将 f() 外提作变量

这样设计其实会导致  令，略过[^0]。 占编号却报错，但足够简单；恒事在化简后也如此内联。  绝句代码生成是分层下降的，这层面不需处理break等的跳转回填也没有IR-SSA基本块(BB)

+ 停下略过=跳转(“校验 设其标签”i、"break")
+ 重复句=标记outr、[^]栈
+ `f()= outr&&cnt==0? f.生成() : 绑跳转( while(), f.生成)` ；前置、表达式外提，保存其引用方名：Type
+ 回= 若带[^i]，校验 栈[n-1 -i] 的返回值类型 非空，赋值(名、式); break

相较之下「重复回」 就比较简单，整个函数体被加在for(;;){break} 里面 参=变，重复回：参=旧量、赋值， continue

绝句『你』『我』 [^n]也是栈形式，如果有引用才保留"旧我_n"

科普下回填(jmp backfill)：for(){break; fn()} 时不知道'}' 是在哪，因此for生成完后，要把break跳转都填到当前 opPtr；continue else{} 和switch里也一样，但 throw return 都是调用栈（运行期数据-地址）指明的

而 f(a,b)=a+b*2 其实译为bash式的 f=$0+$1*2 ，在 JVM 求值栈 深先树遍历就行：`$0, $1,2, imul, iadd` ，只有 && || ?: 要生成 if 不完整求值。 o.xx, o.fn() 和this变量 乃至 隐式转换,finally,static{}这些 就像自动生成对函数的调用 根本没啥。

常量池、jMethodID 和 ACC_PUBLIC 的二进制读写就是扫描、与datObj对齐下的事了，类型上 f(int a,long b) 都是编译期可知量，有 int f1(int); 那 f1(b) ok？错。 f1(a) 就可以，只用问 (int可为“typeof b=”long) 就知道有无类型错误

那么类型推导(infer)呢？ `fun<T> Box<T>.let(f:(T)->R)=f(this)  于 Box(1).let{"$it"} 。T=Int ，f:(Int)->(R=Str)` 各处并集统一 ，那么整个再检查遍就知道ok 与否了。`<T>` 其实是附着在 Def 上的变量，各位置取值归一。

没错，Java 有50+ 关键词，数不清的运算符，但这些东西 都是堆砌。设计到的只有10% 。int long 这些的存在只是为分 iadd ladd 、添加 Long.valueOf 等隐装箱(转换)， interface abstract 都是给JVM标记分 invoke-virtual 或什么，case break, throws 只是为让跳转目标看着更自然些 就采取反人类设计

如果你 new 下就得catch(OOM)，递归要捉 stackOOM，从 stdin read 就要捉 ioe --我不知道 IOException 的“特有”成员谁用到过至于不叫err或ex。 程序员、编译器、用户，谁有问题？ 编程语言的设计者脑子有问题。
运行时错误，框架不懂弹个窗handle 就轮不到语言狗拿耗子。错误解决越早损失越小，揪着这个大做文章？

## 科普

什么是编程语言？确切来说缺少 IDE、Web文档(Logo示例,手册,API文档生成)、社区支持(教程,Maven pip gem npm 包)、逼格与梗（比如秃头 “最好” 机翻 文言 JS弱类型隐转）的语言都不完整

而 C++ stl(std::), VCredist, glibc (stdio.h printf都不是os内核会编写的), JRE, .NET, kotlin-stdlib-jre8 这些“标准库”，也是语言的一些特征（然绝句标准库80%内联到目标语言的，鹅）

其实手写许多编辑器(VSC monaco,CodeMirror-textmate)的高亮规则不难，不少人也只需要看个高亮

__最最基本的语言工具是执行它的途径，编译或解释器。__ 编译比解释快、C又比Java这些快、gcc -O3 比 -O0 快；numpy,OpenGL比C快

这么说就足够

>文章的目的不是让所有人理解编译原理，但作为普及，来讲 `"(+ 1 (* 2 3))"` 是怎么 =7 的。 然后会设计1迷你"Lisp"编程语言和 1"箭头图"描述语言

文首问过 "" 里顶层、再里1层的语法有何模式， + - 1 2 这些都是项(运算符:变量 和常量)，括号也是 但包着多项 ，eval(项)=值 ；那其实 typeChk、reformat 这些操作也一样是给每项，基于其下级 定义1结果。除了 f(x=1) 这些项要先搞作用域

三种情况 `n, a+b, (f args)` 定义求值--__就能执行所有可能被写出的括号表达式！__ 其实对所谓“顶层”也奏效，它的(读取和求值)规则和 (* 2 3) 的并无不同，也能被更大算式包裹、引用。

```js
/*
Top=SExp*
SExp= Num | Op | ("(" Top ")") */
```

若基于[求值栈](#言)，还能看计算过程。 当然不是说 Node 树就不能带过程，tvr(tree-eval-writeRes) 可以遍历每个单步的整体树，但绝句没必要用。

tvr "t" 是啥？比如字面量 `LitNode(1)` 吧，但其实它只是方便深先树重写， LitNode 或 Integer 都是"隐晦if判断"咋求值/生成代码 而已。

绝句在JS 采用了 `{For:e=>e.cond, Lit:e=>parseInt(e.s) }` 这种方法赋予语义，而解析器框架 输入流 `s(1)='X'`，同时兼容同时定义AST的显示 `s.show(s=> s('X'))` 。

绝句语言使用统一树 U-AST 完成多编程语言的翻译、 FnPipe 去做名词翻译等中间处理。它不是单次遍历单向、没有拆出分词-代码格式化流程 却要支持高亮编辑器，这是独特之处。

### dot图
### JS-Lisp
### 编译惯用

>全文不换行的，意味着如果你不感兴趣就别多费时间看

在 OOP 里 `Eval:Visitor<Int>{fn see(:LitNode)}` 而不直接 `LitNode{override int eval()}` 更模块化：让eval操作而非Node子类多态判 instanceof "方法版本,派发"。在 FP 对应的 Final Tagless 则把 Lit 视为 `((Int)->R)->R 再 eval:(Int)->Int,.` 实现(操作和数据case,R=Int或Str)双向扩展，猜猜 Lit(n)是这 Op(a,b)又应如何？ `eval_Lit:(Int)-> ()->R` 调Lit时无需隐式传参个 `(Int)->R`。解析[组合子](#对编程) 同理

作用域上，除了 `eval(e."{}内代码",t.copy())` 全复制、虚表链式查询，还可以在进{} 前先检查冲突、保留名-旧值，}后恢复。 解析出 name 是 第i参(局部)、外j层i参、叫k的全局量称『词法作用域han(lexical scope)』

若在进{} 后冲突(而非 Lisp/Scheme 的 `(let-in [k 0] (+ k 1))` 绑定)，有可能只是给 k 指向的[局部(栈上)位置](#如可变量) 重赋值，却因为你没正确理解 `f(“参[0] x”=1)` 而有误，而(返回局部func)也仅含代码指针，别直接用『动态作用域』！

```kt
sealed class Exp {
  data class Lit(val n: Int): Exp()
  data class AddMul(val op: Char, val l: Exp, val r: Exp): Exp()
  fun eval() = when (this) {
    is Lit -> n
    is AddMul -> when (op) { //=在俩data 里 override fun eval()
      '+' -> l.eval() + r.eval()
      '*' -> l.eval() * r.eval()
      else -> throw Error()
    }
    /* when-is没有必要加else，因为 sealed class"密封类" 只在其 {} 内有新子类*/
  }
}
fun main()=print( Exp.Lit(233).eval() )

interface ExpVisitor<out R> {
  fun see(e:Exp.Lit):R
  fun see(e:Exp.AddMul):R
  //添加 fun Lit.seen(v:ExpVisitor<R>)=v.see(this)
}
```

## 科普1

>物理命名法把类型(单字母)放前面，但和Win32的“匈牙利命名法” 完全不同，“类型”是基于用途而非 bool,int 这些机械检查而定

## 「列」的故事

恒(constexpr)和列(co-routine,JS function* yield)是绝句两大极难的特性。 句依靠它把 `a去滤，它<2。去看为「+1」去行` 变为 `buf=[]; for()if()buf.push` ，避免任何临时数据

列甚至实现了 `试，抛下错("")。去取否(1)` 的内联。同时往  `尝试，成()。接迎错，败()。` 两边加代码(取否就是在 败() 加，默认啥不干)

首先说列基于的断续函数，它是接受『程续(continuation)』的函。 a() 调 b(); c() ，就串成 b再c再a 。你别等待我，让我回调你。 编译器会给断续函数里对断续的调用，串起来（意味着调用栈顶的函数要能临时撤下来-再恢复 即协程）

非断续函只能提供 函续<R>-来执行-目前不支持throw。显然这种“事件注册”或回调 不会阻塞，但和序列生成何干？ Py,JS 里 yield 1; 就是对断续的调用。

列生(0)，交(它+1)。 可获得1个无尽上升的序列，列.交() 就是断续函数，而这段完成，就是序列结尾， a+b, onEnd 会有用。

JS 里 Generator 对象有 next(yield_v); throw(ex); return(v) ，尽管列不是双向交换的“协程”，也可设想，交() 只是简单保留了首参，next(v) 时再交出v-复苏程序，返回首参

在CS（计算机科学）上这称为不平等、单参数协程，有上下级(yield-next 而非两个函数互相调)，更方便理解，但 Kotlin 选择了更基本的编译期、多动词(yieldAll)函数协程，更方便优化

绝句列上 去看、去行、去文 这些都是遍历性的，看为、滤出 都是另一个列

```
”物 列 为..“
恒物事 看为(f：函<A、B>)：列<B> 为
  断续的事 交(值：A)=你去交(f(值))
```

从 (0~2)去看，f。 f尾操作的角度，函数内联就能实现0开销流处理，通过「控制流内联」也能做 取前(5) 这样的操作，但它是不能暴露 onNext(item) 这样的列生成API 的-协程就能。 JS 里你能让主线程滤出鼠标事件「秒数是偶数」吗？做的到。

```
断续的事 f ”函1<函续<数>>“ 为
 f1() ”f作函续，自动被交给了f1！“；f2()；回1
```

一般把 f 里的「重复若」、交()+1 等状态机化就很不易了，但目的其实就是 f() 自己存包“函续”，其局部变量和执行指针，交给 f1(函续), f2(函续) ，等它们回时复苏自己。 f1() 的实际返回值是什么？ 函续.已睡 、函续.已算

当然，f() 在 f1() 后是不需继续留在调用栈的，「已回」代表 f1 已给程续填好返回值，所以无需保存闭包自睡。 否则是 给调度器+1任务，f 可能从调用栈撤下，要保留局部信息。


花开两朵，各表一枝。 如果我们能在编译期确定函续的代码呢？  列生(0)，交(它+1)。去看为，它+1。 里首个『交』 只是赋值它，好比 for(i=0;;)i=i+1

第二层「物事」交 for(i=0;;)i=(i+1+1)  ，去文 去行 带号 这样的自然就可以了

带号后才可以用 取前「次<2」 这样：

```
恒物事 取前(：命题<T>)：列<T> 为
  私下的变真假 q
  断续的事 交(值：T) 为
    若q，没了()。 若此命题(值)，你去交(值)。否则，q=真。

尽管要靠编译优化break，也足够方便了；和「看」的内联相似，恒物量变局部， 你去交() 给内联进去就行

变真假 q=假
变数 x=0
重复若真，
  若q，停下。 若此命题(x)，
    x=x+1
    说(x)
  否则，q=真。
```

## 绝句「恒」

恒(eval)，这一个字就消除了 `inline,const,by,reified,expect-actual C++ &ref,template,constexpr,decltype` 等数不清的词和“元编程”概念、拆掉了编译死板和运行的鸿沟。

原来它在绝句设计稿中只是若有若无的“摸不透”成分，现在它可能是绝句语义里最重要的成分，try-catch简写、多平台、模式匹配解构 上都有它的影子

- 绝句编译期就知道+-*/ 等许多计算和所有控制流的语义（不止知代码生成），它可以及早执行数组排序这样的事 __，只要参数都是常量__ ，或者保存(表达式)恒组
- 「恒」给只能生成代码的语法，在编译期求值的机会；恒组能做循环展开，含可变量<T> 的行则可在编译期乱序几个局部量
- 「恒」来源于字面量、恒物事 恒量，“恒”最终(于非恒处)调用结果必实现『语义留字面』以 `建组()` 等嵌套(表达式)调用序列化。

```
类例 语义解构 俩项<任、任> 为 恒事 解(：我、：组<可变量<值>>) 为
  此组[0]的值=此我的首；此组[1]的值=此我的次

类例 语义解构 表<K、V> 为 恒事 解(：我、：表<K、可变量<V>>) 为
  此表去看，[是k v] v的值=此我[k] 。
```

恒事/量的规则：

1. 其参数会及早计算(const folding,常量折叠,编译期化简)。事的参数非常量表达式，则直接内联/控制流
2. 非恒里提及了「恒」量的代码会被及早计算，恒量不跨函数。绝句句级的语义是，非恒才生成运行期代码
3. 若 恒量a=建组(1、x+1) 等 `组<T>无法及早计算，它会变成恒组<T>`，a[1]+2 即 x+1+2

恒物的规则：

1. 恒物不作值，若 行<可变量<数>> __等无法及早计算，就作为「物」新构造__
2. 恒物()得恒量。其上所有事量内联，如  `建组(3、4)[1~略]去看，[是x i]x+i。  可变量名(改，0到1。、"首")的值=2`

### 如可变量

- `变T可隐转为 可变量<T>` ，访问链是 `局部|的|[k]` 构成，生成对应的恒 var get set
- 言不是访问链，则不可隐转 ；Ref值 尽量内联，除非作值

解构的规则：

1. 可变量<> 的值= 会判定是否变量、或创建新变量。 若不是变量且二者不相等，失败。(整体被翻译在 `变任，x；y。a令，解(我、 行(x、y))； 回真。 里)`
2. 有 `量a=建行(俩项(4、5))； 量a是建行(俩项(x、y))` ，内项含变量，搞个递归解构，若是 俩<数> 就不必

对于可变量<T>：

例如，
```
恒事 增(i：可变量<数>)=令，i的值=i+1。
事 f 为
  变数a
  增(a)

事 f 为
  增(储a)
其中，
  变数a
  恒例 储a：可变量<数> 为
    变数 值 读，a。 写，a=它。
```

- 可变量<数>隐转为数， (储a)的值=(储a的值)+1 ；a=a+1 ，此处能a= ，不必包装IntRef
- 但是，若有 说(储a) ，恒例直接视作例，a有非局部写引用，需包装IntRef
- 可变量针<T> 的信息更多

绝句局部物事(逗句块也是一种)里引用了外层局部，有=赋值 时会整体装箱为 Ref值.数(1)的值

类似于，你能序列化一个内联  Ref值.闭包() 。这会把局部量都变成 class field 且填写代码路径。 函续<R> 就靠对象化令「事」可从调用栈撤下-恢复，并保留执行状态号



## 整体

>言句段词物书 ，词左称小结构，如 if return 的流控句和算式 对外不可见。 否则是大结构，便于OOP再定(复用与修改)、以【标物】含额外常量信息

>构词(keyword)分「软常苛」三种，尽管绝句不以用词盖过句法。苛构词如「+」能用于分词如 `a+b+1` ；常构词如“我”不能用作变量名但『我』就强行和主语我(this)区分开了。偶尔单字符也用它 `物『组』为` 优化排版。修饰词分「简常」两种，恒既读写 后无需加“的”

>juec 使用取前缀解析器来把代码文本变为嵌套的调用。在“编译原理”课上，这是最左推导(1字消歧义)、无backtrack(重读) 的LL(1)文法。 事实上高亮分词也在容错解析时完成，绝句并非简单的套用了递归下降法

- (常量)值执行=值、符号执行=代码； juc知道「+-*/% 且或非 ><即是」和控制流的解释语义、(JVM,Java,.)编译语义  `1+1=2; a+1= a 1 iadd`
- 恒量的=言必是值；恒事有非值参数则内联；恒物(不作值时)事量内联；恒组含表达式 `f=[[+]]; f(1+1,a)= 2+a`;`f(a)=a.fn(2); f(T(1))=f(1)=a_num+2=1+2`;`add(f,1,x+1)(0)= {f(0,1); f(0,x+1)}`
- 提供 `恒事 受恒记：行<任>` 令 `建行(1、2)去滤「>1」` 可被预计算，求得 `[绝句::建行, 2]` 的调用树
- 『符号』可为：参数/局部量 、(物事=逗句块)外i层j号局部量 、例/__文件同名例__ 的引单事量、“我”是任(notype)时 受读("变量名"). 同有 受调用 受造；「的去」都有直接在“我”上访问版/扩充事量，`物事内 外变=` 导致其变为 `量 外变=Ref值.数(1)； 外变的值` [言]
- `可变量(obj的x[1]) = 可变量.K(obj的x、1)`，"的x" 则自动生成恒物 `变T 值 读写` ，按事量内联 规则。`变obj` 的可变量：内部实现，定义域事「令置」 `x的值=f(x)` 类似C宏。作值时创建物事obj，装为 Ref值 [句]
- 恒事参 f：函 控制流内联(回[^2n], 略过[^n]) ； `函1<函续<数>>` suspend fun 在已知时有函续内联，如 `试，2。去取否?其令「+1」空则0`；`列生(0)「+1」 去取前(5)去行[2]` [句]
- `我[^n]；若你是你[^n]` 可指代旧this 旧you(双主语=我[^1]) 人称变量；`建行()带号 去看，[是x i]； 量a是(x、y) ；判(1到2)是， (a到b)，a+b。` 是 `类例 语义解构 事 解(：行<可变量<任>>)` 提供的；`事 fn是 函1<数、文>，"$它"。` 是内联便利 [言]
- 量「试」：试字句 `若你此人 试，曾伤人或曾盗窃。 ，你去抵(你的罪)。` ；`此人令，试，曾杀人。则，杀此人。  试，曾伤人或盗窃。则，抵罪。 。` ，像中文并不稀奇，用判句 才更合适。
- ++i i令置「右」 i++ i令，令置「右」。
- 其中 内书级定义都可包含。不独立作用域：「量」视为在函数体头部，「事」「物事」强制内联。其他加在物的私下但不允许他事引用 [段]
- `量= 变初 变任，a；b。` 系 `物(变 a：数、b：文)` 对“公开的”主构造器 右侧参数都有效！绝句的这类“系统性简写” 是逐步脱糖的，也就是必转化为 物-字段getset&造于 的格式，便于编译=>Java,Kt

提点
- 绝句的逗句块、为其中/= [段] 只基于句首的缩进划分{}段，逗句里逗句会建议换行 ，记法「」可以是合法名字(英文模式不多分词)或任意串 且可 `引单 绝句 「+」作空`
- 「」小中大 优先级，小=内含1 言单、中=加号内、大=等号内 。默认后缀小 前缀中 ，中~大依次： */ +- ~ 记法默认 空则 属存于 >< 即是 且 或 。没有与(=)同级的...号 仅有组拼接 arg()
- 类物例、事量变(可带主语) [词] 的 公私族组内、既可未终定 对应JVM的 ClassFile flag(如 interface 标记bit)， 储例况标(data enum sealed-when annotation)和 改行表集：些许项 类同Kotlin 。`造于,亲,亲<T>` 属class结构 [物]
- 停下/略过,回[^n] (赋"返回"值) 是通过跳转栈校验break 的，内联看(函1) 里当然可以译s；也有恒物已知，如 `尝试A() 接迎错 B()` 在 `既事 B=抛下错("")` 时0开销。 比如线性查找：真假 ；i18n；【书:SQsu ''】
- `(0~1)去滤 去看` 的 `if(p(x)) [插入点]...f(x)` 也在有调度器才真传函续-`列生(0)「+1」 事 交(续)={“调度循环:”x=续(x)} ；滤(续) 交=if(p(x))续(x) ；看为(续)=续(f(x))` [句]
- 绝句的软件包『书』分发格式是 .pkg(zip,带资源) .ju_s -jupool常量池化的AST, 与 ju_ss 等价. 若担心“代码安全”可 -f mangle 删除非API命名
- stdlib `绝句  行表 读写 文本 标记`
- 标物附着在AST上，绝句推荐使用标物简写代码大结构 【参颗粒化】 【书作用域】
- LINC 像 Scratch UI 分组、组合况物，以执行高定制性代码；VecN 提供几何与向量(分量同算)、矩阵点积 等数学与加速能力

算式类型
- `对何<> T1=T，。`  『类型别名』(视为物)或『量纲类型』T1隐转T，T作T1(如在参数首次)执行检查。 自动填充和断止 不能有别名
- `物 _1 T`, `物 T_1：T` 子类型。T1有T所有事量，因此算式适用T=适用T1 (如扩充事量)，即 T可为T1。 `对何<读T> P`, `P<T>可为P<T1> `；`对何<写T> P`, `P<T1>可为P<T>`。 `P<任>` 读T,任=值;写T,任=断止 且“仅读写”会禁用以T参数/T返回值 事量
- 空类型：T不收空、T?可为T/T?/空， `(T?)!! =T, (T?)?的去 T?空则(言/句) =可选链` [言]
- `函0~函8, 函我8, 函新<T>` 函类型，省略尾参是“类型空”(Unit,void, 函续.态,任何句级) 。若不能内联逗句块 作物事； `函2<ABC> = 函我1<A BC>`
- 类型参数(其意义是一致性)： `对何<KV>(其中 V：可序) 物『表』；钱：表<文、数>` ，单字符，恒事里是reified(有具体类型的)。 `P1<arg1> 作P<arg>` 在 arg[i]皆可为arg1[i] 不报错，但一般只帮 `行<数>::去添 作函1<数>` 检查
- 类型推导： `盒(1)去拆拼「+1」` `对何<TR> 事 盒<T>.拆拼(：函1<T、R>)` 会归一(并集)各位置T的实型(`符号["T"]的值 作类型`)，再检查，若仍有 `盒<T>.拆拼` 则ok
- `对何<我>物 数值 为 事「+」(另：我)` 通过 `【宽 8 -127 128】物 数1；【宽 8 0 256】计1；【宽 -32】浮4； 100作数1` 来生成带类型的指令、`类例 语义隐转<数值<任>> 数值 事 试属于(T：类型) = “T的同名例的宽 <类型(我) 且符号相同”` 宽化
- `对何<我 N=数值 数 浮 计>` 参数0是自动填充的(我 是继承/T:可序时填充,N是生成各种数值重载)、T的 `同名例：某类 为` 让T子类也必须有这种同名例。类例(隐转为类)+同名例 是绝句升级的表达式多态

提点
- 函续Continuation,CPS 是让调用-等待 传回调，自动变形(包含for,if,try句)，或者说语言级互调协程Coroutine,Fiber。 它不是按 if p(next()) 或说 `滤：列  交(x)=若p(x)你去交(x)`(toList 啥都会混乱) 过滤一个流，而是让 滤&看&.. 变成由滤负责看..，因此 叠、去文 去行 实现都会方便、高效很多
- ^但协程并不是为 yield 序列设计的（照这样看 Promise 已能避免大部分async），简单的内联 行.next() =i++ 能实现完全相同的效果，但没有 if(i>=N)onEnd ，这也没问题(仅需定 forEach, toList也易实现)。在 for(i in 无尽) 里你却无法断续的计算，而函续已知的『列』可实现内联、否可让行[i] 处理外的循环去调度，通过状态机化每个 事(：函续)
- ^仔细说，Iter 里调用方是在“拉取”、Seq 里调用方是“提供”或“催更”，完全是异曲同工，但 Iter 的计算占用了调用栈，你不能在计算时HTTP什么，不然卡死整个Thread。ES6 async 就利用 `Seq<Promise>` 让调度器帮忙等待调用树所有setTimeout耗时。『列』里由断续的“(0~1)看”内调 滤、叠 这些，它知道尾代码是啥(i++..) 就能0开销
- ^线程Thread 可理解为并发执行的函数(调用栈)，协程则是回调组成的调用 互相yield，适用于mainloop 事件顺序(任务而非服务)调度
- 绝句 看滤序带叠、队栈、去文行表集、列 API 是重新整理的

旧事
- 恒的旧规并非「值值=值、值名=代码」，恒事量 都只“标明应及早计算”，引用恒量的言可早算、恒物() 上成员内联、逗句块有 noinline(而非 f作值作函())
- 待例-实际 expect-actual 由类例实现，内联 晚成 算符  尾递归  断续 infix const/reified/in/out 绝句里都有更简单的替代
- [^n]标签以前是 break@outer 的具名 `Map<标签,List<待填址break句>>` 形式；`量提取(x、y)=(1到2) ； 对a里的 提取(x、y) ； a去遍历，〖提取 x y〗。` 这样，"extract" 也不支持半已知量试= 的情况和仅指定位置关系 自动递归和试=, __
- 现没有 for 句、 try catch 不能作表达式、判属存于 无需每行前加is,in、重复回() 取代 tailrec 、没有 *vararg 而是 `入口(arg(1、建组(2、3))) -- 些许的：文` 组参拼接 [句]
- `作 作?` 曾是 `((User)o).x, o as Int +1` 优先级不清的语法，现仅 `""去作<文> +""去作否<文>!!` [言]
- 大设计上，人称不是联系整门语言的唯一归类法。靠单字口诀和语法类似已能降低学习难度
- 逗号表示法 人称文法 算符 中缀否定 复合名 等术语简化为 __逗句块/逗号块、三人称、记法名、逻辑「不」、点名__ ，取消了 不常 错误 对儿=俩项 属=类型 对(1..2)提取 等不生活词汇或符号
- 书首段 `引` 默认 import* ， `引单` 既能 import static 又能 import as 和简写前缀 [书]
- 不支持汉字数值/"""跨行串 而换''语义单引号、支持‘“” ‘’’ 嵌套注释/文档。字串内插 `\n\r\t\b\f\0\"\'\$\\`、`\uXXXX`、`$a`、`${e}`、无视首 `#!` 行。名不以0-9首 取直到空白或记法.=

旧事
- 集合类通过 `量a=改，建行(0)。 复a去看为「+1」“函新<数>”` 不默认可改与复制(即地改写)，组行表集合列 LnFix Ln Map Set ManyItem (都有RW) LnBy
- 人称「你」仅在若判 接迎(旧无默认名)句可用、没有 `你a且<3且>1` 的写法、「」允许算式、无首项、仅记法/量名 的情况而非“简短”逗句的写法； 不准让[^n] 具名、o去::f 变 o::去f、仅自动修正全角（）、逗句不支持 `、=；` [言]
- 初=受造、变参=变任(且晚决定类型)、常参(const val)=恒量、取者=读、置者=写 、属别名= 对何<>T1=T ；语言层次 常量(literal)、言元(atom-expression)、构(structure) =言常、言单、物 [书]
- 包、引全、定/引记法、成、除、皆有、代者(by)、初(init)、覆写/抽象-实现=既、开放=可定、伴生例、记物=标物、内联物=恒物、抽象物=未定的物、扩物、内物=物事、我属=“类型”我、 `@!` 等前后缀记法，变 书级事/扩充量 [言]
- 物变量 取置 而非 读写、储 而非 可变量 ；不支持 量，a 1；b 2。 名值表简写 ；=可变量 子类 而非 by、 ：继承自<某类>(obj) 而非 by delegate [句]
- 『我类型』和数浮计(Int Rat Cnt)合并为自动类型参数(字文真假 也是基元类型)、效果(Unit) 不再属于值(类型空 必是尾参不写)， 空则(?:) 右可带句 [言]； 令为 令做 顺便 配置为(let run also apply) 变为 其令为 其令 令为 令


绝地
- 1指/上下左右  速览代码和鸟瞰图
- 2指/Alt(移动行 选区折叠/展开)  右执行 左命令
- 3指/Ctrl(移动项 选区+-1段/1词) 右调试 左文档
- 4指/Ctrl-Alt(向上下复制) 左右部标签
- Alt上下上下 n指操作选功能、复制/列选区
- Ctrl- 在每行选区首添加光标

鸟瞰图UI
- 双击添加书签、行号添加断点；右滑选区 、/鸟瞰:常驻
- 切分球拖拽-滑选 功能,文件:打开和拆分编辑 单击打开首功能  /球:添加 瞬移
- 左球可打开面板: 运行/符号表/mvn 调试 文件 插件 搜索
- 底板:  VCS 报错(终端) - 行号/+选区(书签,改动,问题) 缩进  编码,换行(转换) 语法
- inline标签、二进制格式-等价。所有菜单都可被固定

编辑
- 可Shift: Tab, Z, O, Alt-O N 缩进 撤销 打开 打开文件夹 新建
- P 跳到对应 Shift连击 随处搜索 L 打开于 F 搜索/替换 '/'注释选区或行 R重构
- Ctrl点击 跳到文件/声明-实现/引用
- CXV复制剪切粘贴 S W Q 保存 关标签 关窗口

