# 绝句

- 事量物例类 公私族组内
- 储标例况造 既可未终定——面向对象OOP结构
+ 看滤序带叠 列行表组集
+ 若判是属存 书引何其恒——数据与表述式句

事量物例类 公私族组内
读储标例况 列行表组集
看令函是变 既可未终定

为在中文更自然且统一，绝句取消在老教、脚本、函数式、新潮多范式、DSL(模板配置等小用途)里既有的语序和内定模式，如引入不一致性的 `for while, forEach, [for]`、低频次 `goto label:`，__抛弃和根源化__ 是绝句拒绝机械翻译的重点。绝句不是易那样「自主融合」的机翻VC，而是因 Kotlin "Kt" 启发的新语言、编程思想。

不太纠结具体语法词法、算式层次，绝句比 C-like “结构-过程式”语言添加的，对现实应用需求，有序简洁明确之处 才值得。不工程亦不学院派，让人以中华区的语文描述自己对事物套路的理解，不去重复功能、孤立领域，这种务实是绝句「[抽象](-就是赋予动作新的名字，对步骤不懂的外行友好哦)」的首席目的

- [标签P]定义域、值域、量纲、解构造
- 事量[公式]：数值 `事 mix[abt]=a+t*(b-a)`、`事toStr是 函1<数、文>，"$它"。`、、`量，n 1。变数，a；b。`、量纲类型 `对何<> T1=T，。` (在参数)执行检查转换如 `正数=数「>0」`
- `变任 任` 据初现的类型保存变量，以方便UI绑定等共享到{}外的需求，避免“XML+Java 声明两次”等低效注入
- 糖实质：类-未定物多继承&事默认；主造于-量属性-字段getset；例-物同名例

没有脱离语言的思想。减法既有的「知识」要克服太多，保持旧有适用性更不易。翻译器或“试错运行”的工具、中文编程或特立独行的八股文很风流，但 __绝句是为编程工艺的中文__。 绝句容纳的，是所有语言与库中“更而不易”的概念、程序的目的。绝非术语字面之热点

比起评判高低，穷其变、知不穷更像编程语言的本份。0开销化“能写代码的代码”(元编程,CodeGen) 和文档良好的约定俗成，不爱手写单调零散的配置数据 是好习惯。

历史和技术是相乘的，历史是0技术不会多1。只有激进的改变，才能找到自己的历史

o.f() 里f的参数0不在括号内，调用签名在 o.既知type[f] ，看似只算主语归类的访问却造就 f().f1() 的调用链（尽管[令为]更轻便）。语序修补也算语言特性

从编译原理视角，绝句用到 类型(常量算式)流控、代码复制(宏,template,运行期stub)、dispatch(vtable-pos,match,fatptr)、GC 所有这些常见特性；前端和VM也说到底是把语法树上转转、缓存化解释器开销。尽管此原稿300行，多半流程也不过堆砌。


## 控制流
> 重复若-流控内联、?链、值变量 +逗句何为缩进布局

推崇函数化、禁止break@out 的循环：

```
恒事 从0数(n：数、op：函1<数>) 为
  变数i初0；重复若i不>n，op(i)；i=i右。

从0数(2)，[i]
  若i是1，停下。 “i=0~1 停下，跳转到哪？”
  说(i)

量str = 1令，
  若我是1，回[^0] "abc"。  “怎么略过下方代码？”
  回[^0] ""
```

- 在 `op(i)` 里 `回[^0] 和 回[^1]` 的语义就确定为 `continue 和 break` ，多层while时也有效。`略过 停下` 借此生效
- `恒事` 会共享其跳转+“返回值”写入（首例有3处），为易读语法/API服务<br><br>
- 在 `x令(op)` 的op里 `回[^0]` 定义 `量str= _0` 之 _0，有[^0]则借 `for(;;) { if(self==1){_0="abc";break} _0="" ;break} ` 自由ret
- `回；抛下` 基于调用栈跳到旧执行位。 `重复若；重复..若； 若a且 “短路-a假时才算”b，否则，` 由编译器生成完if,while整体再回填各类跳转地址，输出 类汇编(JVM,PyVM,CRuby,LuaV,x86,.)
- `重复回(新值=)` 可全参或部分重写，跳到事首(尾递归tailrec)


`get() ?其令，它+1。?其令(新表「取」) 空则"没有"` 可空调用在if{} 内展开。言级 `o?.f()?.f1()!!.xx` 的T?部，x?.a()空则b 变 v=x?x.a():b

>`op(f1()?去f2() 空则，3。)` 即 `v=f1(); if(v)v=f2(v);else v=3; op(v)` 随后 `if; if` 会被标记移成 `if{if{}}` 来保证原理简洁+0开销。`-3ary 以禁止?:判断`

绝句以 `items去看，` 同时实现0开销 `for(T it:items)` 和 Iterator 的指针右移(可断续,如点击时显下一文本)

>这些都「把调用换成变量，并在前插句」，`重复若` 可能变 `while(true)if(..)break`。`"fn()"= liftVar{fn.call(arg,it)}` 可替换调用为赋值，适于恒事

- `值变量<T>(变值)` 指代可变量如 `物 俩变(a：文、 变b：数、c：数)`
- 值变量支持链 o,o.prop,o[k] 的末部，事>变 绑到物事的变(或nonlocal)。仅作值时包装，内联则只记名
- 类型都属于『值』、断止属于任何类型,不可别名 `值? < T < 断止`
- 若块需回值，末尾1言(及断止)会作为结果被使用。这适用于若判句
- 空则break 等属句，右侧是言即能被言级包含，`若 判[属存是]`  完整时同；书级事量是  `例 文件名Ju 为` 里的词级定义

### 逗句块

代码块{} 在绝句写作可多行(下接的去链)的 `，。` 但对物事造于有例外。缩进上 跨行`f()` 不检查尾深度==当前 也无 `\`

1. `物 为(..)` 可不写，`事为` 还可写成 `事=待定()`, `事是 无事`
   1. 二者都可后随 `其中，(单行不加句号)`：可包含书级定义，不独立作用域。__量视为在函数体头部，事 物事强制内联。其他(量“带”读写=物量)加在物的私下__
   2. 可前随 `对何<TRKV> (其中 T：属1、T：限2、K：恒)` 的型参(约束)，`for<TK>(T:P1, K:eval)`
   3. `例/况物 为` 内可前置 `名(参/参名、)?` 的简写，分别用于super()到Enum值，和简建子类！
2. `造于(n：数)：n增；造于("$n")`，made()没有C++式赋值/另调列表，此外英文逗句即":", 单行 (``) __绝句没有含糊和“隐式”或“严谨”，所有语法都考虑着频次__
3. 变量的逗句 `变数 读=1 写，说(你)。`，宏 `变数n=同一的物量，增(1)。` 会以n+1保存(避免写公私两个变)；`“变任”var*: a; b` 里 *不译作notype

>`'1${2}3'= 受单引号(仨项("1"去切(以=' ')、建行(2)、"3"))` 除能含$内插，可('''带缩进)跨行。`"\41"==ASCII[95]=="A"`，字不是数，__字节(Py bytes)是数1的组__、常量数可隐转为浮

关于链调用 `$_=新f();f1()..` 和(GLSL同款) `f(out res)` 很亮眼，但细想鸡肋。无法在此面别于Kt

- 类(物)名和实例以“此人”或 `小明：人` 区分，`错xx：错 错于：异常` 以错开头
- 常量不标明， `数去看为，它+1。` 也不区分集个体；管道 `函1<文>，它去除白去替换("a"到"b")去转(大小写)。`
- `若q a否则b` 在ab为量时应写作 `q去路(a、b)` ，既然在ju_en里「」由反引号`，『』就由``包围
+ `fun()=fun()=` 被柯里化代替：`【参颗粒化 1 1】的事 所有物(主人：文、：文)="$主人 的$此文"`
+ 宏 `【以下"3物"】 【默认初始化】、【绑定Setter】、【参:旗标"final"】、【数精度 8】的储物` 
+ `【装饰器 "显参"】、【参以 "俩项"】的事 文.分以(符：字、出：组<写文>)`

### 跨平台和脚本

Kt-common 区分了源码-依赖集。未沿用 gcc 宏式的 actual-expect 代码复制，`类例 主界面 安卓` 是为 `juec -p aosp` 实现主界面布局的写法

`“恒”类 安卓：跨平台("aosp")` 包含平台的常用全局量，类例和 `判跨平台的况 属 安卓，` 只生成当前平台代码。若有平台支持更多事量，`类 更多 主界面` 可以自然地区别添加

`同名例 量 JVM.xx = runtime.exec..` 动态扩充也可用

脚本支持 `{}` 字面创建 `行<T>、行<行<T>>、表<KV>、表内行<KV>`，以,或换行切分的 `项*(: 项*)` 生成KV配对如 `{1 2 : "<3"}`

同时有 `{1 2 3, k: v}` 时 k:v 是上方数据的过滤器。`{1 2, 「真」: 「它+1」, 5 6 }` 得 `{3 4 5 6}` ；只有 {1 2,} 时属阵列、{k: v} 时表、{k: a b} 时表内行(分组)


## OOP扩充
> 类型、子类型/类例、记法

- 储物 带自动 `文() 试等 量摘要码` 及 `可复制`，还可 `等位交(a、b)「首+次」`
- `标物 A(：数)` 以 【A 1】 被附加在语法树上(故必 `可收发`)，常用于绝句恒 预处理、代码生成及 JVM反射。标物、例物 定义都无怪异的写法
- `例物 通讯号：编号自(0x1f) ..开机；暂停(0x21、后随=+2)`
- `况物 运算.. 加减()；物 乘除：运算` 的子类确定，`判属于` 不必否则<br><br>
- 常用介词中缀：令* 被再着到必 试次止y
- 人称“你”在 `物 A 事 B.f=我+你“A”`、`尝试..接迎(类型)..终焉，“调用跳出!前”。`、若你、判你(属存是) 可用，`亲“super”<T0>` 调用事于T0的重写
- `词|=事 (主语.)?名(参名、)(：类型)? 码段 。参名=名? (：类型)?(=值)?` 类型默认其名，值默认类型，既名默认类型；缺则报错
- 可收发即(字节)序列化, `同一<Int、Str>(凑“成串”、拆)`，那自然有 sock,file 流 `可闭`
- `可化行{键名、拆：函<T、行值>}` 的函闭包能被序列化(到SQL等loc)，`待回执()其令，量k=它「」； 它(k)“恢复”。` 待先()以列断续 `$i` 留执行位置 做到单串即业务<br><br>
- `待<R> 试，。得<R>：其一<R、错> 待得<R>` 是绝句的流异常。`值 错?` 用于判定 `catch=或 且(，。) finally=令` 接上另一次试。`待 再 去全/首` 是对函0函续的封装
- `事 受初造； 同名例..` = `{}; static {}` (勿用子类可再定的量) ，`物 T “公开的”造于(“参名皆作新量”)`，物内有事/造/变量读写 by-代理 "宏" `量=值变量() 物：值继承<接口>(其既有值)`
- `物 主() 活动() = 物 主活动：活动()`，`事 受调用(0~9参)` 保存SAM接口化的 `函0(=Runnable) 函0<数> 函1<数、文> “arg0作this则等同”函我1；函新<T“同时是R”>`
- 物事：能拿外部物变量的 物(=分段执行+暴露局部量事)__Kt的匿名object或inner class 混淆语言层次 不允许__！以物事new无名子类(提供其上事实现)
- `值最新/函的可变量、懒、同一、其一{的/必A/B,翻}(+跨平台、试)` 也是好工具；事(其一、组参<T、3到"">) 可生成重载。量=懒 亦内联
- `类例 受隐转 事 转换(：T)：R` 以物事语法简写 `类例“作”数1 数4`。`1+1L“数4+数8=数8”` 由此([多态](#另)即多义法)实现

『我』this只是其上名字 可直接用的参数0，(仅需编译期)的作用域策略，__物与事的最小构造，都是“函数签名”。__ 但物可拓展
>`我` 是物的1个分身(实例)，持有在量或行..里，存储它耗内存/GC暂停期

- 可定性(impl ? ?? !)：类/未定物成员默认未定 impl??，(可定)物内默认终定(无子类、`xx去作<T> 去f()` 里f代码唯一)，`物 T1：T 既事 f“虚方法可定”` 就令 `xx去f` 另有多义
- 可见性(same 0 type pkg)：公开私下，族内=protected=仅继承时，组内=internal/pkg-private=仅同文件(被恒事引用时会public)

函与事(Fn or fun)何别？事必然在物的“我”域上，函值却可随处出现并自动捕获(cap,可变)局部量。函是无物亦存的“弱结构”事，可互换

定义域是算式所读写的符号集。等同Kt.let,also 而取代 Builder,Factory 的 `令 其令 令为 其令为 换set(待) 取否takeIf` 似 `量 T.「令」：函1<函我<T、R>、R>` 。__逗句块和「」引用__ 代表添加尾参/调用 ，逗句不可填在值位置如 `=xx, say(xx)` [P]

### 类型

- `物 T1：T` 子类型。T1有T所有事量，因此算式适用T即适T1，即 T可为T1。 `对何<读T>物P`, `P<T>可为P<T1> `；`对何<写T>物P`, `P<T1>可为P<T>` 如 `函1<值> 属于函_需文`。 `P<任>` 读T,任=值?;写T,任=断止 。会禁用以T参数“写”/T返回值“读” 事量 [形变性]
- `对何<KV>(其中 V：可序) 物『表』；钱：表<文、数>` 恒事里K是reified(编译期既知)。 `P1<a1> 作P<a>` 型参 a[i]皆可为a1[i] 不报错 [泛型]
- 空类型：T不收空、T?可为T/T?/空
- 型参常只提供类型信息如 `行<数>「添」 去作函1<数>`、类型推导归一(并集:成员交集)__各位置__ T的实型(`域["T"]“类型”`)，再检查，若必要事仍有合适重载 则ok
- 在 `物 T：可序` 和T的 `对何 同名例` 里 `：我` 指代T；`类 同名例 “无别名”：P` __对继承者的同名例限定P__

通过 `Box<T> = Box<Int>` 得T:Int 时 Type 树拿不到编译上下文(来查T,包括之后get:T)，但 TypeVar 可以由上下文创建填到推导域(fun,class)上。用线程局部表能多线编译但不便作 LangSrv 共享数据

>绝句有 __5模板类型参__ (即,会为 `实参：数n` 复制新重载) `对何<数浮计N我>`，若数非型参 `对何<> 数=数4`。计算机的数字(2进制)位宽度都有固定，像 `数4=2^(32 -1符号位), 计2=2^16 存于0~65535 半32767`

__所谓基元类型，是编译器选择+-*/指令宽度的标记__。基元无关于 引用/复制传参(深拷贝)及是否可变(左右值)，它被老教编译绑架为“特殊对待”的类型

这有Java不可 `List<int>` 的贡献。 `j.lang.Integer` 是堆内有类型标签的int，毕竟List不知1项占几字节，只能装Obj箱而又和 `int[]` 割席，C++则没事。Kt继承此问题，又帮极难用到的计算搞出一堆 `fun Long.plus(Int): Long` 的重载，界内全和SQL,WinHex,C无stdint.h 一样“长短”混乱，我不想学JS等用皆浮点和undef，但 __这些细节也不是容许编译器乃至API更复杂而“专业”的借口__

`事 余除(内数：我)：俩<我> ； 10余除3 令，次是3 且首是1。` 明确了除以抠字眼的问题。数/Int-eger 浮/Rat-ional 计/Cnt-count 有1,2,4,8 即8位bit~64位 的版本，也有 `数N=BigInteger,浮N=BigDecimal`

```
for<^>class Inc:
  fun add1: ^ //<>参只能单字符
  samename insta: Kst
  class Kst:
    val zero: ^ //类型上“^我” 和Inc同域,
class-insta Inc Int: //+capf +captf 生成外局部传参捕获static构造器如javac
  fun add1=this+1
  samename insta :Kst:
    val zero=0

fun Inc.`+2`=add1.add1
for<T>(T:Inc) fun twoOf=T.zero+2

when-class Tag :Byteable:
  User(:Str); Monkey(age:Cnt)
Tag.lets: load(User().dump)
```

### 记法

>记法如 `5次'「说("")」 按钮被' 点击，。 试'，抛下错。去取；RE'(\d+)' ("123")`

记法「」 可为任意串或名字(不略空格) 且可 `引单 绝句 「+」作空`
- 半参引用 `叠(0、「+」)；看为(「+1」)`
- 替代逗句 `用户去滤，名字试存皆 「它为大写」。`
- `成员集去看(用户「解绑」) ；关注者去滤(“我想”「可爱」)` 事量引用 `User::unpin`，所以 `函0R和命题` 不加「」就能传参
- 结合律定义 `事「*」 .. 事「+」小 (另：数) .. 事「**」小右`

`「」小中大` 优先级，小=含1 言单、加号内、等号内 。默认 __后缀小 前缀中__
- 中~大依次： */% +- ~ 记法 空则 属存于 >< 即是 且 或；`引 符.C式` ** ++-- >=<!；1的位 交并移 负片. 值去试同
- 前后缀 `-(x !!)` ，其包裹(`的去[]` )调用链，内层/左侧先算
- 中缀可=前缀(无重名时)、后缀=词 如 `"He"始以"H"是 "He"令，始以"H"。`
- (..)是言单，逆波兰算符重排 `1+2*3 => 1 2 3 * +` 易解析求值序

## 多文件与集书

引-集书(pkg registry) 与恒

`juec get -R删除s搜索Sf固定C缓存 /getdl局部` 能获取 包.ju 依赖的 pkgs/; `juec .pkg` 打包

>书 引/pkg use 列表和 引单/use-1 是绝句多文件的组织法， `引单p a b作d c作空` 即 `引p.a；.. “事量或类型”d=b` ，只带p时是 `import static`
- .ju代码从零到整：言句段词书， xx.jus 由 `类型的jus["xx"]` 引入，句级会被收集到 `受调用()` 即main 除非 `既量` 静态类型共享。jus 子语言里 `{名: v,*mapOf,}` 和 `{1 2 3; 4 5}` 建表/行/阵可用，甚至能调造于()
- `juec` 基于U-AST通语法树，做单双向Pass() 来脱糖/低级化源代码。参见 `同一<AB>`

惯用Java反射/APT生成 能见到词级信息。恒在编译前修改微至言级的代码，像 `""` 常量和算式。编译器就是求值顺带生成代码的解释器，只 __保留编译期未知变量的运算__

语法即编译期函数在(已知常量/`局参[j],外层[ij],导入[k]` 值位置)调用。`俩项(1、"常量")令，首。` 不new开销任何内存

`恒事/量` 不把参数或其内()视为位置变量/invoke-xxop 而实现常量内联，`恒物“仨<数>”` 把其构造量拆散来 __复制传参及赋值__ (作可变量就仍只为引用)，恒事的类型可以是算式，若恒量化简为值 亦可显示


## 数据与列

比起j.util和JSON式数据，`行表组集 <T>：些许项<T>` 与尽量低拷贝(new开销)的运算 是绝句数据

集合改写事分 `表<KV> 改表<KV>` 来限制 `改，建表(1到2)。`，组有 `组<读文> 组<写数>` 禁T作参数或返回值

- 行,改行 `Ln<T>, vector<Tp>, Lua{} PHP array()` “列表”是可删添的有序集；实现队列
- 表 `Map<K,V>,Hashtab, Rb{k=>v} Py{k:v}` “字典”是 `行<俩项<KV>>, 年龄["小明"]` 单向查找的优化
- 组 `Array<T>, T[]` “数组”是固定长度的行
- 集 `Set<V>, Py{1,2}` 就是些许项(如 来自表)
- 队 队和栈(`事 添,泡`)序，或双队(deque,JS [])

`组值 组参 组恒` 分别用于为反射提供装箱 `Int[]`、`"Dio的%s" %参("世界")` 不定长参数/*拼接 、循环展开为多句

数理和编程目的性的差异。解除构造[P]的本质是对应位置赋给值，`量是 判是 其令，[是“于新域”]。` 内未知量+变量 会创建为 `值变量`，定量则为 `命题, 或者句`，放在 `俩项 行` 等内。如 `量t是建表(1到one|"没有")；此俩其令为，[是 a到(合规)|"格式不对"]a。`

`类例 受解构 俩项<任、任> “恒”事 解构(：我)=令，此我“变量集”的首=首。` 会条列与赋(默认/失败消息)值，`恒事 已生成(：俩项)：错误?` 在判是可重试多项

`任.“或”受取(：文),受继承` 是动态类型(执行完才知有无def,class)；`表计<K> 叠着<A>.分次 表数<V> 表域<N> 树表.连串<KV> 树行<T> P<Arg> 俩量：分量同算<N> 前缀表<可看T>  文件(pwd、rwa)去建的文去读` 也被提供

### 函续的续

回调/@Override（注册1函数值）或链式 `Promise.then` 都是基于事件队列 在分片段执行业务，而函续是编译期的分段。`JS.prompt(); Py.input()` 等阻塞事令用户-和1线程在填完前不能干别的事。(同时弹窗问n个数据咋写?能击键时赋值吗?)在顺滑的UX里这种单线流程很罕见，需要“异步”。绝句可以没差的语法写异步IO：

__UI库需死循环(非cmd式算完退)__，1条线只能执行1个轮询，另建线执行onclick() 总开销巨大。故VSCode是单线程app？

Lua,JS,Py 里“协程”即 `coRotine.create(fn{yield_or_suspend() })` 可主动暂停(不等待ret)事，不必占用1调用栈(待信号同步)。JS 靠 yield Promise 回给调度器注册then实现async。绝句允许闭包字节化、事依opPtr恢复执行(即自动把事变带变量 Iterator 如 `for(i=0;;i++)yield i` )，`函续<R>` 即闭包变量们。

>__基于“尾步骤”而非“栈等待”的函数种类__。f1的函续是基于 `run()=when(状态号){..需函续调用_间片段}`，f1{f2{delay(1s)}} f2休眠并return,f1也随之等待 delay 的唤醒

函续是回调，调用方保留其暂停语句号，`f1{f2();if f3()}` 就变为 f2,f3 在某事件继续f1(例如main)，称尾"调用"或CPS。

`事 f(“末尾”c：函续<R>)` c自动生成，调用树倒转一下，让后调者(setTimeout等)提供并“催促”整体返回值的计算("主函数" 在之前要死循环)。若c重复调用呢?

### 列的协程

那需要f的调用方在c()后也重复调用f，像 `foreach(0~9,f)` ，即是生产-消费队列，f,c 都可以含sleep 或待鼠标事件而不必在 new Thread 或ui.eventLoop。

>f会返回 `函续.态{睡,完}` 避免c在即得结果时休眠，函续(f)(参) 可拿到其状态机，避免f调 `yield(x,c)` 时每次保存c参；`行：可看<T>` 自动实现列()和优化的看,滤看,带号

```kt
suspend fun main()=coroutineScope {
  for (i in 1..10) {
    launch { delay(2000L - 200*i); print("$i ") } // 执行器启动10个任务：暂停2k~200ms  输出i=1~10
  }
}//: Job. “新”timer=otherScope.delay(1s,空) 如果你不想等待 但-绝句没有协程域，且coro{} 是不分 runBlocking 或以上名称的
```

>进程是会话/隔离级程序，线程是服务级，协程则可以说是任务级。 要完成电脑的日常，3样缺失任何一种都导致代码的难读难重构，以及性能损失

## 另

- 值域：有Py式 `[0,1,2] [1:] ==[1,2]` “列表切片”的重载 `建行(0、1、2)[1~略] 是(1~2)去行`，`list[a:b:step] = [it[i] for i in range(a,不含b, 步差step)]` 如 `["0"] [0:1]是本身` ，

b负时是 `len(it)+b. it[-1]是末项,it[1:]是首右余项` 。通常it[0]是首，从0数的理由如首项=“列表的内存位置(指针)”、`(a=a+1)%b < b~0往复` 更明确

`0~99, 0~100左, 5~+1 , 0~10 升-1` 是描述变量数值范围、或采样间差的工具，适用于数类型的穷举和判断，如 `5试，我存于0~5且我存于0~100 且我属于数4。` [P]

- 算术式和作用域

算符重排解决求值(即包含)序。Lua同款的此法支持无括号 `0+ ~(1 + 2)` 和 `(0+~(1+2) )!?` ，方法是把 `1+2*3 = 1 2 3 * + ; 1*2+3=1 2 * 3 +` 遇+先输出*级更小更深 继续到读不出 `(x o x) o x` 链单项x 。

`全局表<文、词定义>` ，在进入{} 前保留旧定义，退出{} 时还原就实现了 __层叠作用域__(动态域)。 当然，变量都在函数头声明不大合理，解析期由var做 +1局部量 冲突报错，即“变量提升”。也有 `eval(e.opr,t.copy())` 和原型链：解释器开销大

- OOP多态

>名字在代词指向/子类型上的差异，称为 名/值多态。
多态poly-morphism 即同名多义，不同代码的命名更统一化、易于复用，C和VB没。绝句有3种
- 子类型再定(即重写，原型链也常见吧)
- 符号名再定(即重载)
- `类例 受隐转 T` 多条


+capf 的参数捕获

受解构：“我”的赋值会生成支持 `|或者句` 判断的句，在其中块共享变量

### 绝地

- 1指/上下左右  速览代码和鸟瞰图
- 2指/Alt(移动行 选区折叠/展开)  右执行 左命令
- 3指/Ctrl(移动项 选区+-1段/1词) 右调试 左文档
- 4指/Ctrl-Alt(向上下复制) 左右部标签
- Alt上下上下 n指操作选功能、复制/列选区
- Ctrl- 在每行选区首添加光标

鸟瞰图UI
- 双击添加书签、行号添加断点；右滑选区 、/鸟瞰:常驻
- 切分球拖拽-滑选 功能,文件:打开和拆分编辑 单击打开首功能  /球:添加 瞬移
- 左球可打开面板: 运行/符号表/mvn 调试 文件 插件 搜索
- 底板:  VCS 报错(终端) - 行号/+选区(书签,改动,问题) 缩进  编码,换行(转换) 语法
- inline标签、二进制格式-等价。所有菜单都可被固定

编辑
- 可Shift: Tab, Z, O, Alt-O N 缩进 撤销 打开 打开文件夹 新建
- P 跳到括号 Shift连击 随处搜索 L 打开于 F 搜索/替换 '/'注释选区或行 R重构
- Ctrl点击 跳到文件/声明-实现/引用
- CXV复制剪切粘贴 S W Q 保存 关标签 关窗口

虽说绝句最开始是 JetBrains 语言的“逐词翻译”(把class译为“物”的程度.)，随着3年的草稿，绝句和 Kotlin 早已南辕北辙。

无论用词的文体、语法还是数据物+功能、编译期处理上，绝句的道路不 Kotlin+ES6 不 Haskell+Scala 更不 Groovy 或 C++，其严肃性与“专业语言范式”是有云泥之别。

绝句的词人将能体验到一种既松散，又不乱；像简单，又不弱；词抽象，意满盈 的工具之厂。名为厂，却真正不在机械重复

名|ju|kt|描述
:--|:--|:--|:--|
无 数值重载|`值域 组N 数浮计` | `IntRange; IntArray; Int,Long,. Float,Double UInt,ULong,.` |只靠 `对何<我>` 泛化数值类型「+」等计算参转换和装箱拆回。无“基元”类型
名动词OOP|`物 类 物事 变“量”读写` | `class; interface; inner class; var get set` |改写了OOP“类”的含义，重命名 companion object = 同名例samename-insta。`super<TYPE>.f()` 变为 `作<上物>去f`
成员词性|`既事 清空；族内未定的事 『砰！』`。默认公开终定(或继承)|`override fun clear; protected abstract fun Peng`|弃用保护(族内)、抽象 final “修饰符”而有可见性same(公 私族组:0 type pkg)+可定性impl(既 可未终:? ?? !)
读写型变|`对何<T> 事 组<T>.覆盖(至：组<写T>)`|`fun <T> Ary<T>.setTo(dest:Ary<in T>){dest[indices]=this}`|out=get,in=set,*=任意 。形变性除校验传参/返值也用于试否可 `序反()` 等动作
SAM,次要物事|`f(层叠()) 其中，物事 层叠：值继承<表>(t) 为` | `f(object: Map by t {})` |__禁用“匿名内部类”即表达式级新类型__。只有物事能访问外部量、客制编译期脱糖
可变量之事|`量a=造表("a"到1)内 去作<值变<数>>`|`val a by mapOf("a" to 1)`|利用 `值变<T>` 提供变量名、读写 方法 比如组/表-视元素单项绑定，以及解构(的每项类型)
隐式型参|`对何<> 针=数「不<0」`|`typealias Idx=Int`|类型别名细化为『量纲类型』，类型参数自动填充：“我N数浮计”、父类同名成员、(外部物)同名参数
单文件跨平台|`物事 JVM.终端组件 为 例：终端提问` | `expect fun; /*jvmMain*/actual fun` |利用 ~~类例~~/全局量实现跨平台和平台接口集。全局This：JVM
^类型|<td colspan=3>曾用名：值域 数域 区间、域半 略域、计数 正数、<b>物事 内物、读写T 出入T</b>、值变 可变、上物 亲物“第一人称” 超类、值晚 晚设 晚置(修饰符)、允许匿名obj:{}、“类型别名”、待定-实际</td>
真假去路|`用户 为Vip 去路("您"、"亲")`| `if(user.isVip)"您" else "亲"` |基于 `(真假\|其一\|得).路way` 做“三元运算”和查找，变量=函0=函试，尾参「」可多个
位旗|`用户去作<位旗<钻>> 为(绿钻+黄钻)`|`user.vip.run{isGreen&&isYellow}`|按位交并异 实现的bitflag
“不”与公式|`事 试偶[n]=n去余除(2)的首是0；量 数.为偶=试偶(我)；2不为偶`|`fun Number.isEven=toInt()%2==0; !2.isEven`|为真假事量添加否命题、将算术模板类型化。另支持 `事 f是 函0，` 的模板定义和 `变*，n 0；i 0。` 量表初值/首次类型
且或连缀|`若 用户试「为老鸟且名似"^A"」`|`若用户且为老鸟且名匹配"^A"`（绝句草稿）|弃用无义糖，保证一致性；代数解构和中文数值亦弃(但有 `量n是x**2`)
人称与语法支架化|`判你1 存于，0~略，"正数$你"。否则，""。。`|`when(val i=1){ in 0..100 -> "正数$i"; else -> ""}`|when-in 只是多次调用 `域.试存` 。判..是 支持解构如同量x是；你我它[^0] 式标签不命名
双主语|`物 应用域 量 数.「em」=我*你的字号`|`context(App)/*receiver*/val Int.em=this*this@App.fontSize`|扩充成员用类例实现、数.em 依赖相应域。多主语和“基类”混淆且难传参 不支持
既未知解构|`(1到2)其令为，[是a到b]a+b。`|`(1 to 2).let{ (a,b) -> a+b }`|禁止按编号解构、可在解构处给 `字句_或<函试、文>` 判断
试与异步|`对何<T> 事 待<T>.「!」(：函续<T>)； 试，抛下错("")。去取否 空则1`|`CoroutineIntrinsic`|用 `待` 隐式回调，`试` 简单处理异常(重试)情况，用 `取否 空则，。 和空错(0、"未找到")!!` 取代 `getOr*` 处理
^语法|<td colspan=3>曾用名：路way 并路fold、空(未写类型) 效果Unit、断止 無、余除remdiv 取余+除、“判”只限于属存是、无法if解构、尝试..有(终焉)、以 `断续(T)->R` 而非 `函2<T、函续<R>>` 协程</td>
事简长名|`造行(0)+空值() 改，造表(1到2)。去滤(到=kv集)「真」` | `listOf(0)+emptyList(), mutableMapOf(1 to 2).entries.mapTo(kvs){true}` |禁以长名附加可变性、空值（__利用同名例类__）等参数，得益于绝句的“类例”多态+同名例接口
事无异名|`造行(1)[0~略]令，添2；泡第(0)。` | `listOf(1).subList(0,1).toMut.apply{add(2);deleteAt(0)}` |禁对同种操作因结果不独立存在而差异命名、用添泡命名增删，操作后集合(往往)__默认可改且不复制__
令我上|`其令为itLets 令为lets 令 其令` | `let run apply also` |Scope Fun 到“定义域函数” 着重性有变化
函授我|`f：函我2<T、A、R>、f1：函1<A>` | `f: T.(xx:A)->R, g: (A)->Unit` |禁用()-> 等类型运算符
绑定同|`变行<文> 内容=文件("a.txt")内(同一去切('\n'))`|`var lines: String by File("").text`|`同一Equiv` 和变=值变 组合
看滤序带叠|`听去行 去切(' ')去看为「数()」 (叠.自(0、「+」))`|`System.in.bufferedReader().readLine().split(' ').map{it.toInt()}.fold(0){a,b->a+b}` |以支持 `表叠(叠.至行、用户「分组」)`
储标例况物|`况物 文具(剩余：浮) 为 铅笔(硬度=2“B”、剩余)；橡皮(白度=1、剩余)`|`sealed class 文具(val 剩余:Float){data class 铅笔:文具/*太长不写*/}`|例况有前置简写构造器，`造于()` 及.jus子语言 可默认类型签名与传参(如 `物事 文件.屏蔽词()：文件“同名传参” 为`)。
^数据|<td colspan=3>曾用名：`动行(1)+建行()+空行()去切片(0~0)`、`令为let 令做run 配置为apply 顺便also`、`函我2<T AB、R>`、`可看.求和 变 列.和`、映滤排组归(+对每项forEach)、储例况标(使用频率序)</td>

逗句何为、记法「+」、你我它[^] 已融入绝句的文风和灵魂，不再是醒目的功能点；而“不”与“?其令”、空则 也跟随了众多新语言的表达式改良，保证易读易猜。

绝句的用词并不是为看起来专业、不是为了孤立和“酷”，却也不会非中文不可。每个字都经过词频事例和久日的推敲，或许这“文笔”很激进，但它也只是从<abbr title="从良渚文明(2300BC~)算是五千">四千年象形字</abbr>的文化里，取出来的『原来如此』


类型树项：(图标 锁:红蓝绿) 白盒=物 蓝=类 红圆=事 蓝方=量 (名) (? ?? ! 可定性)

图标在中文是类型名/首字；对物造于、长名是编号。英文用"Hi", +- 表示类型

### PLNK

律lvABC
- Arg 命令行:Cmd参数 CLI交互 解析器
- Bin 二进制:file/mem 0-copy修改&libc-FFI
- Code 文本代码 AST 和高亮&sloc 解析器
- D# 函数图、数据、滤镜、音频 绘图交互平台
- 按键鸡  任务 库/辅助/{放大 软键盘} 系统/{更新 录制 示啄 关于} ：啄N遍 啄N秒 预设 快捷键

陶瓷：各框架统一 Web(HTTP,SQL,Sock,XMLs)、系统服务(XXBus,注册表etc) 绑定；GUI组件库

>PLNK(points,link) 树状/图 编辑UI、非数图表、计算库

AST可以类似Scratch的UI来编辑。物=绿 量/流控=蓝 事/言=橙 ，词定义可内嵌或用线集散查看

可以文本添句/编辑、添加令* 块(赋值)函数，子算式可命名。 可拖拽码块以示范代码的事归类

调试器可记录函数图，如方波

SSA 和 AST 一样是已解析过符号的计算图，如 `val a=1;a+a` 每点固定输入 多份输出，可参看 Blender着色器节点。跳转在BasicBlock 做不完整"短路&& ||"计算，LLVM IRBuilder前端是SSA形式，更利于死代码/公子式消除 等编译优化、寄存器 指令选择等重要流程

phi节点让SSA可以重赋值，如 x=(q?a:b) 里x的具体算式靠前BB 是a还是b决定，生成上就是让ab都赋给1量。以前 for(i=0~1) 即i=0;while 这样的跳转循环也i=phi。现在推荐创局部量，有 mem2reg

流控的实例，比如 If(cond,thenB,elseB) ，问cond 决定是否跳到else-可为{} 。 之后的插入点是新BB -手动要if{}写完 才能“回填”}后地址，等同break 。IR使得3*br自动回填

```
引单cmd.Cmd
引random

物 猜数：Cmd 为
  既量intro="随机猜100内数"；prompt="猜: "。

  量 n=randint(1000)/10
  量历史=改，建行()。；变数 近

  事 $default(：文) 为
    量数=试，此文去数。去取否 空则，说("$此行 非数")；回。
    历史添数
    说(若数是n，"中了!"。
      否则，"太${(数>n)去路("大"、"小")}了！"。
    )
    说接近()
  事 说接近：真假 为
    量d=历史去看为，数的距(它-n)。去计的极小
    回(近>d) 令， “^试避免重算!”
      若我，近=d。

猜数()去cmdloop

接水 relextrma pairwise
```

绝句，语文之美
语言之韵，绝句之律「绝地」
继承自过去，组合出未来
既定事，可未终定！
组事为强族事，私下更为公开
汉语标点，成事有余。华夏拾遗，丈量世界
条条推敲，字字如金
行云流水，表万物相连；序末俩头，看数浮何异
对何项，只泛此型

文心雕龙，函涵读写
重定义，万事万物[多态]
类之例，无需多言。[类例跨平台]
事其中，何再物事？[匿名内部类]
不严谨，愿重复回回虔诚[重复有意义，新潮有语义]
不为更酷，只为更明[恒]
距离相对，运动绝对！[物理记名]

为何此物如此新
引人注目又很新
为何此物如此酷
突破常规又很酷
哦123时光流失
问题仍然环绕我
为何此物好冷酷
虽存温度也很冷酷

换个视角去寻找真理
偶尔也要回头看
来解决 他人所不能及
真是清理一切问题的妙法
加入未来一代曙光的小组

但告诉我你怎怕什么
你明白它会还 有点用(继续做)
立刻开始！追踪！只剩一半

突破常规更进一步
做点更智能的事物
勇于创造先于成果
词语激昂引领前方

为何此物如此新
引人注目又很新
为何此物如此酷
突破常规又.. 全新开场

不属从任何术语，绝句只给您想法和步骤的表达欲，为此把领域连系
飞吧，绝句！把被篇幅或阅读阻碍的空想，变为近在眼前的真实
a更新b渲染，b输入a重赋值

线信号的喧嚣、数控PCB的碎语

未来代码 本源程序
死盯语言的目的，只做份内的事
语言在开发者到OS-CPU 的流程里，是微不足道的前端工作。但如同经济原理，它的决定是根源性的。更优质具体的输入，毫无疑问能简化亦优化大量尾步骤，解决更多本不存在的算法问题。编译器的存在是为打破这种绝对的联系，可冷冰冰的“天才”用词，真的比C远离过程式、反省汇编时代，反省导致问题的功能缺失和误设吗。

创造价值和价钱是不同的。当导入导出变成“增值云服务”时可以粘住用户


绝句所吟诵的文化，并非「文化凭证」所教给你的单调横杆，或有其形无其神的文字把戏。
所谓不严谨不达意，从我的角度看就是世界第一的概括能力，只有中文做得到的事情。抽象而严谨，并不即是空洞和死板。
不知如何形容它所做的，但，绝句没有一个名词设计考虑短于10分钟的。从未以为新即是好，却独不见死而不亡、大音希声的东西，始终环绕于既专业又客制化的软件
即便从创业者的层面说，中国从未在领域“成果”前加入竞争与协作吧。 所谓的成果就是这种等摘果的功夫、商业互吹才用的文科“弱”笔，不够啊。这种处处隔阂的科学学术，早点把乱眼的书体跟上，才能为领域献出自己想不到、没工夫做的事吧？
不敢质疑的大厂规范，是中国人的核心吧？算吧？万般皆下品唯有怎样高，真正在挡路的、压制创造力的，不是时间和课业，是你们的审美。叶并非果的装饰、学并非识的证书，它才是果实里的东西；从根源翻涌相乘出的人潮思潮、逆向仿造出的用具，何止是敢改动几处的区别。

越黑话的事务群体越严重嘛
所谓高材低差，都不过是只看见自己领域的独裁者；话里的最好，永远指被教导的既存的东西，哪怕不知差异为何、为何差异。根本没人在乎规格背后的流派渊源吧
即便今天也憧憬亲缘学科手操具体能力的兴趣者，却再不会忽视口吻里孤独的主观，与原理不相干。
无论为何重复，大同或大异的参差，天上地下，他们的代码里都缺少一种味道。把成功视作失败的味道。“不满”的味道

即便扫两个码很麻烦，`待<R>` 也能轻松流水，且示码能用相同接口完成
大牌不能把一件事做到极致，只能在方向上逃避同质化


词法是JSON+可嵌套“” ‘’注释+"$字串"，注释放在wsPre[语素]前导空白间，文档和其下词以编号配对
言级是 (言单=言常+名[^]+的()[]去 链) 再+「记法」。 ?链、默认参数、逗句「」参数 也是一环
能打的流控有 重复回(扫区=a~i) 和 判x(存于,属于等中缀)… 在分支穷举或有“否则”时可作言
若(言)… 有 (开关)去路(1、0)；重复若 (重复…若) 有 "甲乙"去看；尝试…接迎(型|) 无finally 有 试…去路(无事、除错)去皆
被替代，基本仅用来教学和语言自举

词级该念诀：

事量物例类 公私族组内
储标例况变 既可未终定

例况物有 名(参、)； 格式的初始/子储物 前置定义。：例自(1) 提供改编号构造器，构造变量 “变x：数、” 右皆可变 同名自动以“既”覆盖
造于和变[读写] 都是 =|逗句 函数体、事则是 =|为|是 体，造于(及jus子语言)的同名参自动填类型，可见性默认继承或“公开”，可定则默认“终定”
值变<T> 仅有变T 值 和受隐转至值，也实现值懒、值晚(先以null) 的检查- 值变.V 的实例会被内联至变量读写、.K 则含集合编号信息。如同 o[k]=o去受读(k)；f(x)=f去受调用(x)

书级除 引 引单 该先谈 对何<>针=数4「不<0」 量纲类型，和[]公式：

事 pmix[abt]=a+t*(b-a) 里3参是 对何<N> 的数值
量，i 0；j 1。 换成变任 一样
俩(1、0)其令，[是a到b]“量它=a到b” a。

方括号、对何<> 以空格分多词(“是”算1词)，或大小写一致的1词

物事 除了能读写局部量(“我”)，其可作扩充事、构造隐式传同名参。对重复率高的词，以【以下 2 "私下"】事 或 【以下于 '1; 2; 3'】事 加$1[n]=n+"$1"去数；即 事 加1是「+1」 来合并

看滤序带叠 列行表组集
值受恒判换 对其函是试

- 恰如其份。相信任何功能点都有早知的倾注“份量”、愿为和其份的代码写恰好易用的函数库。绝句更注重广度而非深度，并希望知识的连系能让“深者”更简单、更本质
- 繁简明确。绝句认为知识只有久经工程和懒于互进，而无绝对的深广分界；只有不懂变通的嘴和审美人，会让优秀的电脑对“核心”词穷。为了1万人1万天的使用，多点费心与惊喜、少当脑热和装酷 并没错，哪怕没人用也应该！

最好的程序，在文字前出现。
没有无需语言的思想

“真理早于语言”其实很常见，最简如 x+1=y 就以无语序的方式表达增减与比率。绝句以 `同一去增(+1)令，拼(1)是2 且 拆(2)是1。` 实现类似。拆拼(cut cat) 亦称 into,from 但绝句未采用这“严谨而广泛”的用词。并非只为符合中文

若说代码易猜性， Str.into_int("1") 或 Str.into<Int>("1") 也巨优雅，可数据里双向的关系，比人际的双向难多了！

“思维不可独语自立”，语序对学习之重要常被忽视。记忆一堆首尾不接的词：`蚂蚁 书包 蛋糕 桌子 时钟 漏斗 巨石 水泥路 柏树` 如背单词般麻烦，但除了天赋者，这样也能容易背住：

蚂蚁背书包，包内装蛋糕（桌上） 旁放漏斗和时钟（在干嘛？），它被巨石绊倒在水泥路旁的柏树

看着答案出问题，你也能再出几道。 绝句以 `同一的数令，拆("12")是12 且 拼(100)的长是3。`  代替同无主语的 文去作数("5") ，给了程序员统一的观察方向；绝句的起名，是为大于单次动作的编程思维。这类改变虽是微妙的，集至语言却纹龙绣凤！


## 前进和转向

2048贪吃蛇对360度🐍的要求并不高，要能利用四向版的规则但不同时玩

滑移是靠 a.push(涂黑a[-1]+d); a[i]=a[i-1] (i=N-1 ~1); 涂白a.pop() 的右添&盖旧，要动画只需从a编号+SVG元素 类型的蛇身支持

角度(0~<1.0) 的输入相对于蛇头，流程和四向版一致；方法Vec计算

蛇头恒于屏幕中心可用插件锁定body内项相对XY中心偏移；可支持Qt网格UI

## 礼物

碰撞以 SVG.nearest() 和 sqrt(xx+yy) Vec距离算；礼物是N回合制、蛇上的函数，可inv(f)用于它蛇

许多游戏需带分布概率线。从1.0往下找 .7 就是70%，毕竟 random()<1.0

## 皮肤

皮肤对编号改元素样式。尾,头 传入其方向 而蛇身自尾从3数

有增长、缩短、反向 的礼物

