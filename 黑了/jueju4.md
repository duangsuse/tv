# 绝句 

我们从“描述法特点”上看绝句编程语言，不太纠结具体语法或词法、算式层次，而只谈绝句比 C-like “结构-过程式”语言添加的，现实应用需求。

绝句在大体似 Kotlin ，但俗套化了它的术语且 __系统的重设计__ 了它对 Java 开发流程的改进，目标是功能多而不乱。 若问题能从根源解决，过多工具就是浪费精力。

绝句的语言是：
- 不为编译器设计。形体的语言-简洁严谨的中文；灵魂的语言-清晰有序的汉语构造。
- 不为运行时设计。要体现语文之美。中华语文优先。能运行只是代码的底线
- 不为字面上专业。绝句不学院派也不软件工程派，它就是纯粹的编程-让人描述自己对事物套路的理解，不为“功能”而功能、不为“领域”而孤立造词

编程天然地具有抽象性，却只会帮助绝句或汉语落到实地，并把API们聚在一起。

我所理解编程的『专业主义』，5年来一直很虚无。学着玩过很多，却感觉啥也没学。 同学也能拼装许多功能，使用Py式的API；网友真做了些常见的app，而我反而像固步自封，只有小众的经验实验。从未写过业务

如今我见的编程，大概已经与代码API无关了。用Excel理解SQL或2D数组，IO,FFI库和UI的模式从顺序选择重复，最小3要素理解，我很少看文档和博文，以REPL熟悉领域必调的其他领域动名词、结构，自己做框架“绑定”。

其实我是害怕公共?重复代码的、其实即便知道做法于其他领域的联系，在算法和Web上，我的自信心始终像初见时那样，也不想踏实去完成什么；除非遇见了新的闪光点、能创造新可能的代码工具/lib。层叠的 (a,b)=>c 和手试调用渐渐变成「编程」的定义

>所谓『专业主义』，是那种明白自己在做的事，对大家有何时帮助而非身份、术语上区别的价值观。否定自己的见识，真的很需要勇气，尤其是从爱好者融变回普通人。 但忘却以往的“产出”，以语文重新来过，正是在追随绝句的终选吧。

## 主体布局：逗句何为

`对何<ETKV>为..其中` 的符号顺序是绝句的大结构“何为其中” `事= 和 造于，。` 小结构“逗句块”

static 成员都作同名例上的事量、文件级事量都作 `例 文件名Ju` 上的，且绝句认为，表达式(言)级 的优化是最重要的，句、词(class{}内)级复杂度应小于SQL

绝句十分推崇0开销的“能写代码的代码”(元编程,CodeGen) 和文档良好的约定俗成，反对手写单调零散的配置数据

书 引/pkg use 列表和 引单/use-1 是绝句多文件的组织法， `引单p a b c作e d作空` 即 `引p.a；引p.b；引p.c “事量或类型”e=c` ，无a..时是 import static

绝句也支持 `引单 绝句 「+」作空 「-」作「减」` 的记法重命名，尽管 前中后缀（负1 a到b 空!!），都不能重名 且只有后缀能在「的去」访问。全局「」事前缀；物里「」事中缀 「」量后缀

与Kt和C++的“运算符重载”不同，绝句的+-*/ 只是用『记法名』的事而不叫内定算符，也不像Hs那么混乱 靠数指定结合律。「记法」大中小 规定了无括号时谁包含（结合住）谁

大与(=)同级、中(+)同级、小(*)同级， 而前后缀更小些 是 `-(x !!)` ，包裹的是(的去[] )调用链，内层/左侧先算；而 `5次，。` `按钮被点击，` 这些都是()调用——出现逗句或「」都可能作为“函数块” `obj去受调用()` 尾参

咱使用 #cs 逆波兰算符重排 解决结合序，Lua同款的此法支持无括号 `0+ ~(1 + 2)` 和 `(0+~(1+2) )!?` ，方法是把 `1+2*3 = 1 2 3 * + ; 1*2+3=1 2 * 3 +` 遇+先输出*级更小更深 继续到读不出 `(x o x) o x` 链单项x 。 代码求值序会是左先内先

可以说相当多用且省写烂代码，所以咱的技术不是纯递归下降诶。绝句不想对“极致”情况做严苛的UB "Undef. Behavior" 定义，我建议别修改前后缀的优先级。好的语言不靠混乱的结合律组织起，绝句没有学Kt 把as as? 视作算符而有 `o去作否<T>` 就是避免这些问题

绝句的语法和文档是考虑了书写频率的，逐字句的推敲、每语境的假设。这点目前，没有一门编程语言做到，无论用户量和严谨性。因为他们设计API时甚至没配用例，因为大家甚至不知道发言时用辞规范就能“通过编译”

按道理说，过度使用任何为理论OK的语言，都能写出无意义的代码如 `Error().let{listOf(throw it?:return@let, 0+require(true) as Int) }` ，绝句设计者明白这些苗头都不算的特性以及Kt从Groovy等照般的堆砌性用词

但绝句不会为杜绝滥用刻意做任何努力。优美强大的语言天然就不给人冗文或炫技的动机，编译器是证明语言实质能力的招牌，需要显眼直白。文中一笔带过的知识，许多在 #cs 编译原理 有步调夸张的平替。你好奇的话可以脑中设段短数据模拟下，打断点看单步数据？

当你发现写的码不易看懂，首先要想的不是怎么做冗长，而要利用注释或函数签名写明步骤的性质；当你觉得代码太长，首先要搞清业务流程最少需要几个动名词，而不是[用单字符名字](#物理名)然后放着大结构的冗长引以为傲，这是绝句对代码风格的建议。

## 量[公式]

为方便多变量定义，`量k=1；变数k初1` 都有公式表写法： `量，k 1；s "2"。 变数，k 1。`
变任 (任=notype) 则依据初现的类型保存变量，以方便UI绑定等共享到{}外的需求，避免“XML+Java 声明两次”的低效注入

`全局表<文、词定义>` ，在进入{} 前保留旧定义，退出{} 时还原就实现了 __层叠作用域__(动态域)。 当然，变量都在函数头声明不大合理，解析期由var做 +1局部量 冲突报错，即“变量提升”。也有 `eval(e.opr,t.copy())` 和原型链：解释器开销大

v=0 的语义是 arg[j]或loc[j] =0 赋值栈上位置，再支持 just=a=>(_=>a) 有 up[i=1][j=0] 的upval闭包(内存对象,nonlocal可写, Java要求final)，即能词法域：声明/重赋值=指派位置/改写 需区分

名字在代词指向/子类型上的差异，称为 名/值多态

>多态polymorphism 即同名多义，可以让不同代码的命名更统一化、复用得更自然，C和VB里不存在。

绝句有3种多态：
- 子类型再定(即重写，很常见吧)
- 符号名再定(即重载。并称值/名再定)
- 隐式转换

## 事[公式]

`事pmix[abt]=(1-t)*a+t*b`  可对所有数值使用，[]内只能由默认值确定类型

`事toStr是 函1<数、文>，"$它"。` 能定义查重率高的事。 一般函<>值 由()时尽量内联的恒事 提供

除了给[公式]简写脱糖，事默认值、量读写 语法和 Kotlin 无二，但参数名可不写 ：数=此数 ，可变量< T> 取代了 by get/setValue

## [是公式]

绝句支持带校验的匹配解构，可匹配类型如 `类例 语义解构 俩项<任、任> 事 解构(：我)=令，此我的首=首。`。 绝句以『可变量』调用待解构类型的构造器

像 `o其令，[是x i]。  量o是x i 判o是，(a到b)。` ，并会内联 __赋值/测试已知量/赋默认值__ 的语句

一些语法像 若你、接迎你 由“人称”来提纲：
- 「我」亲-子类再定、扩充事量
- 「你」若判接迎 双主语事
- 「它」首参和「+1」「物量」 obj::去

>上文是绝句比 Kotlin 更新的点

## 绝句多态

物的「同名例」就是名字重载，`物 T(i：数) 为` 时既新建了类型T，又添加了变量T， T(0) 即 `T“同名例”去受调用(0)` 会new(内存分配+设初值)这个数据实例

物例,事量(=词)的 __既可未终定__ (impl impl? impl?? impl!) 在 `可定物 T.. 可定的事 f` 参数上可提供 `物 T1.. 既事 f` ，obj去f 就按其属于T,T1 操作不同。invoke"函数签名"需进行虚方法查找，即 Py int.mro() Ruby Float.ancestors JS ctor.prototype `__proto__` 链 C++[虚函数指针](https://www.blurredcode.com/2020/10/虚函数_虚表_多继承/)struct区(__vptr) Rust &dyn 双指针(fatPtr,内存片+虚表区)

>这也是 Java 应写属性 get/setter 的由来。性能和复用不懂取舍 全都想要全手写，就带来冗余代码和“规范”

词的 __公私族组内__ (same same-0 same-type same-pkg: public private protected internal) 可见性则有助于封装计算的内部细节

`类例 有序 数 为…… 类例 可闭 文件 为` 类例(typeclass, class-insta) 是种隐式转换。绝句里 我Self 是在 `T1: T` (继承和[其中]型参约束)时自动填写的型参，对照函数式语言 Haskell 的多态范式

```hs
class Inc t where --像 interface Inc<T>
  add1 :: t->t
  zero :: t

p2 ::(Inc t)=>  t->t
p2 x=add1 (add1 x)  --x变量就必有add1 等 (Inc t) 指明的操作存在，但并不是“关于” x 的，只是多了一堆全局函数
one=add1 zero

instance (Inc Int) where --实现了“Inc的子类型Int”
  add1 x=x+1
  zero=0
```

绝句同时接受继承与接口组合的复用模式，但仅把「类例」作为扩展性的补充 -在那之前允许为事量指定主语“我”

```
对何<我>类 Inc 为
  事 add1：我
  同名例：常量 “绝句的 samename-insta 比 companion object 多了一个类型约束，也方便序列化器-注册。”
  类 常量 为
    量 zero：我 “类型参数自动传递给内层 Inc.常量<我、...>。类似物事 的外部变量会闭包住”
类例 Inc 数 为
  事 add1=我+1
  同名例：常量 为
    量zero=0

for<^>class Inc:
  fun add1: ^
  samename insta: Kst
  class Kst:
    val zero: ^
class-insta Inc Int:
  fun add1=this+1
  samename insta :Kst:
    val zero=0

fun Inc.`+2`=add1.add1
for<T>(T:Inc) fun two=T.zero+2

‘Inc的扩展函数’
事 Inc.『+2』=add1“再”去add1

对何<T>(其中 T：Inc)
事 one=T的zero去add1 去作<T>

物 存啥 为
  公开的变 Inc? i=空
  事 Inc.设 为
    你的i=我 “双主语 你=我[^1]”

存啥()令，数的zero 去设 。的i

类例 语义隐转 文 为
  事 隐转：数=读数() “绝句借类例提供自定义隐转”
```

先提一句，`变Inc? i=晚置` 等“可变量” 在读写时做额外检查； `恒物 可变量、值最新、懒、同一、其一(与跨平台、试)、代者("恒事 受继承"生成继承 自既有对象)`  也能实现惊艳的0开销简写-不局限于编译期可用，像 行<可变量<数>>

有 `量，a 1；b 2。 变数，ac 1。` 值表缩写。`变任，a；b。` 首次赋值弱类型，则适合UI组件变量的情况。 绝句没有const“变量”，变与量(var val) 的写法完全不同，`量i=0；变数i初0` ，毕竟绝句仅提倡定义式的算法如 `(0~5)去看，。` ，一些语法只是为自举性(语言完整)保留

绝句认为 __“对象”是强类型、分段执行的函数值“闭包”__ ，更易继承修饰、多实例。『我』this只是其上名字 可直接用的参数0，(仅需编译期)作用域策略。

__物与事的最小构造，都是“函数签名”。__ 除 `物 杂组 公开的造于(某属性：值、变 a：值、b：值)`、`物 主 页面()` T1：T() 主构造器外，物内可有 `量/变 某名 =/读，。 写，。` 定义待设初值=，由其他 `造于，。 造于()=造于()` 和 `事 受造 “init{}”` 赋值。

>「造于」都是恒(编译期化简,常量折叠)的，便于检查是否初始化了自身所有量

绝句使用分层脱糖的代码生成，__主构造器、默认值参数 就是典型的语法糖__；实际上『函续』也完全是把事+执行指针 物化 为内存对象/可序列化 ，而 __储标例况物__ (data enum sealed annotation) 也都是 Java 既有的特殊class文件语法糖

匿名类型的obj `f(int x){ obj=new ArrayList(){{add(x)}} ; }` 在绝句只能是「物事」inner class 。物事可以内联，就像 `函0 函0<R> 函1<T、R>  函我1“~8”<M、R>` 与「事是」可用于简化“仅名词不同”性定义

「其中」内书级定义都可包含。不独立作用域：__量视为在函数体头部，事 物事强制内联。其他加在物的私下但不允许他事引用__ ；绝句的句级文法是很单纯的，若 判 空则  都能被表达式包含，特殊时只作语句 ；书级是 书引+别名+ `物 文件名Ju 为` 里的词级定义

- 储物 带自动 `显文 试等 摘要码`
- 例物 里只有 `名(构造参数)` 如 `例物 通讯号：例物自(编号=0x1f)`
- `况物 运算.. 物 加减：运算 物 乘除：运算` 的子类是确定的，「判属于」里不用否则
- `标物 A(：数)` 以 【A 1】 被附加在语法树上，常用于绝句恒 预处理、代码生成及 JVM反射。 绝句支持量和主构造器，因此标物、例物 不需要使用怪异的写法定义

### 注

- `对何<我>类Inc.. 类常量 量某：我` 在Inc里 "常量"引用的"我"直接变 Tparam[0] ，而 `同名例：常量` 的引用自动前置了<我> 于Targ。 物事也是自动将一些访问移到 vals[0] -双主语、自动前置外层“我[^1]” ；而函<>函我<> this or it 是可互换的-扩展函数 即如此编译
- 很像 `令 令为 其令 其令为` (apply run also let) it=当前this 或 this=arg0 的替换 `函2<ABC> = 函我1<A BC>`
- 其中物事 引用到局部变=新值 会整体装箱为读写 绝句.值Ref::的值
- C++ gcc/msvc/clang class-虚表 菱形继承等 __多继承__ 有固定的 virtual 组<函数指针>排序，而 `dynamic_cast<T1>(o)` 会调正o虚表到T1的章节 (类似Rust trait双指针)再传参，这些底层细节绝句从不考虑，也不赞同泛滥的“结构定义”暴露给“魔法师”
- int typeTag; union{A,B} 是强转的“严谨”版，而虚方法 实际令 不if(tag==TK_A) 就能 xx->run() ，易用性对大型程序是不可替代的。C慢慢变得只被拿来写低组合性-算法
- 多态是“脚本语言”流行(很少人觉得VB算吧?WScript-COM和VBA宏只算开发方法)的重要原因(比如不必写 int[] 不必void main 随处写class def)，严谨多态可以进一步降低解释器开销，尽管如numpy,OpenGL,SQLi ，语言特性并非性能瓶颈，优秀的多态方法，对开发各个方面都有利在千秋的作用。此作用并非短化语法/工具类能实现的

## 绝句数据

>数据类型与再组合是SQL,C,C++,Java语言 都必须设计的东西，但它对应用编程却意义不大(有目的才有数据)。绝句的 面向对象OOP 是 C struct+union,enum 的融合，尽管不太传统，绝句不重视数据上的新术语

“基元”上绝句和 Py 类似，无特殊语法。 __数字文真假空浮__ ，作<数1“byte”> 和「+」 这些是目标语言提供的，Int+Long=Long 宽化是 `【宽 8 0 256】计1` 生成隐转规则实现的

`对何<我数浮计N>` 皆自动填充的类型参数-类似template<>。默认 数=数4 浮=浮8 计=计4， `事 sq[x]=x*x/2` 里x仅能用默认值指明类型否则是对何N(所以绝句的[是公式]真挺不严谨的) ，绝句令 对何<数>事 能为 数1,2,4,8,N(BigInteger) 生成重载，避免拿 IntRange,IntArray 取代 值域<数> 组<数>

- `对何<> T1=T，。`  类型别名或『量纲类型』T1隐转T，T作T1(如在参数首次)执行检查。 自动填充和断止 不能有别名
- `物 _1 T`, `物 T_1：T` 子类型。T1有T所有事量，因此算式适用T=适用T1，即 T可为T1。 `对何<读T> P`, `P<T>可为P<T1> `；`对何<写T> P`, `P<T1>可为P<T>`。 `P<任>` 读T,任=值;写T,任=断止 且“仅读写”会禁用以T参数/T返回值 事量
- 空类型：T不收空、T?可为T/T?/空， `(T?)!! =T, (T?)?的去 T?空则(言/句) =可选链` [言]
- `对何<KV>(其中 V：可序) 物『表』；钱：表<文、数>` 恒事里是reified(有具体类型的)。 `P1<a1> 作P<a>` 型参 a[i]皆可为a1[i] 不报错
- 但一般只提供类型信息如 `行<数>::去添 作函1<数>` 。类型推导归一(并集)各位置T的实型(`符号["T"]的值 作类型`)，再检查，若必要事仍有读/写T的 则ok

“集合”上绝句有 __组行表集项(些许项)列__、 __看滤序带叠__ ，行<文>等默认是不可改的； `改，建行("xx")。` 即可删改， `复某行 去滤，。去看为「」` 则是绝句的坑点- 任何行的看为(函新<原类型>)、滤 默认是原地改写(0复制)，想保留旧值要加个“复”字

不过用数据列就OK了，和 `试做，抛下错("")。去取否(1)` 的物事内联不同， 列的0开销是基于编译期已知「函续内联」

>如此绝句完成了 表达式/语句 层的语义，已可支持许多单次单页工具，和各种强弱类型语言都差异不小。

CPU,MCU“芯片”以x86_64,ARM,MIPS 是汇编的解释器，每条指令能赋值/运算内存(mov,lea,sub rsp,addL rax 1L)和读写外设(int=syscall)、跳转执行位置，常数内联到指令-程序亦数据。对FPGA,IC开发程序是烧刻写死的，不像电脑手机有BIOS或BL从内核可单次选；而GPU,DSP 善于并行计算巨量散点，算力很重要，但完整学到编程 要理解Buffer 和内存对象/byteIO 的区别，切不可故弄玄虚、冗长堆砌

像 裸机的汇编API、 补码(2进制+符号位)、IEEE754和字节序  绝句不会涉及，但从电子工业来的它们，用“高级”语言也是可模拟的，希望大家有余力时真正的支持中国的计科 而非计科生意 知识“阶层”，并不是流量大用户多，或者常需说出口的热爱才有意义。

优秀的工程师比动物厉害的点只在于，在编写前所谓新事物在他脑中是既存长久了。  这种对所谓开发宠辱不惊的认识，是绝句作为语言最想囊括的。

- `重复回()` 照映出尾递归(tailrec)变跳回开头的本质，函1<函续<数>> +自动传尾操作 而非 suspend ()->Int 消减了许多“基元”概念和库
- `判你x属于，0~1、5~10， 否则，` 等格式替代switch、(q? a:b) 三目也莫得了，但 尝试接迎 句因为有 `试做，。` 封装 不算言级
- (1到2)其令，[是a b] a是1且b是2。 即 量arg0是a b ，和判x是 利用『语义解构』让 行<可变量> 等对应x的取值路径； 事(ab：俩<数>) 恒物内联，缓解了无Go式简短参数列表的问题
- 除了言句级语法简洁自由（基于汉语助词“的去”和逗句），事[公式] 量[公式] [是公式] 也为特殊用途(如大量UI件-变任)做了不刻意的简写；对AST结构的公开让绝句能辅助一些领域(如LaTeX)的表达

- 流控内联 停下 略过 回[^n] 内联=变写
- 物事内联 试，1。去取否? 恒物(f)
- 函续内联 去列去滤「>0」
- 恒算式与解构 序列化为嵌套调用、带判断[是公式]
- 物事>变[nonlocal] 到 值Ref() 、可变量 o,o.prop,o[k] 链
- (q?a:b) 等表达式外提到量 -左插条语句、重复若真化
- 令 其令 的主语/参0 互换
- 扩充事量通过 函我< A> 函读< A> 变量自动接受参0调用、“我”事量直接调， ::去 ::的 将参0作“我” 。函/我 唯一的不同

SSA 是和 AST 一样已解析过符号的计算图，每点固定输入 多份输出如 val a=1;a+a ，可参看 Blender节点。跳转 BasicBlock 做不完整"短路&& ||"计算，LLVM IRBuilder前端是SSA形式，更利于死代码/公子式消除 等编译优化、寄存器 指令选择等重要流程
phi 节点让SSA可以重赋值，如 x=(q?a:b) 里x的具体算式靠前BB 是a还是b决定，生成上就是让ab都去赋值一个量。以前 for(i=0~1) 即i=0;while(i++<2) 这样的跳转循环也i=phi。现在推荐创局部量，有 mem2reg
流控的实例，比如 If(cond,thenB,elseB) ，问cond 决定是否跳到else-当然可能是{} 。 之后的插入点是新BB -以前要if{}写完 才能“回填”}后地址，等同break 。IR使得3 br回填自动了

## 控制流内联、记法&书引

- `建表(1到2、3到4)试为空； 建行(2)试，不为空且我[0]>1。`
- 绝句的逗句块、为其中/= [段] 只基于句首的缩进划分{}段，逗句里逗句会建议换行 ，记法「」可以是合法名字(英文模式不多分词)或任意串 且可 `引单 绝句 「+」作空`
- 「」小中大 优先级，小=内含1 言单、中=加号内、大=等号内 。默认后缀小 前缀中 ，中~大依次： */ +- ~ 记法默认 空则 属存于 >< 即是 且 或 。没有与(=)同级的...号 仅有组拼接 arg()

`函续<R>` 就靠对象化令「事」可从调用栈撤下-恢复，并保留执行状态号

`(0~2)去看，f(它)。` 若f 只是调用say 之类的函数，能实现 "yield" 吗？显然不行，首先『看』必定是一下跑完全部数据，而不是在f(它) 时把执行权移交给f-何时恢复、next()几项 由f决定。JS使用func*里yield Promise 实现async ，就是通过 __编译期协程『函续』__

协程能有 onNext(item) 这样的列生成API。 JS 里你能让主线程滤出鼠标事件「秒数是偶数」，就需要任务级线程-协程(generator,Fiber 都是含上下级协程的接口)，任务、服务、软件3级线程 都有才利于编程

简单说，CPS 就是把整个调用树倒转一下，让后调者(setTimeout?)提供并“催促”整体返回值的计算 却不阻塞在调用栈 -和async或回调就是一回事。靠 Iterator.next 的 map() filter() 和它是兼容的，只是绝句比for(x of xs)yield x 等效 next()=xs[i++] 宽一步，『列』是编译期化简的-for if 等流控套路变 `去看 去滤` 调用链。

`事 f(“末尾”c：函续<R>)` c是在调用时自动填充的-调用方会被状态机化，类似for(i=0;;i++) 变数据 Iterator 。c() 可以重复多次，微妙的实现了 forEach 。List.迭代也必须状态机化？ 举个例子，用户click() 次显1项，包含 列() 的i++过程可能暂停

`列：CPS回调化域` ，意味着 `某列 去f1去f2 = 某列令，f1()；f2()。` ，f1的尾操作c只=f2 ，那 看为、滤 就能实现了。「带号」则使用列的私下变数，『行 叠』后不是针对单项的处理，咋办？

把行和列，“归纳”出单个值的，只能用 `建行(1、2)去文整，滤掉「<2」 。` 而非 `a去滤掉「<2」去文整` 的语序，后调用的可以像Iter 那种阻塞等待 f()是函续.已回 的停止，但写前头更中文些。

(a~b左“-1”)、a止b、 a~b升-1 带号 外其实往往不需要有计数变量，这样的列去“带号” 就是把它内部的量传递给尾操作。“尾随计算”不是() 后的代码都算，this不同代码就只在()调用时做1次

比如，`列自(0)「+1*2」 = 列<数>，变数 值初0；重复若真，值=值+1*2；交(值)。  。` 交()：断止?“必=空” 此处，只是过滤线的一部分，它之后 相同『列』上去看、去滤 都是其函续， 而 `叠自(0)「它+我」 ，去滤..` 内有 `我去流动去看..；回积` ，回积 就是流动() 完后执行。

比如，`async { defer(1000); say("") }` 里defer的函续是此async的{}

```
事 f(：函续<数>) 为
 f1() ”f作函续，自动被交给了f1！“；f2()；回1
```

f 里的「重复若」、交()+1 等给状态机化就很不易了，其目的是 f() 自己存包“函续”，其局部变量和执行指针，交给 f1(函续), f2(函续) ，等它们回调。 f1() 的实际返回值是什么？ 函续.已睡 、函续.已回

当然，f() 在 f1() 后是不需继续“阻塞”在调用栈(线程)的，「已回」代表 f1 已给程续填好返回值，所以无需保存闭包自睡。 否则是 给调度器+1任务，f 从调用栈撤下前，保留局部量。

若能在编译期确定函续的代码呢？  `列生(0)，交(它+1)。去看为，它+1。` 里首个『交』 只是赋值，好比 for(i=0;;)i=i+1  ，它有forEach,toList 的执行方法

```
物 列：CPS回调化域 为
  对何<AB>事 看为(f：函1<A、B>、c：续)=做<“我列作”B>，
    值=f(值)；c()
  事 滤(p：命题<A>、c：续)=做，
    若p(值)，c()。
  事 行(f：函我<列>) 为
    量a=改，建行<A>()。
    列()；f()；a去添(值)
```

for(i=0;;)i=(i+1+1)  ，去文 去行 带号 取前「次<2」 这样的自然就能写了

`(0~1)去滤 去看` 的 `if(p(x)) 内联点(f(x))` 也在有调度器才真传函续-`列生(0)「+1」 事 交(续)={“调度循环:”x=续(x)} ；滤(续) 交=if(p(x))续(x) ；看为(续)=续(f(x))`


啄木鸟、看！绿虚带碟

绝句，语文之美
语言之韵，绝句之律「绝地」
继承自过去，组合出未来  书引
既定事，可未终定！
组事为强族事，私下更为公开
汉语标点，成事有余。 华夏拾遗，丈量世界 “”和建组行表令
行云流水，表万物相连；序末俩头，看数浮何异 储标例况,数值,改/队栈
文心雕龙，函涵读写「语义类型：变量代理」
条条推敲，字字如金「记法」  试,次,~,止 ,到,令 被
对何项，是泛此型「对何<> 事量是」
重定义，万事万物 「值名多态」
事其中，何再物事？「匿名内部类」
类之例，无需多言。「类例-隐转、跨平台」
不严谨，愿重复回回虔诚「函数式」 重复有意义，不重复有语义
初造于你的(我[^0])，亲和作同一
若判不尝试，接迎无未来；试可令其续，空则仍有得「值<断止」 交集：成员集比A,B大
不为更新潮，只为更明确「恒 和其中推导」
你倾诉与我，这次不等待。换我构筑你「列」

# 绝句

事量： Java“类成员/字段” 绝句“动名词”
词：事量物类 等OOP概念
绝句不是仅支持简体中文的编程语言，尽管源于汉字。/后 是对应的西语写法

绝句有3种同名多义：值/名多态、类例多态（隐式转换） ；它让代码不同者用法统一化、复用更自然，C和VB里不支持。

- 事量再定 `例 某：Cmd页().. 既事 入口 为` 即重写 `@Override` 是基于 __值所属子级类型__，选择()调用代码
- `物.. 同名例 为` 即重载"overloads" 是基于函数签名选代码
- `类例 可序 数4` 为 `行<数4>` 提供了 `对何<T>(其中T：可序) “有类例 可序<T>” 事 行<T>.序：行<T>` 及0值 最大值等指定

绝句四则运算是依自动填充的型参 `对何<我> “同类型”我+我=我` 检查、`对何<数浮计N>` 自动生成重载的。 `类例 数4 数1` 就以 `物事 宽化：数4` 的语法提供了隐式宽化，而 `类例 受隐转 T ..事 化为：T1` 是此特性的根本用法

不定长参数则以 `组参<T> “配” arg(建组(1、2) 、 建组(3、4))` 的特殊数组标记

「」 /<b>``</b> 俩反引号
- `事「*」 .. 事「+」小 (另：数) .. 事「**」小右` 记法-结合律定义
- `叠(0、「+」)；看为(「+1」)` 记法引用
- `用户去滤，名字试存皆 「它为大写」。` 逗句的替代。「存皆」是记法 右不可带逗句
- `成员集去作<行<用户>>去看(用户「解绑」) ；关注者去滤(“我觉得”「可爱」)` 事量引用 Kt `User::ungroup, ::isCute`

『』 /<b>````</b> 俩“双反引号” 用于词的定义和指代
- 先说“俩反引号”，SQL常见 Kt罕见。本可直写的名字带空格 不利编程，故绝句采用bash里 $ <b>echo `ls # command`</b>
- 名在编译期被解析为 arg[0] 等确切引用，详见[词法作用域](#词法域)

类型 空/断止：
- `函1<组<文>>` 没有返回值（`函我1<>` 则把参0上词暴露在变量域），`函1<浮、浮>` 是数学绘图意义的函数，空Unit 不可以作任何参数
- 类型都属于『值』类型、断止属于任何类型 `值? < T < 断止`
- 空则 ?: break throw 这些都是句级，空则与若判类似，特定情况（右侧是言）可作言级

## 词法域

作用域，简化说变量域，是负责把名字对应到API（C++.h文件）/局部量位置 或[同名?](#恒类型)编译期类型的字典；词法域是“闭包 closure” 即函数值的实现方法：称作 Upval 的变量存储，就是在 new 对象()。

为方便多变量定义，`量k=1；变数k初1` 都有 量[公式]写法： `量，k 1；s "2"。 变数，k 1。`
变任 (任=notype) 则依据初现的类型保存变量，以方便UI绑定等共享到{}外的需求，避免“XML+Java 声明两次”的低效注入

`全局表<文、词定义>` ，在进入{} 前保留旧定义，退出{} 时还原就实现了 __层叠作用域__(动态域)。 当然，变量都在函数头声明不大合理，解析期由var做 +1局部量 冲突报错，即“变量提升”。也有 `eval(e.opr,t.copy())` 和原型链：解释器开销大

v=0 的语义是 arg[j]或loc[j] =0 赋值栈上位置，再支持 just=a=>(_=>a) 有 up[i=1][j=0] 的upval闭包(内存对象,nonlocal可写, Java要求final)，即能词法域：声明/重赋值=指派位置/改写 需区分

参数求值序，有传值/传名:懒算/传算式，常见于类C、函数式语言、预处理器，绝句只支持传值。但有 `可变量<T>` 多返回值

绝句的数值转换也很独特： `1+1L “事 数值<我>.「+」”` 的宽化不是基于 右Long>左Int 的优先级，而是对 `<我>` 数4=>数8 的隐转交集。绝句没有基元类型或算符，都只是类型和文法系统的可见成员

## 事的便利

`事pmix[abt]=(1-t)*a+t*b`  可对所有数值使用，事[公式]内只能由默认值确定类型

`事toStr是 函1<数、文>，"$它"。` 能定义查重率高的事。 一般函<>值 由()时尽量内联的恒事 提供

除了给[公式]简写脱糖，事具名/默认值、量读写 语法同Kt，但参数名可不写 `：数=此数` ，`可变量<T>` 取代了 by代理 get/setValue

绝句支持带校验的匹配解构，可匹配类型如 `类例 语义解构 俩项<任、任> 事 解构(：我)=令，此我的首=首。`。 绝句以『可变量』调用待解构类型的构造器

是[公式]像 `o其令，[是x i]。  量o是x i； 判o是，(a到b)。` ，并会内联 __赋值/测试已知量/赋默认值__ 的语句； 类别名[量纲] 可以指定带校验的类型

一些语法像 若你、接迎你 由“人称”来提纲：
- 「我」亲-子类再定、扩充事量
- 「你」若判接迎 双主语事。 `判你u的名令(搜查) 属/存于`
- 「它」字句指代函数式编程

>数据类型与再组合是SQL,C,C++,Java语言 都必须设计的东西，但它对应用编程却意义不大(有目的才有数据)。绝句的 面向对象OOP 是 C struct+union,enum 的融合，尽管不太传统，绝句不重视数据上的新术语

“基元”上绝句和 Py 类似，无特殊语法。 __数字文真假空浮__ ，作<数1“byte”> 和「+」 这些是目标语言提供的，Int+Long=Long 宽化是 `【宽 8 0 256】计1` 生成隐转规则实现的

`对何<我数浮计N>` 皆自动填充的类型参数-类似template<>。默认 数=数4 浮=浮8 计=计4， `事 sq[x]=x*x/2` 里x仅能用默认值指明类型否则是对何N(所以绝句的[是公式]真挺不严谨的) ，绝句令 对何<数>事 能为 数1,2,4,8,N(BigInteger) 生成重载，避免拿 IntRange,IntArray 取代 值域<数> 组<数>

## 休眠列

async编程是基于可挂起函数，即“传回调化”CPS 实现的。回调/@Override（注册1函数值）或链式Promise 都是基于事件队列 在分片段执行业务，它们没有编译器的“上下级协程”概念。

事f1 里写 f2()  时，f1要等待f2回它一个值，再接着去算。这占用了1线程:1调用栈 ，在单线UI(android.view,Web `prompt()` ) 里会造成假死，而多线程会带来薛定谔的异常，如今最易最快的解决方案是await，

即对 async f2 的调用导致自身暂停执行(yield)回主循环“调度器”，何时恢复？f2 将拿到 f1 里的 `函续<R>` (注册给如 `setTimeout`)，f1就变成在 f2,f3,.. 成功后，调用自有函续，这是基于“尾步骤”而非“栈等待”的函数种类，f1的函续是基于run()=when(状态号){..需函续调用间片段}实现。

Kt称其为 suspend fun ，绝句里尾参 `：函续<R>` 的函如 `函0<数> “之” 函1<函续<数>>` 的调用方变为状态机。是f2休眠，f1也随之休眠，否则直接继续算 的“被催促计算”，它和 `列<T>, JS func*` 有关？
>JS=ES6里 `r=f2();await r` 是yield回 __awaiter 让其帮忙 `r.next(继续自身)` ，显然开销更大（且只有yield一词定死了） 但async是IO密集 不是CPU密集，频次不高

在非函续事里调用 `delay(1秒)` 咋算返回值？命令行应用里 HTTP取()，main线程应while(!_sig)死循环等待。 那如何在delay后加delay，而不让main等待2次？ `绝句.『CPS环』` 决定了函续的内容不宽至调-被调方，同个主语上的函数体，就视为函续

若不知续，自身变状态机 接受回调参，否则，函续内联 ；绝句列和等调用栈的 Iterator.next 差别是很大的

因此，`a去滤，名[0]是'A'。去看，说(它的性别)。去行` 为a创建1列 开喂，其函续是 滤&看 连起来的串。 去行= `全局域令，结果=建行()。` ，重赋值不包含在函续

CPS环上的每个函都是『协程』，调用顺序指定了休眠-函续； `量 既有=列生(0)「+1」去看..`  后 `既有去看` 不会被唤醒，CPS环只是把函事串起来的主语。

## 恒类型

`对何<>` 往类型域引入新变量，变量的意义是各位置统一。

对于 `行<T>` 这些变量可为参数

- `物 _1 T`, `物 T_1：T` 子类型。T1有T所有事量，因此算式适用T=适用T1，即 T可为T1。 `对何<读T> P`, `P<T>可为P<T1> `；`对何<写T> P`, `P<T1>可为P<T>`。 `P<任>` 读T,任=值;写T,任=断止 且“仅读写”会禁用以T参数/T返回值 事量
- `对何<KV>(其中 V：可序) 物『表』； 钱：表<文、数>` 恒事里是reified(有具体类型的)。 `P1<a1> 作P<a>` 型参 a[i]皆可为a1[i] 不报错
- `对何<> T1=T，。`  类型别名或『量纲类型』T1隐转T，T作T1(如在参数首次)执行检查。 断止和自动填充 不可别名
- 空类型：T不收空、T?可为T/T?/空， `(T?)!! =T, (T?)?的去 T?空则(言/句) =可选链` [言]
- 但一般只提供类型信息如 `行<数>「添」 作函1<数>` 。类型推导归一(并集)各位置T的实型(`符号["T"]的值 作类型`)，再检查，若必要事仍有读/写T的 则ok

“集合”上绝句有 __组行表集项(些许项)列__、 __看滤序带叠__ ，行<文>等默认是不可改的； `改，建行("xx")。` 即可删改， `复某行 去滤，。去看为「」` 则是绝句的坑点- 任何行的看为(函新<原类型>)、滤 默认是原地改写(0复制)，想保留旧值要加个“复”字

不过用数据列就OK了，和 `试做，抛下错("")。去取否(1)` 的物事内联不同， 列的0开销是基于编译期已知「函续内联」

>如此绝句完成了 表达式/语句 层的语义，已可支持许多单次单页工具，和各种强弱类型语言都差异不小。

CPU,MCU“芯片”以x86_64,ARM,MIPS 是汇编的解释器，每条指令能赋值/运算内存(mov,lea,sub rsp,addL rax 1L)和读写外设(int=syscall)、跳转执行位置，常数内联到指令-程序亦数据。对FPGA,IC开发程序是烧刻写死的，不像电脑手机有BIOS或BL从内核可单次选；而GPU,DSP 善于并行计算巨量散点，算力很重要，但完整学到编程 要理解Buffer 和内存对象/byteIO 的区别，切不可故弄玄虚、冗长堆砌

像 裸机的汇编API、 补码(2进制+符号位)、IEEE754和字节序  绝句不会涉及，但从电子工业来的它们，用“高级”语言也是可模拟的，希望大家有余力时真正的支持中国的计科 而非计科生意 知识“阶层”，并不是流量大用户多，或者常需说出口的热爱才有意义。

优秀的工程师比动物厉害的点只在于，在编写前所谓新事物在他脑中是既存长久了。  这种对所谓开发宠辱不惊的认识，是绝句作为语言最想囊括的。

- `重复回()` 照映出尾递归(tailrec)变跳回开头的本质，函1<函续<数>> +自动传尾操作 而非 suspend ()->Int 消减了许多“基元”概念和库
- `判你x属于，0~1、5~10， 否则，` 等格式替代switch、(q? a:b) 三目也莫得了，但 尝试接迎 句因为有 `试做，。` 封装 不算言级
- (1到2)其令，[是a b] a是1且b是2。 即 量arg0是a b ，和判x是 利用『语义解构』让 行<可变量> 等对应x的取值路径； 事(ab：俩<数>) 恒物内联，缓解了无Go式简短参数列表的问题
- 除了言句级语法简洁自由（基于汉语助词“的去”和逗句），事[公式] 量[公式] [是公式] 也为特殊用途(如大量UI件-变任)做了不刻意的简写；对AST结构的公开让绝句能辅助一些领域(如LaTeX)的表达

- 流控内联 停下 略过 回[^n] 内联=变写
- 物事内联 试，1。去取否? 恒物(f)
- 函续内联 去列去滤「>0」
- 恒算式与解构 序列化为嵌套调用、带判断[是公式]
- 物事>变[nonlocal] 到 值Ref() 、可变量 o,o.prop,o[k] 链
- (q?a:b) 等表达式外提到量 -左插条语句、重复若真化
- 令 其令 的主语/参0 互换
- 扩充事量通过 函我< A> 函读< A> 变量自动接受参0调用、“我”事量直接调， ::去 ::的 将参0作“我” 。函/我 唯一的不同

#cs SSA 是和 AST 一样已解析过符号的计算图，每点固定输入 多份输出如 val a=1;a+a ，可参看 Blender节点。跳转 BasicBlock 做不完整"短路&& ||"计算，LLVM IRBuilder前端是SSA形式，更利于死代码/公子式消除 等编译优化、寄存器 指令选择等重要流程
phi 节点让SSA可以重赋值，如 x=(q?a:b) 里x的具体算式靠前BB 是a还是b决定，生成上就是让ab都去赋值一个量。以前 for(i=0~1) 即i=0;while(i++<2) 这样的跳转循环也i=phi。现在推荐创局部量，有 mem2reg
流控的实例，比如 If(cond,thenB,elseB) ，问cond 决定是否跳到else-当然可能是{} 。 之后的插入点是新BB -以前要if{}写完 才能“回填”}后地址，等同break 。IR使得3 br回填自动了




协程coroutine 在绝句被设计为一串互调的函数，咱利用状态机让串内每函可暂从调用栈撤下，待事件时恢复；每函休眠时会交出 `函续<R>` 供恢复-调签名是 `函1<函续<R>>` 对应 `函0<R>` ，总之，这是不同于线程栈-等待的 ()调用策略

`函<> 函我<>` 尾部未填写的类型算作void，『断止』则标示函数永远 throw 或 System.exit(0) 不返回值，而协程是 `函1<函续<R>、协程.态 “睡/结” >` 这个意思

函续通常自动提供，调用会给入函续并休眠自己，绝句没有Scope 这样的概念，启动任务线程 `launch {}` 在非协程里函续自动runBlocking，若有 `launch{launch{}}` 而不想等待内部协程，提供空函续即可。

绝句列类似 Py,Ruby,Kt 流，基于 yield Iterator

```
物 列：迭<T> 为
  变真假 hasNext 私下的写
  事 next：T 为
    c()；回值

  造于(交项：函我1<列<T>、函续>)，
    交项，“最后” hasNext=假。
  私下的变函续 c
  事 交(项：T、：函续) 为
    值=项；c=此函续 “保存了暂停 交() 的点”

  事 滤(p：命题<T>)=列，
    你去看，
      若p(它)，交(它)。
  事 看(f：函2<T、函续>、：函续) 为
    重复若hasNext，f(next())。
  事 看=已优化("列看内联")
```
