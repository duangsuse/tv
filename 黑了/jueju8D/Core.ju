pkg jueju

for<T>fun `*`3(args:Seq)=Ary().as<Args>
for<T>fun T?.`?` :T? =VMOp
for<T>eval fun T?.`!!` :T = this ?: lets: throw ErrNull(asE.Str)
@_("空则")
for<T>fun T?.`?:`0(:Fn0<T>) = (this!=NO).way(as<T>,fn)

@Namely("i")
for<> Idx=Cnt4
for<> Int=Int4 //IntN in Py
for<> Rat=Rat8
for<> Cnt=Cnt4

for<T> eval fun Bool.way(Y:Fn0<T>, N:Fn0<T>) = if this: Y()
  else: N() //q? a:b
eval fun `!`(:Bool)=q.flip
/** $Yes or $No, `$Y|sayYes; $N&sayYes` does nothing(calc [byLazy]). [Flag],[Vec_Bool] */
/**: 真或假，`真或做；假且做` 啥都不做([值懒]算)。[旗],[向量_真假] */
@Namely("q")
thing Bool were CanSort,NumLike.Flip:
  fun `&`3(:Bool):Bool=VMOp
  fun `|`3(:Bool):Bool=VMOp
  !fun `==`3(:Bool):Bool
  !fun Str=way("$Y","$N")
  fun xor(:Bool):Bool=VMOp
  samename-insta:
    !val normalOrd get:VMOp

/** Any?=Any+NO: `null`, nullptr or None
  Any value(!=null) provided to fun-[Args]ument and val/vars, maybe const literal, system registry or user input.
  expr and its subexpr/vars comes with 1 value&type. types are implicitly `:(extends) Any` and canBe(it's subtype) [Break] */
/**:
  值?=值+空: `null`, nullptr 或 None
  事参数和变量接受的任意(非空)值。可能由常量字面、系统登记或人类输入。
  算式及其子式/单量“的去”都有1值和其类型。任何物类隐式 `：(属于) 值` 且可为(即:有子类) [断止] */ 
impl? thing Any:
  /** Test content equality(provided any!=NO), see [CanSort]: math rules, [Vars]: memAddr equality */
  /**: 实现内容相等性，任何值!=空。数学性质见[可序], 内存地址相等见[变量集] */
  /** Brief obj(&inners), rarely used outside debugging(&[StrBuild]). Add :[Vars] for load/dump. precedence(0~3):'*', +, ~ ><, == & | */
  /**: 简述对象和其内项数据，很少在调试（和[文拼]）外有用。导入导出请加 :[Vars]
    算符优先级:小'*' 中+ 大>< 超大'是' 且 或。默认“中” 前后缀默认“小”且后=前-1=中-2 ，玩法: `1~2存于(3~4)`  */
  @_("是") @CopyInfix(_("不是 en !="))
  impl? fun `==`(:This):Bool = VMOp
  impl? fun Str:Str = VMOp
  /** Pregrouping key for optimizing [==] lookup, must pure(equals->sameHash)
    or [KV.get] becomes UB. Hashes are sparse like pseudo-[Random] */
  /**: 优化“靠 [==] 查表”的预分组线索，必须纯（相等->散列相同）
    否则 [表.取] bug。相邻值散列不扎堆这点像伪[随机] 但并非加解密 "[同一]" */
  impl? fun Hash:Int = VMOp

/** `Any` canBe `Str,Int,Ary`,. (`"" is Any`), if provided value implements([is]) [T] e.g. Str&you can't change type signature(e.g. Any), cast `any.as<Str>` is efficient
  for `int1.as<Int4>` widen, `int.as<Int1>` lose precision it's C-like(& lit-int=>float,Char!=Int2). for JVM APIs autoboxing `Ary<Int> == int[]` supported (slower). __"as" is retType-overloaded__ */
/** 值可为文,数,组,. 比如 `"" 属于 值`。若提供的值有实现([is]) [T] 如=[文]，且你不能精确化类型签名如[值]，强转 `此值去作<文>` 不慢
  在数1作数4 宽化、数4作数1 精度丢失 如同C语言族（但只有常量int=>float、[字]!=[数2]）。对JVM接口，支持略慢自动装箱如 `组<数> == int[]`。__此方法以返回类型重载__ */
for<T> eval fun Any?.as: T = VMOp
for<T> fun Any.asMay = is<T>.way(`as<T>`, NO)

/** Check if typeof this inherits [T], or have `class-insta T This`. `class: samename-insta where XX: ` inherits, like [Empty]
  Such [Bool] infix supports `!is` and `when x is:` syntax. "type" is statically(compiler-time) known part whatever (func)value, or "def" order is, faster&safer */
/** 检查值的类型是否继承[T]全员，或有 `我类型.作：T`。 类的无名同名例会被继承如 [值空]。
  有 `不属于` 和 `判x属于，` 语法。值的类型/型参静态(编译时)已知，无论值由谁何时提供，比弱类型快速而安全  */
@_("属于")
for<T> eval fun Any?.`is`2: Bool = VMOp
@_("存于")
for<T> fun T.`in`2(set:Seq<T>) = set.contains(this)
//[CoreRange]: +- ><



@BelowFor("`({'T'}+('B'~'H'))  (Fold.From("",{+it}).eachStep)`")
for<$1R> class Fn$0:
  fun wasCall(): R

@Below(8, "@jueju.words.JuFun")
// [*-* ~](~  ^_^)
for<AR>Fun1=Fn1<A>
for<ATR>Fun2=Fn2<A,T>
for<ATBR>Fun3=Fn3<A,T,B>
for<ATBCR>Fun4=Fn4<A,T,B,C>
for<ATBCDR>Fun5=Fn5<A,T,B,C,D>
for<ATBCDER>Fun6=Fn6<A,T,B,C,D,E>
for<ATBCDEFR>Fun7=Fn7<A,T,B,C,D,E,F>
for<ATBCDEFGR>Fun8=Fn8<A,T,B,C,D,E,F,G>



for<T> FnNew=Fn1<T,T>
@Namely("p")for<T> FnTest=Fn1<T,Bool>
@Namely("c")for<R> FnCont=Fn1<R>
for<T> FnSort=Fn2<T,T,Sort>

for<T> T.as=FnTest: you==this
for<T> T.as=Fn0: this


/** May asList(for int[] do copy) to `Ary<T>`. On JVM [get] returns `int`, not `Integer` boxed,
  `Ary<Int>` can't do this for it can be a [Line]. Supports JVM `Object[]`, or [T]: Int,. for typed array */
for<T> eval thing AryN where Ary<T>
/** Compile-time known expr list, use it for const expansion or destruct */
for<T> eval thing Args where Ary<T>
/** `fun pair(:ArgsName<Str, 2 to "ab"> )` */
for<TK>(K: eval, K: Pair<Int,Str>) eval thing ArgsName where Args<T>

for<E This>(E:Flag.Bit) thing Flag(var bits=Cnt.ALL_ONE.bits) were Empty:
  fun set(:E,q:Bool)=bits set: q.way(it+e, it-e)
  fun get(:E)=bits&e.mask

  for<This>thing Bit(i,name,mask=0b1.bits(+i)) were Enum:
    fun `+`(:This)=Bit(i,name+you.name,mask+you.mask)
  samename-insta:
    !fun empty=Flag(0)



/**: `物事 JVM.作：独有实现` juec可见全部语言内类型签名，但只生成当前平台的调用。其内物事受调用()能覆盖 `终定` 成员以提供造于()和常量等 继承时合并代码 */
class Platform

/** `Collection<E>` = [Sized]+[CanSee], no more `Iterable` s cause `impl fun ` [see] implies async Seq */
for<T> class CanSee where CanSeeInf:
  for<R> fun seen(to=rw{lineOf<R>()},op: Fun1<T,R>) = to.let { you.see: add(it.op()) }
  for<R> fun seenNot(no:R, to=rw{lineOf<R>()}, op: Fun1<T,R>)
  fun contains(x: T)
  fun contains(xs: Seq<T>) = xs.all: it in this

/** like [Seq] but optimized to [RwLine.add], AND adds caller to [Seq] */
for<T> fun SLine(:Fun1<AddScope>) = rw{lineOf().as<AddScope>} let: fn()
where:
  for<T> AddScope=RwLine`$N`
  for<T> fun AddScope.got(x:T)=as<RwLine> add x

fun collapse(editorOpen=0, :Fn0):
  if editorOpen: fn()
fun TODO(reason="having a rest") were Break:
  throw ErrNoImpl(reason)
fun error(msg:Str): Break = throw ErrVars(msg)

fun require(q:Bool, msgr: Fn0<Str>):
  if !q: throw ErrArg(msgr())
for<T> fun requireNot(it: T?, value: T?, msgr: Fn0<Str>): T
for<T> fun requireNotNO

/** See [assert] for testing */
fun check(q:Bool, msgr: Fn0<Str>)
for<T> fun checkNot(it: T?, value: T?, msgr: Fn0<Str>): T

for<R> fun trys(:Fn0<R>) = try { Res.Ok(fn()) } catch(CanThrow) { Res.Err(you) }

