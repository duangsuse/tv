pkg jueju
use1 NumLike

for<T>(T:Flip) fun `-`(:T)=it.flip
for<T>(T:Flip) fun `+`(:T)=it
for<T>(T:Empty)fun empty=T.empty
for<T>(T:Sum) fun Seq<T>.sum=this(Fold.From(T.empty, `+`))
for<T>(T:Sum) fun Cnt.`times`0(repeat:T)=lets:
  var T x=from
  times{x=x+x};x

thing NumLike:
  /** `-(-it)==it` */
  for<This>class Flip:
    fun flip: This
  for<This>class Sum were Empty:
    fun `+`1(:This)
  /** use `val: author now.User; n 0` for (Num) default init */
  for<This>class Empty:
    same-insta:
      fun empty: This
  for<This>class Sibling:
    val inc:This
    val dec:This
  for<This>class Num Empty:
    val rn: ClosedRange<This>
    val bitsFull:This

  @_("分量同算")
  for<This T>class CalcEachIdx were Num,Sized,*:
    fun get(:Idx): Num<T>
    eval fun wasGet(k:Str): Var<num<T,k> <T>>
  where:
    eval fun num(:Type, k:Str)=when k.size:
      1: error("no $k in $type")
      2: Vec2; 3: Vec3; 4: Vec4
      else: VecN

for<This>class Num were Sum,Flip,Sibling,NumEmpty:
  @Below(3,'_(:This):This')
  fun `*`0=VMOp
  fun `/`0=VMOp
  /** So use `val n==x**2` for sqrt, `val n==2**k` for log2 */
  fun `**`0R=Pow(this,you)
  fun `-`1=+(-you)

  for<This>thing-fun rem:
    fun wasCall(:This):This=VMOp
    fun `/`(:This)=this(you) to this[^1]/you

  /** Numerics represent by 2+4+8+.. Unlike [Num], `a&-b == a-b; a+(2a-a)==2a; a(shl=0)+a==a; a.xor(a)==0`, for ushr: [Cnt] */
  for<This>class Bit were Flip,Sum:
    fun `&`(:This)
    fun `-`(:This)=this&-you
    fun xor(:This)
    fun wasCall(shl:Int)

for<N> Pow=PairOf<N>
for<N> Pow.as:N=Vec1.pow(A,B)
for<N> thing-fun Pow<N,Var<N>>.as were WasDestruct:
  fun eq(:N):
    B.v=Vec1 lets: log(A)/log(n)
for<N> thing-fun Pow<Var<N>,N>.as were WasDestruct:
  fun eq(:N):
    A.v=Vec1 lets: sqrt(you,B)






for<This> thing Int:

class Rat
  val `finite`
  val `NaN`
  samename-insta:


for<> Int1 = Int`$N`
for<> Int2 = Int`$N`

@BelowFor("4 8 N", 2+2)
fun Int1.as:Int$1
fun Int2.as:Int$1
fun Cnt1.as:Int$1
fun Cnt2.as:Int$1

@BelowFor("8 N", 1+1)
fun Int4.as:Int$1
fun Cnt4.as:Int$1
@BelowFor("I C", 1)
fun $1nt8.as:$1ntN

@BelowFor("8 N")
fun Rat4.as:Rat$1
fun Rat8.as:RatN





for<> Deg=Rat `in 0~<1`
for<N> eval val N.`deg`=Num.deg.cat(this)

/** mutable point with angle [r] and magnitude [l] */
for<N> thing Vec2(x:N,y:N) were CalcEachIdx:
  var Deg r
  var Rat l
  /** weighted sum */
  fun `·`(:Vec2)=x*you.x+y*you.y
  same-pkg var rVec get:Vec2 
for<N> thing Vec3(x:N,y:N,z:N) were CalcEachIdx:
  fun cross(:Vec3)
for<N> thing Vec4(R:N,G:N,B:N,A:N=1) were CalcEachIdx:

for<N> thing VecN(it:Args<N>) were CalcEachIdx:
  fun get(:Line<Idx>)
  fun set(:Line<Idx>)

/** 
Vectors are e.g. [Vec2](x,y) points, Vec1 capture e.g. `Var<Int>` but just adds math funs to it:
(hyperbolic)trigonometric, rounding [saw], [sign] and [abs]olute value. For power&it's exponents, logarithmic see [exp1]
 */
for<N> thing Vec1(r:Deg, yaxis=$N)
  fun abs = let: sign=+1
  val sign get: (n==0).way(0, `(n>0).way(+1,-1)`)
    set: v=Vec1(you).sign*abs()
  /** make this [n]-divisable. see [saw] */
  fun sawStep(:N): N
  samename-insta Math:
    @BelowFor("4 8", 3)
    /** support [bOvf] negate. Test `x in Int.range` for safe converts */
    fun addExact(a:Int$1, bOvf:Int$1) = a+bOvf
    fun mulExact(a:Int$1, bOvf:Int$1) = a*bOvf
    /** floor, round, ceil. normal `a/b==trunc(a/b)` round to 0 */
    fun saw$1(:Rat$1, closer=-1): Int$1
    /** Move point to leftmost, find precision `1/Math.ulp(1)=1e7`. ignore sign, NaN */
    fun ulp(:Rat$1) = VMOp.xx
    /** `nextIn(10~+Inf)` */
    fun nextIn(:Range<Rat$1>) = VMOp.xx
    fun getExp(:Rat$1)
    fun IEEErem(a:Rat,b:Rat): Rat
    /** expm1, ln1p, for [E]. Use `8.itLet{[==2**x]x}` for log2(,log10) */
    val exp1=Equiv(`E**it`, `Math.log(it)`).plus(-1)
    /** JDK:[scalb] */
    fun mul2k(n:Rat, k:Rat) = n*2**k
    eval val PI=3.1415926535897931; /** `ln(E)=1,ln=logE.log=log10` */ eval val E=2.7182818284590451
    /** `180/360*DEG` */
    val radians = Equiv.ratio(DEG/360)
    /** [a] for arc, [h] for hyperbolic */
    enum-thing AngularFn:
      Sin; Cos; Tan
    /** `Vec1(.5turn)==Vec1(Cos,PI)`, JDK:[atan2] `Vec2(x,y).r` in 0~1turn. math atan^2 in 0~2 */
    for<N> fun wasCall(:AngularFn, :N)
    /** `sin(arcsin x)==x`  */
    for<N> fun a(:AngularFn, :N):N
    /** JDK:[hypot] `sqrt(xx+yy)`  done with `Vec2(x,y).l` */
    fun<N> fun h(:AngularFn, :N): N



