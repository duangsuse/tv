<input id=eTxt>以<input size=3 id=eK>
<div class=SQC><table></table>
<pre id=SQCo>SQL</pre>
<textarea id=SQC placeholder="SQ糖代码"></textarea>
</div>
<script>doc=document
dbSql=(k,o=openDatabase(k,0,k,1024*4))=>(s,ok)=>o.transaction(x=> x.executeSql(s,[], (_,r)=>ok(r),(_,ex)=>alert(ex.message)) )
onload=()=>{
试析={有:[_RE(/\d+.\d*/), {数目:_1("奥特光线","奥利奥", ["伽马",_RE(/./),"人",(_,x,__)=>x], _N(_RE(/\d+/),'+') ), 阿巴:_N(_RE(/[啊波吃的]/) ) ,['']:just('_1和{}必须穷举')},Array],
取:[P.f(s=>s(-1), x=>+x+1), P.f(_RE(/\d+/) ,s=>[...s].reduce((a,b)=>a+(+b) ,0) ), (a,b)=>`+首${a} 尾和${b}`],
没有:just("可以"), 派:Math.PI,['']:just("不行")}
eK.onchange=()=>试析=this[eK.value]
eTxt.onchange=()=>console.log(P.喂(试析, eTxt.value) )
P受用();P查询(); eDB("pre:not(#SQCo),pre>code")
doc.querySelector("code").innerText=留loc()
}

eDB=css=>{
SQC.onchange=()=>{set(SQCo,"p", P.喂(SQ糖,SQC.value+'\0')); getSelection().selectAllChildren(SQCo);doc.execCommand("copy") } //emm之前还以为只有blur
let f=dbSql("a"),e=SQC.parentNode,eC,tbl; on("click",css, eHid(e,E=>{SQC.value=E.innerText;SQC.onchange()} ) )(doc.body)

on("click","p", ev=>f((eC=ev.target).innerText,tbl) )(e)
tbl=({rows:a,rowsAffected:num})=>{eC.before(el("span",`*${n(a)}+`,num)); if(n(a)){let k=Object.keys(a[0]),th={},x;for(x of k)th[x]=x;
  set(e.firstChild,NO, [th,...a].map(r=>set(el("tr"),"td", k.map(k=>r[k] )) ) )}}
}

set=(ul,li,a)=>{if(li)a.forEach((x,i)=>a[i]=el(li,x)); ul.innerHTML=``;return el(ul,...a) }
eHid=(e,f)=>{
let c=e.style,ct=k=>e.classList.toggle(k);
ct("gone");e.onblur=()=>{ct("show");e.addEventListener("transitionend",()=>ct("gone"),{once:$Y}) }
return ev=>{if(e.classList.contains("gone")){f(ev.target); Object.assign(c,{left:ev.pageX,top:ev.pageY});}  e.onblur()}
}

el=(k/*tag*/,...fe)=>{if(!k.nodeType)k=doc.createElement(k);  while(typeof fe=="function")fe.shift()(k) ;for(let e of fe)k.append(e) ;return k}
on=(k,css,f)=>e=>e.addEventListener(k, ev=>{if(ev.target.matches(css))f(ev)})
</script>
<style>
.SQC{    border: 2px solid gray; position:absolute; background:whitesmoke;
    margin: 0.5em; opacity:0;
    transition: .5s opacity cubic-bezier(0.42, 0.09, 0, 1.01); max-width:120vw; }
.show{opacity:1}.gone{pointer-events:none}
#SQC{width:100%}
#SQCo>p::after{content:';'}
#SQCo>p:hover{background:yellowgreen}
#SQCo span{float:right;background:skyblue; border-left: 2px solid red;}

.SQC table>tr:first-child {
    background: yellow;
    font-size: 1.4em;}
.SQC tr:hover {background: aqua;}
.SQC td:hover {background: pink;}

blockquote {
    margin: 6px;
    padding: 0 6px;
    border-left: 3px solid red;
}
pre {
    background: #f7f7a7;
    border-radius: 2px;
    padding: 8px;
}
</style>
<script>
nop=x=>x //(var)char:20,255 ;B/CLOB same to NONE, real/double/numeric alike, Time can be text/int(UNIX)/real
词={数:"integer",浮顶精:"decimal",文:"char",定:"enum", 改文:"varchar",长文:"text", 数1:"tinyint",数2:"smallint",数4:"int",浮:"real",真假:"bit",时间:"datetime",日期:"date",
fl:{主键:"primary key",自增:"autoincrement",正:"unsigned",唯一:"unique",当:"on",删:"delete",新:"update",跟着:"cascade"},名:{无:"\0",空:"\0NULL",$名:nop,$取:(S,g,c)=>/ join/.test(c)?c+S+g : S+g+c ,$无:nop},
表:"请建表",问k:[],事:{},//新建(默认),新 和 取某表(x=?0) 参名于$函数=语句
fn:{逗:'+', 计:"count",拼组:"group_concat",拼文:"concat",求和:"sum",求均:"avg",极小:"min",极大:"max", 正:"abs",整低:"floor",整取:"round",整高:"ceil"}}
建典=(k,v)=>{let t={};ss(v).forEach((x,i)=>t[k[i]]=x); return t}

P查询=()=>{
let 查=(k,v,t=建典(k,v))=> s=>s(1) in t? t[s(-1)]:NO, 字=(k,v,f)=>KV(建典(k,v)).forEach(f),//L100
词A=查("库表暂","database table view"),词S=查("小大","Asc Desc"),

有=(a,x)=>P.f(行(x) ,k=>k.map(x=>`create ${a} `+x) ),
删=q=>[词A,行(名), (a,k)=>k.map(x=>`DROP ${a} `+x+q)],
列域=括原文, 加=(...p)=>_1(p,just('')),

str=JSON.stringify,KV=Object.entries, q$=s=>s[0]=='$',尾=s=>s.slice(1),  orLen=(s,i)=>i==-1?n(s):i,
简写=nop, qstr=v=>v[0]=="\0"? (n(v)!=1?尾(v):"default") : str(v),
tupV=a=>`(${J(简写(a), qstr)})`,//别 新建人 名="某" ;新建(名)人("小明")
tupU=t=>J(t, ([k,v])=>{填问(v,k); return `${k}=${qstr(v)}`}),
tupC=a=>J(a, ([k,s])=>k+`  `+(q$(s)?词[k]+尾(s) :s)),

填问=(v,k)=>{if(typeof v=="string"){let m;if(m=/^\0\?(\d+)/.exec(v))词.问k[m[1]]=k }},
fn表=KV(词.fn),译函=s=>{let 调=fn表.find(e=>s.startsWith(e[0])),f=([k,v],I)=>v+`(${s.slice(n(k),I).replaceAll(词.fn.逗,',')})`+s.slice(I+1); return (NO==调)?s: f(调,orLen(s,s.lastIndexOf('|')))},
f简=o=>a=>{for(let[k,v]of o)词.名[k](a,v) ;return a},
外键=(k,s)=>为典(s)? ` references ${k}(${s.find(([k,v])=>/ primary key/.test(v))[0]})`:s

为典=o=>Array.isArray(o[0]),
标=(A,f)=>(k,_,v)=>{f(k,v);return `/*${A} ${k}=${v}*/`},
分页=加('页每',数值,_1(数值,just(0)),(_,a,b)=>` limit ${a} offset ${b}`)

SQ增fn表=o=>{fn表=KV(Object.assign(词.fn,o))}

类型=[名,括原文, _1('?',just('  not null')),加("或",值单, (_,v)=>` default `+str(v)), _1(_N(名),just([])),
  (k,arg,nul,dv,fl)=>外键(k,译(k,词))+arg+尾(nul)+dv +' '+J(fl,x=>译(x,词.fl), " ") ]
结构=括(行([名k,_1(类型,just('$')), Array]))
名构=[名k,结构, (k,ty)=>{词[k]=ty;词.表=k; return k+'('+tupC(ty)+')' } ]

语句={
有库:有("database",名),有表:有("table",名构),
有删:删(" if not exists"),["有删!"]:删(''),
有改:[词A, 名,_Q(_RE(/[+-]?/)),_Q(文),结构 ,(a,k,q,co,c)=>`alter ${a} ${k} ${q=='+'?"ADD":q=='-'?"DROP":"change"} ${co} ${tupC([c[0] ]).replace('__',' ')}`],

新删:[选, ([s,S])=>`DELETE from `+s+S],
新建:[列域,名k,_N(值), (k,s,v)=>{简写=nop;return `insert into ${s} ${k}values `+(n(v)<3?"":"\n")+J_if(v,o=>为典(o)?(简写=f简(o)):NO  ,tupV, ",\n") }],
新:[值,选,_Q(文), (vs,[s,S],co)=>{
  if(!为典(vs)){let k=[];vs.forEach((v,i)=>{if(v!="\0")k.push([ 词[s] [i][0],v ]) }) ;vs=k}
  if(!S.endsWith("(默认)"))return `update ${s} set ${tupU(vs)} `+S+co //新建为简写.仅选新有?参 L46
  vs.forEach(([k,v])=> 填问(v,k))
  return `insert into ${s} (${J(vs,x=>x[0])})values (${J(vs,x=>qstr(x[1]) )})`+co
}],
取:[加('不重',_=>` distinct `),列域,选,
  加('序',词S,名k,(_,a,k)=>` order by ${k} ${a}`),加('分组',名k, (_,k)=>` group by `+k),
  分页,加(文,s=>`/**/`+s),  (ds,k,[s,S],ord,grp,pg,co)=>`select${ds}${k?' '+J(k.slice(1,-1).split(',') ,译函) :'*'} `+
    (s=="无"?'':`from ${q$(s)?词.表:s}`) +词.名.$取( q$(s)?`${S.slice(0,-1)}(${词.名[s]}))`:S, grp+ord+pg,co)],

简写:[名,'=',文, 标('有',(k,js)=>{词.名[k]=q$(k)?this.eval(js): Function('a,j',js)} )],
类型默认:P.f(结构, ty=>ty.forEach(([k,t])=>{词[k]=t }) ||`/*有类型 ${J(ty,x=>x[0])}*/`),
$:[名,'=',NO, 标('子查询',(k,sql)=>{if(k[0]=='查')词.名['$'+尾(k)]=sql; else 词.事[k]=[词.问k.splice(0,n(词.问k)),sql]} )]//勉强支持嵌套$查=呗
,['']:just(NO) }
语句.$[2]=语句
字("何用","show use",([k,v])=>{v+=' '
  语句['有'+k]=[词A,_Q(名), (a,k)=>(v=="use "&&a=="table")?`/*${词.表=k||词.表}*/`:v+a+(k=='s'?k:' '+k)]
})
字("日钟时","DATE TIME TIMESTAMP",([k,v])=>{v='CURRENT_'+v
  词["创建"+k]=`default `+v; 词["更新"+k]=`default ${v} ON UPDATE ${v}`;
  词.名["当前"+k]=(a,j)=>{a[j]="\0"+v}
})

J_if=(v,f,f1,sep)=>{
let x,a=[]; for(x of v)if(NO==f(x))a.push(f1(x) )
return a.join(sep)
}

SQ糖糖=anew=>_N(_1(语句,s=>{if(s(1)=="\0")return[];throw `请在 ${Object.keys(语句)} 里选，非`+s(20)}) ,
  _1(';','；',s=>s(1)!="\0"?'':NO),
  [anew, (a,A)=>{a.push(typeof A=="string"?A:A.join(';'))  }] )

SQ糖=SQ糖糖((s,a=[])=>(s(0).cmt=(_,x)=>a.push(`//`+x), a) )
留loc=(o=localStorage)=>o.str=decodeURI(尾(location.search))||o.str||''
}

词.多fn={
显:"printf",首不空:"coalesce",字数:"length",找字:"instr",字区:"substr",替换:"replace",字点:"unicode",字:"char", 若:"iif",符号:"sign",随N:"randomblob",随:"random",//rtrim,quote
小写:"lower",大写:"upper",  删改统计:"total_changes",型:"typeof",行:"", 圈点:"highlight" //取(圈点email+2+'<b>'+'</b>') email('fts5'); 全文搜索match,利用C模块“虚拟表”
}

P受用=()=>{
括=p=>['(',p,')',(_,x,__)=>x]
行=p=>_N(p,','),_Q=p=>_1(p,just('')), 译=(k,t)=>k in t?t[k]:k
J=(a,f,sep=", ")=>a.map(f).join(sep)

let ri=1,r=o=>P.tok(ri++,_RE(o)),  词8=建典("&|","AND OR"),换8=(m,k)=>` ${词8[k]} `
名=r(/[\w$][\d\w_]*/), 名k=P.f(名, k=>词.名.$名(k))
数值=P.f(r(/([+-]?\d*)?(\.\d+)?/),x=>+x)
文=P.f(r(/"((\\["nrtfbu])|[^"])*"?/),JSON.parse); 括原文=_Q(r(/\([^)]+\)?/))//^可复用

选=[_1(名k, s=>词.表), 括原文 ,(s,co)=>[s,co?( co.replace(/\?(\d+)/g, (m,i)=>词.问k[i]=`_`+i),
  ` where ${co.replace(/([&|])/g,换8)}`):''] ]
值单=_1(数值,文,['?',数值, (_,i)=>"\0?"+i ], P.f(名,k=>译(k,词.名) ) )
值=_1(括(_N(值单)),
  _N([名,'=',值单, (k,_,v)=>[k,v] ],',') )
}
//export{SQ糖 词 名,值,类型 名构 语句 括原文}
//rq=indexedDB.open("xx",5);rq.onupgradeneeded=()=>{tbl=rq.result.createObjectStore("a")}; //tbl.openCursor(IDBKeyRange.only(k)).res.continue() //IDB OS可以键自增.. 没分col NoSQL
</script>
<script>
n=o=>o.length,ss=s=>s.split(" "),just=k=>()=>k,NO=null ,$Y=true,$N=false
//[]顺序{}前缀 _1 Or _N 个 _RE 或""词tok(1,p)高亮 构成语法
feed=(s,i=0)=>n=>{let q=n<0,r=s.slice(i,i+(q?-n:n)); if(q)i-=n; return r}

_RE=o=>{let re=RegExp('^'+(o.source||o).replaceAll(`\w`,`\p{L}`),'u'),d=4
return s=>{let r,N=0,N0; do{r=re.exec(s(N+d)); N0=N;if(r)N=n(r[0]) }while(N!=N0) ;return N?s(-N):NO}
}
P={//成功则,构更大
f:(p,f)=> s=>{let r=P.fed(s,p);return NO==r?r: f(r)},
fed:(s,parser)=>{let p=parser;switch(typeof parser){
  case"function":return p(s);case"object":
  let i=0,N, a;if(N=n(p)){a=[]
    for(;i<N-1;i++)if(NO==( a[i]=P.fed(s,p[i])))return NO//a[<i] may ok!
    return p[N-1](...a)
  }
  let K="\0",f=p[K]; if(!f)f=p[K]=P.典(p)
  return P.fed(s,f(s))
  case"string":return ""==p?p:  p==s(n(p))?s(-n(p)):NO
default:return p}},
tok:(kType,p)=>s=>{let r, c=s(0),k0;k0=c.st; if(kType!=9)s(1);c.st=kType; r=P.fed(s,p); c.st=k0;return r},

asAry:[()=>[],(a,x)=>a.push(x)],asObj:[()=>Object.create(NO),(o,[k,v])=>{o[k]=v}]
};P.喂=(p,s)=>P.fed(lineno(feed(s)),p)
_1=(...ps)=>s=>{let p,x;for(p of ps)if(NO!=( x=P.fed(s,p)))return x}
_N=(p,sep='',[A,B]=P.asAry)=>s=>{let r=A(s),x;do{x=P.fed(s,p);if(NO!=x){B(r,x);x=P.fed(s,sep)}}while(x!=NO); for(x in r)return r;return NO}

lineno=(s,c={st:0,cmt:(k,s)=>$Y }, noWhite=s=>{let f=c.cmt,[行,列]=[/[^\n]*/,/[^\*]*\*?/].map(o=>P.tok(9,_RE(o))), 注=C=>C=='//'?f(s(-2),行(s)) : C=='/*'? f(s(-2),列(s)) : $N
  for(let W=/\s/,x;W.test(x=s(1))|| x=='/'&&注(s(2));)s(-1) //^跳注释而已
})=> n=>{if(n==0)return c;
  if(0==c.st)noWhite(s); return s(n)
}

trieS=d=>(k,v)=>{
let pre=(a,b)=>{let i=0,N=Math.min(n(a),n(b));for(;i<N;i++)if(a[i]!==b[i])return i;  return N},
p=d,K,p1 ,S//AME part
fndK:for(;;){for([K,p1]of p)if(S=pre(K,k))
  if(p1.set&&S==n(K) ){p=p1,k=k.slice(S);continue fndK} else {
      p.set(K.slice(0,S),  p.delete(K)&&new Map([[k.slice(S),v],[K.slice(S),p1]]) /*长k短'' 新先*/);return}
  p.set(k,v) ;break}
}
tadd=(o,T)=>{let d=new Map,f=T(d),k;for(k in o)f(k,o[k]) ;return d}

P.典=(o,t=tadd(o,trieS) )=>P.tok(10,s=>{
  let p=t,k,v; Fwd:for(;;){for([k,v]of p.entries()){
    if(''==k)return v
    if(k==s(n(k))){s(-n(k)); if(v.set){p=v;continue Fwd} else return v}
  } return NO}
})

</script>

<!--https://codebeautify.org/markdown-viewer-->
<h1 id="sqsu查询语言">SQsu查询语言</h1>
<p><strong>SQsugar(SQ糖)</strong> 是我设计的一门翻译到SQL的查询语言，作为一次小实验。我给它写了个简单的查询界面，你可以在浏览器里离线地学习/简写通用 SQL 来操作数据库。</p>
<p>请不要试着打字或默写本文的SQL语句，然后去粘贴到什么 <em>且忽略掉查询结果</em> ，它不值得你这么做。</p>
<blockquote>
<p>学会SQ糖等于学会 SQL 吗？</p>
</blockquote>
<p>介于许多人并不会真正的SQL，且<a href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">SQ糖</a>涵盖SQL的所有常被手打的代码，学SQ糖确实相当于学SQL。</p>
<pre><code>
</code></pre>
<blockquote>
<p>本文所有的代码块，点击后显示出其对应的SQL语句，自动复制。点选可执行。执行右侧 <code>*3+0</code> 代表结果3行 删改0行</p>
</blockquote>
<pre><code>有表 狗(id 数 主键 自增,
名 文, 重 浮(3), 高 数1,
品种 文(5), 月龄 数1, 毛色 文(1)/*定(&quot;白&quot;,&quot;黄&quot; ,&quot;黑&quot;)*/
)
有删!表狗 //如果首句报错才
新建狗
(1 &quot;Mike&quot; 3 28 &quot;吉娃娃&quot; 10 &quot;白&quot;)
(2 &quot;Sala&quot; 6.5 40 &quot;柴犬&quot; 15 &quot;黄&quot;)
(3 &quot;黑狮&quot; 21.5 45 &quot;藏獒&quot; 26 &quot;黑&quot;)
(4 &quot;大圣&quot; 15 42 &quot;牧羊犬&quot; 20 &quot;黄&quot;)
(5 &quot;Boy&quot; 5.5 24 &quot;蝴蝶犬&quot; 6 &quot;白&quot;);
</code></pre>
<p>有了表结构和既存数据，就可以查询了</p>
<pre><code>取狗
取狗(月龄&gt;6 and 高&gt;40)
取狗(0&lt;高&amp;高&lt;40)
取(名)狗
取狗 页每2 0
取狗 序小 月龄
取(名,月龄)狗 序大 月龄
取(极大月龄,名)狗
有用表;取;
取(月龄/12 as 年龄,名)
</code></pre>
<pre><code>有表X(x 狗 当 删 跟着) //外键
有改表狗(id 数4? 正 自增)
有改表狗(名__昵称呀 文(11)?)
有改表狗+&quot;foreign key&quot; (xx 狗)

//当然也可以英文：但enum得全复制贴到MySQL执行！
有表Dog(id 数4 主键 自增,
Name 文, Weight 浮(3), Height 数1,
Type 文(5), Age 数1, Color enum(&quot;白&quot;,&quot;黄&quot; ,&quot;黑&quot;)
)
</code></pre>
<p>我们的测试环境(SQLite) 功能还算齐全，比如主键自增。但这“自增ID序号”和表结构是完全无关的。</p>
<blockquote>
<p>小秘密：你可以按 Ctrl+Shift+C 选中一个网页 tbody或&quot;table&quot; ，然后执行以下代码 <strong>“偷”些表格数据用于SQL练习</strong></p>
</blockquote>
<pre><code class="language-js">f=s=&gt;JSON.stringify(+s?+s:s); [...$0.children].map(r=&gt;[...r.children].map(v=&gt;f(v.innerText) ).join(&#39; &#39;)  ).slice(1).join(&quot;)\n(&quot;)
</code></pre>
<blockquote>
<p>如果有些语法错误(没显示SQL语句)，你也可以按此快捷键，查看 Console js终端</p>
</blockquote>
<pre><code>有表影(id 数, 名 文(15), 票房 文(8), 年 文(5), 导演 文(12), 制作 文, 发行 文)
新建影
(1 &quot;哪吒之魔童降世&quot; &quot;50.35亿&quot; &quot;2019年&quot; &quot;饺子&quot; &quot;光线影业、彩条屋影业、可可豆动画、十月文化&quot; &quot;光线影业&quot;)
(2 &quot;西游记之大圣归来&quot; &quot;9.56亿&quot; &quot;2015年&quot; &quot;田晓鹏&quot; &quot;高路动画、十月文化、天空之城&quot; &quot;聚合影联、横店影视&quot;)
(5 &quot;大鱼海棠&quot; &quot;5.66亿&quot; &quot;2016年&quot; &quot;梁旋、张春&quot; &quot;彼岸天、彩条屋&quot; &quot;光线影业&quot;)
(7 &quot;白蛇:缘起&quot; &quot;4.51亿&quot; &quot;2019年&quot; &quot;黄家康、赵霁&quot; &quot;追光动画、华纳兄弟&quot; &quot;卓然影业&quot;)
(9 &quot;罗小黑战记&quot; &quot;3.15亿&quot; &quot;2019年&quot; &quot;MTJJ&quot; &quot;寒木春华&quot; &quot;卓然影业&quot;)
(26 &quot;大护法&quot; &quot;8760万&quot; &quot;2017年&quot; &quot;不思凡&quot; &quot;好传文化、彩条屋&quot; &quot;光线影业、华夏&quot;)
(29 &quot;昨日青空&quot; &quot;8381万&quot; &quot;2018年&quot; &quot;奚超&quot; &quot;彩条屋、路行动画、好传文化&quot; &quot;光线影业、华夏&quot;)
(68 &quot;开心超人&quot; &quot;3509万&quot; &quot;2013年&quot; &quot;黄伟明&quot; &quot;明星创意&quot; &quot;小马奔腾&quot;)
(77 &quot;宝莲灯&quot; &quot;2900万&quot; &quot;1999年&quot; &quot;常光希&quot; &quot;上海美影&quot; &quot;上海美影&quot;);
</code></pre>
<blockquote>
<p>搜索下这些数据出自哪个网站。</p>
</blockquote>
<pre><code>取(*,极大票房,求均年)影 序小年 分组发行

有表A(x 数)
新建A(1)(2)(3);
取A(x=2&amp;x&lt;3) //一个挺废的条件并立
取A(x=2|x=3)
取A(x!=1)

取不重(年)影(发行 LIKE &quot;卓然%&quot;) //按“行”而非格单位不重复！
</code></pre>
<p>你可以用 LIKE &quot;%发财&quot; 匹配 <code>&quot;张发财&quot;,&quot;李大发财&quot;</code> ，而 LIKE &quot;_某&quot; 匹配字串 吴某 范某 等某</p>
<h2 id="题外话">题外话</h2>
<pre><code class="language-sql">SELECT column, another_column, …
FROM mytable
WHERE condition(s)
ORDER BY column ASC/DESC
LIMIT num_limit OFFSET num_offset;
</code></pre>
<p>如今你见识过大部分SQL语法但没有写1行SQL。 这语言只含「有新取」三字</p>
<p><strong>为什么SQ糖的作者不写SQL？</strong> 因为它被工程界误解得太严重了。</p>
<p>实际上许多用SQL和各种DB解决的问题，NoSQL(KV数据库,MongoDB 文档数据库) 都能解决，</p>
<p>SQL强大得太尴尬了、语法“自然”得太夸张了，还不如用ORM(对象1:N,存储) 单单纯粹做好 1人:N朋友 的这些关系。</p>
<p>别忘了，过度脚本化，曾造成SQL注入等严重问题(你可以理解为在输入 &gt;&lt; 时一些网站必然给它换成别的 为“防注入”)的PHP 2022年了还有人用呢。JavaEE log4j <a href="https://new.qq.com/omn/20211210/20211210A01JXN00.html">2021 年了还出严重RCE代码执行</a>呢，还复古流行起 CRUD boy 用&quot;sqlmapper&quot; Mybatis 绑定SQL语句去执行呢……</p>
<p><strong>因为用途领域上的尴尬，SQL的用户接口真的差劲极了</strong> 。 XP.cn (中文面板) 常用免费的 <a href="https://demo.phpmyadmin.net/master-config/">PHPMyAdmin</a> 查点小东西都要重载、<a href="https://navicat.com.cn/navicat-16-highlights">Navicat</a>啥的收费又复杂，<a href="https://www.heidisql.com/screenshots.php">HeidiSQL</a>, <a href="https://zhuanlan.zhihu.com/p/265486596">DBeaver</a> 这些也都不适合入门 ，MSOffice 一堆“外行”好用但不会做普通SQL的“支持”，更何谈有大部分院校还在教学生用 CLI(cmd.exe) 客户端 <code>mysql -u root -p</code> 从记事本右键粘贴啦</p>
<p><strong>然而，宝刀未老的SQL仍是大部分人的选择</strong> 。作者也是出于娱乐的心态弄了一门翻译到SQL的小语言，并支持用 ?1 和 <code>$新用户=新(?1 ?2 ?3)用户(默认)</code> 这种语法创建“函数”，当然在这里，这个为语言API桥接 的特性没有用处。只是说SQL真的很鸡肋</p>
<p>IT工程界和教育有这么不堪吗？很抱歉，的确有。无论自诩多高等的机构、高级工程师，排名顶尖的，的确有。 天才尽管天才，也没机会创造解决实际问题的东西。</p>
<p>SQ糖不会追求功能上的“丰满”和理论上的“精准”，只要求用着方便、学着能看到每行代码出现的理由。 <strong>SQ糖不告诉你知识，只愿你清楚理由</strong></p>
<pre><code>取(id,名) //select
  影(年=&quot;2019年&quot;) //from-where
  序小年 //order-by asc
  页每5 0//limit 5 offset 0
</code></pre>
<pre><code>取(id+1 as 号,名)
  影(年=&quot;2019年&quot;)
  序小 号
  页每5
</code></pre>
<h2 id="join">JOIN</h2>
<pre><code>类型默认(字/*：*/ 文 主键)

有表 物品(字, 主人 文)
有表 人(字, 外号 文)

新建人(&quot;小明&quot;&quot;智多星&quot;)(&quot;小刚&quot;&quot;及时雨&quot;);
新建物品(&quot;牙刷&quot; &quot;小明&quot;)(&quot;拖鞋&quot; &quot;小刚&quot;);
</code></pre>
<p>这个词是“连接”的意思，比如寝室里这物品可能被多个人引用，所以不能直接附在人上，那么给你物品，你能查到人的外号吗？</p>
<p><strong>主键默认是唯一的，就是用于JOIN</strong></p>
<p>SQ糖并没有为JOINs 提供语法糖，因为它太机械化了。把同属1人的东西独立成表，本身就是太现实的问题，即便简写也无法简单；但幸好还有文章可以写</p>
<pre><code>取(物品.字,外号) 物品 &quot;inner join 人 on 物品.主人=人.字&quot;
取(外号) 物品(物品.字=&quot;牙刷&quot;) &quot;inner join 人 on 主人=人.字&quot;
</code></pre>
<p>可以翻译为：<code>取(外号)物品(名=牙刷) 联动/*我,右,全*/与 人：名=主人</code> 但SQ糖没有。</p>
<p>你就取了 <code>主人=人名</code> 的(项的交集) INNER JOIN (即&quot;JOIN&quot;)</p>
<p>LEFT/RIGHT JOIN 则会使 物品/人  的一些列为空，FULL JOIN 就更会了，毕竟这些是 &quot;OUTER JOIN&quot;</p>
<blockquote>
<p>^ <strong>一个常见的误会是，“表格由行和列组成”。</strong> 实际它是由含横格的多行组成的，列的本意是“所有行等位项”，有时却指代行内1格(2D数组或i&lt; n,i*m+j 总nm格拟2D 同理)</p>
</blockquote>
<p>什么意思呢？ <code>取物品(名=&quot;牙刷&quot;)</code> 的()条件删掉。如果有个主人 &quot;小茗&quot; 找不到，那么FULL 会保留这1行，空格填NULL。LEFT 也会</p>
<blockquote>
<p>SQ糖里 <code>新(&quot;电子字典&quot; 无)物品(名=&quot;字典&quot;)</code> 代表 <code>新 名=&quot;电子&quot;/*无改主人*/ 物品()</code> 或 <code>无=default</code>，而空代表NULL</p>
</blockquote>
<p>NULL不会参与许多计算，比如平均值，要滤掉NULL 取物品(名!=NULL)</p>
<p>另，有种叉联动把A的每项与B的所有项 生成 nA*nB 个结果，叫 <code>cross join</code> 笛卡尔积</p>
<h2 id="计算">计算</h2>
<p><strong>SQL 的功能实际上是数据统计</strong> 而非1:N存储和 FilerSort 。它甚至在某些数据上比 Excel 好用，比如单位换算和表头(列名) SQL都能处理</p>
<pre><code>取(1+1 as 二);
取巨长表名&quot;as 此 inner join 人 on 此.主人=人.名&quot;
</code></pre>
<p><code>分组键</code> 能在组内做统计(如排序)</p>
<pre><code>取(计*| as 组项N) 影 分组年//有几组得几项(=行)。像 取(计,极小,极大) 这些是只得1项
</code></pre>
<p>组内排序需要 <a href="https://sqlite.org/lang_aggfunc.html#group_concat">group_concat</a> ，这个SQLite里也有，不是MySQL/Postgres的扩展</p>
<pre><code>取(拼组 名)影
取(拼组名)影 序大票房 分组年
取(拼组名+&quot;|&quot; |表格)影 序大票房 分组年
</code></pre>
<h3 id="执行顺序">执行顺序</h3>
<blockquote>
<p>参阅 <a href="http://xuesql.cn/lesson/select_queries_order_of_execution">xuesql</a>。它的上几节也不错</p>
</blockquote>
<ol>
<li>from 和 join 确定涉及表范围</li>
<li>where 过滤</li>
<li>group by 分组</li>
<li>having=where 过滤每组(概率小 没给糖!)</li>
<li>select 进行x+1,name+&quot;__&quot;等计算，或min,max等</li>
<li>distinct不重</li>
<li>order by 排序</li>
<li>limit/offset 截取部分数据。 这个过程可以用Cursor(已选行) 实现，在Server等单次请求的地方 它比cursor更利于缓存</li>
</ol>
<p><strong>灵活运用以上的句法组合能在SQL层面更好的解决数据问题</strong> ，而不必把问题都抛给程序逻辑。</p>
<ul>
<li>列性质：主键(且唯一) 自增 正(unsiged)</li>
<li>类型：数1,2,4 integer；(改/长)文 char；浮顶精(10,1) =0.0~9.9 和8字节(双精)浮点“浮”；真假 bit 定 enum  时间 日期</li>
<li>特殊值： 无 default 空 NULL ?0 首个$事=语句 参数(jsAPI:<code>词.事,问k</code> 页每 不支持!)</li>
<li>函数：计 count 拼组/文 concat 求和均 极小大 正 abs 整取/低/高</li>
<li>时间：<code>新建 当前[时/日/钟]=0/*即第1项*/ (0);</code> 和 <code>当前时 更新时</code> （基于 <code>ON DELETE CASCADE</code> 这种特性）</li>
</ul>
<p>除了组内排名作列表等<a href="https://zhuanlan.zhihu.com/p/92654574">窗口函数</a>，SQLite 甚至能<a href="https://sqlite.org/lang_with.html#outlandish_recursive_query_examples">“生成” helloworld</a>，不过是关系式编程版的。</p>
<p>或者1~100 (递归/循环 查询) <strong>请在命令行等 SQL 客户端执行</strong></p>
<pre><code>WITH RECURSIVE cnt(x) AS (VALUES(1)
  UNION ALL SELECT x+1 FROM cnt WHERE x&lt;100)
SELECT x FROM cnt;

WITH RECURSIVE cnt(x) AS (SELECT 1
  UNION ALL
  SELECT x+1 FROM cnt
  LIMIT 100
)
SELECT x FROM cnt;
</code></pre>
<p>因此SQ糖尽管好用，限制还是很大的。 目前没有支持Index(表头定制)、ACID属性(transaction: begin commit rollback-to?savepoint)，也没有给 groupBy-having 和 join， replace into(on conflict) 语法糖(故 改新取 支持&quot;代码&quot;)</p>
<p>另外：vaccum 是重建db文件，reindex 是删索引，attach 这些是CLI客户端命令。 like,glob,<code>name regexp &quot;\d+&quot;</code> 和 <code>&#39;{&quot;a&quot;:NULL}&#39; -&gt;&gt; &#39;$.a&#39;</code>(单&gt; 仍JSON) → NULL  json_type quote 这些是单格列表等的支持</p>
<pre><code class="language-sql">SELECT DISTINCT user.name
  FROM user, json_each(user.phone)
 WHERE json_each.value LIKE &#39;704-%&#39;;

SELECT DATEADD(HOUR,+1,min(JSON_VALUE(ExtraData,&#39;$.enrollDate&#39;)))  as [enroll_date] 
 FROM school_7..StudentCourseItem 
 WHERE Student_id = 11449387 AND ItemType_id = 2 
 AND JSON_VALUE(ExtraData,&#39;$.levelNo&#39;) in (7,8,9)
</code></pre>
<p><a href="https://github.com/by-syk/CoolapkUserStats">https://github.com/by-syk/CoolapkUserStats</a></p>
<pre><code class="language-sql">SELECT
    @rownum:=@rownum+1 AS &#39;#&#39;,
    CONCAT(&#39;[@&#39;, name, &#39;](http://www.coolapk.com/u/&#39;, id, &#39;)&#39;) AS &#39;user&#39;,
    FLOOR(fan * 0.5 + feed * 0.4 + app * 0.08 + find * 0.02) AS &#39;score&#39;,
    fan, feed, app, find
FROM
    user, (SELECT @rownum:=0) temp
ORDER BY
    score DESC
LIMIT 100;
</code></pre>
<pre><code>简写$取=&quot;(S,g,c)=&gt;S+&#39;, (SELECT @rownum:=0) temp&#39;+g+c &quot;

取(@rownum:=@rownum+1 as &#39;#&#39;,拼文
&#39;[@&#39;+name+&#39;]\x28http://www.coolapk.com/u/&#39;+id+&#39;\x29&#39;| as &#39;user&#39;,整低
fan*.5- -feed*.4- -app*.08- -find*.02| as &#39;score&#39;,
fan,feed,app,find
) user 序大score 页每100

//刷新页面以删除简写！(js 词.名.$取 ,.$名 翻译?)
</code></pre>
<p><a href="https://liolok.com/zhs/database-exercise/">https://liolok.com/zhs/database-exercise/</a></p>
<pre><code class="language-sql">-- (1) 找出与李勇在同一个班级的学生信息；
SELECT * FROM Student
  WHERE Clno = (SELECT Clno FROM Student WHERE Sname = &#39;李勇&#39;)
    AND Sname &lt;&gt; &#39;李勇&#39;;

-- (2) 找出所有与李勇有相同选修课程的学生信息；
SELECT * FROM Student
  WHERE Sno IN (SELECT Sno FROM Grade
    WHERE Cno IN (SELECT Cno FROM Student S, Grade G
      WHERE S.Sno = G.Sno AND S.Sname = &#39;李勇&#39;))
  AND Sname &lt;&gt; &#39;李勇&#39;;
</code></pre>
<pre><code>有用表Student
$查a=取(Clno) (Sname=&quot;李勇&quot;);
取$a(Sname!=&quot;李勇&quot;&amp;Clno=);

$查a=取(Cno)&quot; S,Grade G where S.Sno=G.sno and S.Sname=&#39;李勇&#39;&quot;;
有用表Grade
$查b=取(Sno)$a(Cno IN );
有用表Student
取$b(Sname!=&quot;李勇&quot;&amp;Sno IN )
</code></pre>
<blockquote>
<p>所以我说 <strong>学SQ糖基本等于学会SQL</strong> 。从简单、常用到复杂、混乱，SQ糖都能表达</p>
</blockquote>
<p>至于什么精通，让爱死记硬背的人通去吧</p>
<h2 id="hack">Hack</h2>
<pre><code>有表A(x 数4),B(s 文),C(t 时间), 用户(字,boy 真假 或1)
有删表A,B,C //并立是支持的,只是网页上可能无法执行

新(?1?2)用户(默认) //和新名=?0 用户 一样可以创建语言绑定($事名=语句 )

简写增列=&quot;a[j]*=2&quot;
简写$wtf=&quot;&#39;常量文本&#39;&quot; //SQ糖的常量与类型名 是会“或许”被“翻译”的

新建A 增列=0 (1)(2) $无=0 (3);
新建A 当前时=0 (0)(0);

类型默认(小文 文(4)?)
有表AA(小文 $ 主键) //$=小文。 not null 不必重复两次
</code></pre>
<pre><code>取( )无 &quot;1+2 as n&quot;
有用表无 //当计算器用
简写$_=&quot;SQ增fn表(词.多fn)&quot;
取(删改统计);
取(型2);
取( )&quot;(1,2,3) = (1,2,3),(1,2,3) = (1,NULL,3)&quot;

有表t2(x 数,y 数,z 数);
新建 t2 (1 2 3)(2 3 4)(1 空 5);
取( )无&quot;(1,2,3) IN (SELECT * FROM t2)&quot;

取(显&quot;%x&quot;+z- -7);
有用表无
取(大写&quot;abc&quot;);
取(字数&quot;a&quot;);
取(9%2);//余数, 从0~100 往复于0,1
取(字区&quot;abc&quot;+1+2);
取(替换&quot;abc&quot;+&quot;a&quot;+&quot;c&quot;)
</code></pre>
<p>也可以在DevTools 应用&gt;存储&gt;WebSQL 即 (F12&gt;Application&gt;Storage) 查看表与执行SQL，或清除数据</p>
<pre><code>有删库a //提示：不要在生产环境使用（废话..
</code></pre>
<blockquote>
<p>关于程序员的一些秃头和数学天才的笑话是说着玩，但删库跑路会被抓、暴露用户隐私很危险，都明白吧</p>
</blockquote>
<p>若不看注释， <code>SQ糖=SQ糖糖(()=&gt;[])</code> 即可</p>
<p><strong>SQ糖提供了较简洁的语法，可在js源代码里查看（只有220行）</strong> ，然后还有个 <a href="db1">db1</a> 非常复杂..教科书。本原文是 <a href="db2.md">md文件</a></p>
<p>首个空白会保留地址栏 <code>?</code> 后随的代码，你可以用这个分享查询片段</p>
