## 流控内联
>回、重复-停下/略过 跳转间的关系及 [^n]层次

为了在中文更自然且统一，我们抛弃了在老教、脚本、新潮、函数式、DSL(模板等狭用途)，等一切语言既有的语序和内定模式，甚至规划了[物理命名法](#物理名字表)；`for while, forEach` 带来的不一致性和 `goto label:` 等低频语法，是绝句拒绝机械翻译的重点。

其推崇函数化、禁止break@outer 的循环：

```
恒事 从0数(n：数、op：函1<数>) 为
  变数i初0
  重复若i不>n，op(i)；i=i右。

从0数(2)，[i]
  若i是1，停下。 “停下，跳转到哪？”
  说(i)

量str=1令，
  若我是1，回[^0] "abc"。  “怎么略过下方代码？”
  回[^0] ""
```

在 `op(i)` 里 `回[^0] 和 回[^1]` 的语义就确定为 `continue 和 break` ，多层while时也有效。`略过 停下` 借此生效

在 `x令(op)` 的op里 `回[^0]` 在其前向 `量str= _0` 的 _0 赋值，借 `for(;;) { if(self==1){_0="abc";break} _0="" ;break} ` 自由跳转（若 `[^0]` 受用）

一般，`回；抛下` 基于调用栈跳到旧位置执行。 `重复若；重复，。若； 若a“假才算” 且b，否则，` 由编译器生成完if,while整体再 #cs 回填各类跳转地址，输出 类汇编(JVM,PyVM,Ruby MRI,LuaV,x86,.)

`恒事` 会共享其跳转+“返回值”写入方法（首例有3处），为尽可能低的运行期开销和易读语法/API服务

`get() ?其令，它+1。?其令(新表「取」) 空则"没有"` 可空调用在if{} 里添加

>这些都「把调用换成变量，并在前后插句」，`get()?xx` 就变为 `可空(get())，xx。` get;if() _0=xx 前移，处理右部照此。 `!!(空则错) 和 空则` 同可内联。当然 `重复若` 可能变 `while(true)if(..)break`

>随后 `if; if` 被(调用)标记。会被移成 `if{if{}}` 来保证原理简洁+0开销

不同于内定的 `for(T it:items)`，绝句以 `items去看，` 等 `可看<T>` 列实现 Iterator 的指针可断续右移(如点击时显下一文本)，也以列看内联 避免了简单穷举 `iter.next() hasNext` 的开销

> `"fn()"= liftVar{fn.call(arg,it)}` 可以替换调用为赋值，适于恒与非恒事。标物同APT流程
<br>言级eval:loop 可把 `o?.f()?.f1()!!.xx` 每?后 添为独立块，待再Pass

## 值域
>`0~9 值域<数4>、(0L~略 升2) 略域步<数8>` 模板类型参数和 +-*/~ 等记法、类例隐转

类似Py，绝句有 `[0,1,2] [1:] ==[1,2]` “列表切片”的重载 `建行(0、1、2)[1~略] 是(1~2)去行` ，尽量不写 `for(int i=0;i<3;i++)` 这种东西

Py,JS有 `list[a:b:step] = [it[i] for i in range(a,不含b, 步差step)]` 如 `["0"] [0:1]是本身` ，

b负时是 `len(it)+b. it[-1]是末项,it[1:]是首右余项` 。通常it[0]是首，从0数的理由如“列表的内存位置(指针)”=首项、`(a=a+1)%b < b0往复` 更短

值域(即区间Range) `0~99, 0~100左, 5~+1 , 0~10 升-1` 是描述变量数值范围、或采样间差的工具，适用于数类型的穷举和判断，如 `5试，我存于0~5且我存于0~100 且我属于数4。`

属于数？

绝句有5模板类型参 `对何<数浮计N我>` ，计算机的数字(2进制)位宽度都有固定，像 `数4=2^(32-1符号位), 计2=2^16 存于0~65535 半32767` ，__所谓基元类型，是编译器选择+-*/指令宽度的标记__。若数不是型参，`对何<> 数=数4`

数/Int-eger 浮/Rat-ional 计/Cnt-count 有1,2,4,8 即8bit位~64位 的版本，也有 `数N=BigInteger,浮N=BigDecimal`

在 `物 T1：T`、`对何<T1>(其中 T1：T)` 和T1的 `同名例` 里 `：我` 指代T1

```
对何<我>类 Inc 为
  事 add1：我
  同名例：常量 “绝句 samename-insta = companion object+类型约束，也方便序列化器-注册。”
  类 常量 为
    量 zero：我 “类型参数自动传递给内层 Inc.常量<我、...>。类似物事 的外部变量会闭包住”
类例 Inc 数 为
  事 add1=我+1
  同名例：常量 为
    量zero=0
```

>类型参数对内部类可见。常见OOP里编译期多层级参数共享易，没必要引用时自动传参

基元 与复制/引用传参(是否深拷贝)、是否可变 无关，它被老教(old-school)编译绑架为“特殊对待”的类型也有Java不可 `List<int>` 的贡献。 `j.lang.Integer` 是堆分配、有类型标签的int，毕竟 `j.util.List` 不知1内项占几字节，每项只能按 `Object` 装箱而又和 `int[]` 割席，这也是C++ 和J最大的性能差异。Kt也没完全修正此问题，又为极难用到的计算搞出一堆 `fun Long.plus(Int): Long` 的重载，界内全和SQL,WinHex 一样乱

__我很反对为编译器细节倒贴掉语和言、类型优雅性的设计__，或者像JS等用皆浮点或undefined 规避这些不足。 绝句为算术设计了 `对何<我> 数值 ..事「+」(另：我)：我 = 内定` 和 `类例 受隐转 数4`

`事 余除(内数：我)：俩<我> ； 10余除3 令，次是3 且首是1。` 也明确排斥了除和除以等抠字眼的问题。没善用中文，当然导致文件冗长 语义欠缺

简单说，`类例 T T1` 内语法同 `物事 T1：T()`，它会添加T1=>T的 `受隐转` 规则，T就成了调用时遍寻可能的“A|B并集类型”：为T1的事量也适用T

`a+b` 会试归一ab 俩 `数值<的T>` ，查有数4=>数8 无数8=>数4 ，加1调用就实现了隐式转换。多参靠 `reduce` 逐俩匹配

`组值<T> 组参<T> 组恒<T>` 用来实现 `Integer[] /*非 int[]*/` 和 `"Hello %s" %参("世界")` 不定长参数。组恒做常量展开

## 定义域函数
>“逗句为何”布局、事定义语法、.ju书引

「其中」内书级定义都可包含。不独立作用域：__量视为在函数体头部，事 物事强制内联。其他加在物的私下但不允许他事引用__

.ju文件有5语法层级，言句段词书，惯用Java反射/APT生成 能见到词级(__事量类物例__)信息，而绝句恒能在编译前修改微至言级的代码，像 `""` 常量和算式，因为绝句编译器就是能生成代码的解释器，只保留编译期未知变量的运算。 #cs 常量折叠,循环展开

句级是纯粹的，`若 判[属存是] 空则`  完整时能被言级包含；书级事量实是  `物 文件名Ju 为` 里的词级定义

`juec` 基于U-AST通语法树，做单双向Pass() 来脱糖/低级化源代码。参见 `对何<AB>同一`

### 集合

相比 `java.util` 及“脚本语言”和JSON语法上的数据集类，绝句有继承自Kt但尽量低拷贝/new内存开销的 `组行表集 <T>：些许项<T>`，否决了常用术语

- 组 `Array<T>, T[]` “数组”是固定长度的行
- 行,改行 `List<T>, vector<Tp>, Lua{} PHP array()` “列表”是可删添的有序集；实现队列
- 表 `Map<K,V>,Hashtab, Rb{k=>v} Py{k:v}` “字典”是 `行<俩项<KV>>, 年龄["小明"]` 单向查找的优化
- 集 `Set<V>, Py{1,2}` 就是些许项(如 来自表)
- 队列 队和栈(`事 添,泡`)序，或双队列(deque,JS [])

在类型上，集合改写事分 `表<KV> 改表<KV>` 来限制 `改，建表(1到2)。` 创建，定长则有 `组<读文> 组<写数>` 禁 `<T>` 作参数或返回值

`储物 标物`

### 书引

书 引/pkg use 列表和 引单/use-1 是绝句多文件的组织法， `引单p a b作d c作空` 即 `引p.a；.. “事量或类型”d=b` ，只带p时是 `import static`

与Kt和C++的“运算符重载”不同，绝句的+-*/ 只是记法名，不像Hs自定算符 靠数指定结合律，`「记法」大中小` 规定了无括号谁包含（结合住）谁

大与(=)同级、中(+)同级、小(*)同级， 而前后缀更小些 是 `-(x !!)` ，其包裹(`的去[]` )调用链，内层/左侧先算；而 `5次，。` `按钮被点击，` __这些都是()调用__——出现逗句或「」都作为“函数块” `obj去受调用()` 的尾参

#cs 逆波兰算符重排 解决结合序，Lua同款的此法支持无括号 `0+ ~(1 + 2)` 和 `(0+~(1+2) )!?` ，方法是把 `1+2*3 = 1 2 3 * + ; 1*2+3=1 2 * 3 +` 遇+先输出*级更小更深 继续到读不出 `(x o x) o x` 链单项x

## 量纲类型等助
>别名与量纲、量,事 [公式]、代理Proxy

```
事 fib[n a=1 b=1]=若n是0，a。否则，回重写(n左、b、a+b)。
```
## 可空类型
>集合类型论和多态、类型推导

`1作<数>`、`事 显(o：值)=o作否<文>? 其令，"文:$它"。空则o去文`

### 类型皆集合

每1值都有 `数4、真假、文` 这种类型-其有 `233、真、""` 这样的取值，像 `可看<T>` 又有 `组行表集 <T>` 4种子类，而一切类型都 `属于 值?`

`物 T1：T` 意味着T1有T的所有事量，故需要T的位置，完全可以写个T1。 类型常有极多可能取值，单例Singleton 和 `new T(){{initThis()}}` 建立了T的新子类，它就只有1取值。因为没有公开构造器，它们的功能很固定，但其内数据也会因 `static / new-this` 上的改写而行为差异，因此，类型为编程提供的是数据体有定式，而不是能否改写/属何子类。 此谓继承-抽象，其实现法是封装-多态 （公私分明-同名多义）

尽管如此，面向对象OOP 还是有 `enum, instanceof` 的概念，`例物 况物` 给需要分情况数据 的程序，在 `判x是 判o属` 时不必写出else

## 函、函我
> 「」引用、物事和恒字

>`函我` 的主语内联必要时被lift 。函我是带this域的函，调用和定义服从JVM ABI

绝句也支持 `引单 绝句 「+」作空 「-」作「减」` 的记法重命名，尽管 前中后缀 `负1 a到b 空!!` 都不能重名、仅后缀能以「的去」访问。

全局「」事前缀；物里「」事中缀 「」量后缀

「」 /<b>``</b> 俩反引号
- `叠(0、「+」)；看为(「+1」)` 记法(半缺)引用
- `成员集去作<行<用户>>去看(用户「解绑」) ；关注者去滤(“我觉得”「可爱」)` 事量引用 Kt `User::ungroup, ::isCute`
- `用户去滤，名字试存皆 「它为大写」。` 逗句的替代
- `事「*」 .. 事「+」小 (另：数) .. 事「**」小右` 记法-结合律定义

『』 /<b>````</b> 俩“双反引号” 用于词的定义和指代
- 先说“俩反引号”，SQL常见 Kt罕见。本可直写的名字带空格 不利编程，故绝句采用bash里 $ <b>echo `ls # command`</b>
- 名在编译期被解析为 arg[0] 等确切引用，详见[词法作用域](#词法域)


## 可变量与解构if
>判断数据格式同时给其内项位置简写名
## 断续列
>实现不用 `get("baidu").then { say(it+"end.") }` 写明的async
## 英文绝句
>为更符号化、而非书面化的语言翻译绝句

储例况标 data enum when anote
