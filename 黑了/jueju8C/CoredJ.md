多广播单选空haadel
- 调用链可以嵌入函数 a.as(x=>) ，那么当a是复数，首次返回YN,over 便实现find,forEach
- a.at(x=>) 返回YN,NO 时实现filterNotNull
- had(x), del(0) 可实现单参push和0参pop, `posR.as(基于,i=inout(0))` ..+方向查找
- posL只实现had,trim,浮点后继; `too().posR()` 深克隆
- x.as(An=>) 实现with(x), 基于evalFun(错闭包替换)

歪嘴假借YNOoo/ 4+2种mayerr
- `[]` length为0
- `""` trim后为空
- `NaN`
- `Error` message不空
- $Y,$N,NO,over,+oo(null,undef,Inf) 是常量, over仅用于函数重载

除了处理错误 `may("grpErr"), x.may(err=>假值), as(为空?, x=>)`
- `$N.as()==NO`, u.age?.as() 不应执行
- `u.as.age()` __as链接受Promise__, 如果是 `age$(b)` 则调用 `env.age(it,b)` 。可逆Out里颗粒化为 `age(b)(it)`
- 即用as实现 derive, watchEffect

asres映射表,go异步组
- `as(res,()=>)` 用于分组报错
- `as({key:x=>[x? 0 :NO, ]})` 用于字典或switch, 默认按"type"
- `obj.as({临时swap, as:An=>})` 参赋链
- `"1".as(Out($=>nbase$(10)), A=>A+"0")` 靠Out世界绑定映射两项
- go,as 有意味 `Promise.all,race`

共赋值参数:4用4特inout,DLC.acty可吊销
- __任何需要Promise或回调的位置，都能提供 inout()__, 反之亦然
- 从DOM或JS监听新值 `inout(f,e,'change'), (f, obj),(f)`; 轮询如 `1..s, 1..sRate(roDebounce)`
- 与只增数组互转需 Incy(ro), `await s.as(rw)`-即onEach直到赋值 `y(over)`
- Incy.fn 在数组,(async)只增数组values 上都可用

基于HI=CLI+Ini (后端=把SQL封装成命令行+环境变量=>RPC查询), “登录”是远程参数即句柄，可close `DLC.acty=$N`

inout有oxaf4种类型, 如a"关键数组"
- 都支持 `ro((x,b)=>x+1) (b)` 关键赋值
- `Fn.Out({f:thiz=>, p:Out(get,set?)},'rwx')` 代表!writable,enum,conf; `Out.T0` 查询extends
- a.onvi 基于v值i编号做缓存, `(x,i,ad)=>` ad变量监听项的添删
- `a.at(is),a.as(fn)` 有2参绑定, is.如 `'>0',['theads',]` 预留为DSL

藏赋值参数gosft
`class{override}` 就是向高阶函数传参，因此对象亦闭包。把 at=,rn(),n预留为DSL
- too(A,B) 遍历{}[]的树, 应用 way2=(A,B)=> 等对齐求和

列表
- go(Sum.as,key)可求和+分组, goRn即地排序分组
- fork,sep,join(Sum.ln) 分页
- TPair,TKV, trim(0,0)模拟py[:], trim(1,L,R),atSort/All/N1 分栏
- rn.reRand率/res/l_1+/sep/cyc

Sum
- 对(0项)归纳或展开
- 标准和分组统计
- 无需中间列表创建kv,uniq 分组
- 记录求和步骤, 能实现[].join 和DP. unSum支持加权BFS

