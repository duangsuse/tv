pkg jueju

/** Any value(!=null) provided to fun-[Args]ument and val/vars, maybe const literal, system registry or user input.
  expr and its subexpr/vars comes with 1 value&type. types are implicitly `:(extends) Any` and canBe(it's subtype) [Break] */
/**: -参数和变量接受的任意(非空)值，可能由常量字面、系统登记或人类输入。
  算式及其子式/末端单量都有1值和其类型。任何物类隐式 `：(属于) 值` 且可为(即有子类) [断止] */ 
impl? data Any()
  /** Test content equality(provided any!=NO), see [CanSort]: math rules, [Vars]: memAddr equality */
  /**: 实现内容相等性，任何值!=空，数学性质见 [可序], 内存地址相等见 [变量集] */
  @_("是") @CopyInfix(_("不是 en !="))
  fun `==`(:This): Bool = VMOp.eq
  /** Brief obj(&inners), rarely used outside debugging (except [StrBuild]). Add :[CanSend] for load/dump */
  /**: 简述对象和其内项数据，很少在调试外有用（除在 [文拼]）。导入导出请加 :[CanSend] */
  fun Str: Str = VMOp.objStr
  /** Pregrouping key for optimizing [==] lookup, must pure(equals->sameHash)
    or [KV.get] becomes UB. Hashes are sparse like pseudo-[Random] */
  /**: 优化“靠 [==] 查表”的预分组线索，必须纯（相等->散列相同）
    否则 [表.取] bug。相邻值散列不扎堆这点像伪[随机] */
  fun Hash: Int = VMOp.objID

  /** `Any` canBe `Str,Int,Ary`,. (`"" is Any`), if provided value implements([is]) [T] e.g. Str&you can't change type signature(e.g. Any), cast `any.as[Str]` is efficient
    for `int1.as[Int4]` widen, `int.as[Int1]` lose precision it's C-like(& lit-int=>float,Char!=Int2). for JVM APIs autoboxing `Ary[Int] == int[]` supported (slower). see [WasConvert] */
  /** 值可为文,数,组,. 也即 `"" 属于 值`。若提供的值有实现([is]) [T] 如=[文]，且你不能精确化类型签名如[值]，强转 `此值去作[文]` 不慢
    对数1作数4 宽化、数4作数1 精度丢失属C语言族（但只有字面int=>float、[字]!=[数2]）。对JVM接口，支持略慢自动装箱如 `组[数] == int[]`。见 [WasConvert] */
  'T'impl! eval fun as: T = VMOp.checkcast
  /** Check if typeof this inherits [T], or have `class-named T This`. `class: named as XX: ` inherits, like [Empty]
    Such [Bool] infix supports `!is` and `when x is:` syntax. "type" is statically(compiler-time) known part whatever (func)value, or "def" order is, faster&safer */
  /** 检查值的类型是否继承[T]的全员，或有 `类例 T 我类型`。 类的无名同名例会被继承如 [值空]。
    类似真假函数支持 `不属于` 和 `判x属于，` 语法。值的类型/型参静态(编译器)已知。无论值由谁何时提供，更快速而安全  */
  @_("属于")
  'T'impl! eval fun `is`: Bool = VMOp.instanceof

@Below(4+3, '''eval ''')
'T'fun Any.asMay = is[T].way(`as[T]`, NO)
@_("存于")
'T'fun T.`in`(set:[CanSee T]) = set.contains(this)
'N'fun `-`(:N): N = VMOp.neg
'N'fun `+`(:N) = n //later def N=Vec,Sort
@Below(3, '''@CopyInfix''')
@_("非")
fun `!`(q:Bool) = q.not //del "!!"
/**: 只能 `1不>2` 而无“1不大2”。否运算lteq "<=" */
'N'fun N.`>`(:N): Bool = VMOp.gt
/** [>] */
'N'fun N.`<`(:N): Bool = VMOp.lt

/** Any?=Any+NO: `null`, nullptr or None */
named NO: Any?
/** See [HalfRange] */
eval val Omit=NO

/** Instrinic stub, impls are inlined */
samepkg impl?? data VMOp
/** TO distinguish int & Integer(e.g. how Ary[Int] => Integer[]) , var on VMT changes */
samepkg impl?? data VMT
/** typeof `throw` or [Exec.exit], never has value so anydata canBe Break. `Any?<T<Break` in memberSet */
/**: `抛下` 和 [进程.结束] 的类型，不返回值故任何类型可为断止。词(成员)数上 `值?<T<断止` */
impl! data Break

// scope fun
'T'fun T.takeIf(p:[FnTest T]) = p(this).way(this,NO)

// helper
eval fun TODO(reason:Str="I'm tired"): Break = throw ErrNoImpl(reason)
fun error(msg:Str): Break = throw ErrVars(msg)

fun require(q:Bool, msgr: Fn0[Str]):
  if !q: throw ErrArg(msgr())
'T'fun requireNot(it: T?, value: T?, msgr: Fn0[Str]): T
'T'fun requireNotNO

/** See [assert] for testing */
fun check(q:Bool, msgr: Fn0[Str])
'T'fun checkNot(it: T?, value: T?, msgr: Fn0[Str]): T

'R'fun trys(:Fn0[R]) = try { Res.Ok(fn()) } catch(CanThrow) { Res.Err(you) }

/** Switch `$Y` or `$N` (true|false) */
/**: 在 `真` 和 `假` 间选择 */
data Bool() CanSort
  /** use [!] instead */
  fun not: Bool = VMOp.not
  @_("且")
  fun `&`(:Bool): Bool = VMOp.and
  @_("或")
  fun `|`(:Bool): Bool = VMOp.or
  /** Only 1 Bool true? see [Int.xor] */
  /**: 只有一个真值？见 [数.xor] */
  fun xor(:Bool): Bool = VMOp.xor

@Compiled("bidir(-1,MinAt0,Eq,MaxAt0)")
-enum Sort(sign:Int):
  MinAt0(-1); MaxAt0(+1); Eq(0)
  //min,max
/** Type with comparator. to sort [compareTo] must: 0. not random (pure) 1. a=b&b=c&a=c (refl,identical & transitive) 2. a>b & b<a (!symmetric) */
'this'type CanSort:
  fun `compareTo`(:This): Sort
  //by rev nullsFirst  thenBy


@Compiled("bidir(-1,NO,$N,$Y)")
''Bool3 = Bool?

'AB'A.`to`(:B) = Pair(this,b)
/** Typical data with 2 [Vars]. use [PairOf] for (type)A=B, [Vec] for numeric Ary指针也是用a到ks,取(k) 表示 */
'AB'(get A B) - Pair(A:A,B:B) Send:
  impl fun toStr="$A:$B"
'ABC'(get A B C) - Pair3(A:A,B:B,C:C) Send:
  impl fun toStr="$A,$B,$C"
'T'PairOf=[Pair T T]
'T'PairOf3=Pair3[T,T,T]

'N'-when RangeHalf(A:N) as CanSee[N]:
  fun contains(:N) = n!<A
  fun see(:Fn1[N]) = (this step 1).see(fn)
  fun gotSize(it:Sized) = A~it.size

'N'data Range(A:N, B:N) as RangeHalf(A):
  fun contains(:N) = n![A & n!]B
  fun see(:Fn1[N]) = (this step 1).see(fn)
  fun moveAndPad(:Int,n:Cnt)

'N'RangeSub=PairOf[Range[N]?]

'TR'PairOf[T?].joinOr(v0:T, :Fn2[T,T,R]) = fn(A?:v0, B?:v0)

'N'fun N.`~`(:NO) = RangeHalf(this)
'N'fun N.`~`(last:N) = Range(this,last)
'N'fun N.`~+`(right:N) = Range(this,this+right)
/** `0~+-5` = ±5 */
'N'fun N.`~+-`(pad:N) = Range(this-pad,this+pad)
'N'fun RangeHalf[N].`step`(d:N) = RangeStep(this,d)
'N'fun RangeHalf[N].`div`(:N) = this step (B-A)/n

/** `0~10 step 2`. [d]: delta, increment */
'N'data RangeStep(rn:RangeHalf, d:N) as CanSee[N]:
  fun see(:Fn1[N]):
    var N: i A; n B-1
    val fwd:Fn0[Bool] = (rn is Range).way( (b.remDiv(d).A==0).way(`i!=n`, `i<n`), `$Y`)
    loop if fwd(): fn(i); i=i+d
  fun contains(:N) = (n in rn)& n.remDiv(d).A==0

data Char() Zeros CKase CanSort:
  fun Int = as[Int]
  fun `+`(:Int) = (as[Int] + i).Char

  -named:
    eval val surrogate=(56320~57343).seen{Char} to (55296~56319).seen{Char}
    impl val N_BYTE = 2
    impl val sign = $N


'This'type CKase:
  var noCase=$N
  fun equals(:This)
  fun retype(need:Case, lo:Locale) = when need:
    Upcase: uppercase(lo)
    Lowcase: lowercase(lo)
    Title: titlecase(lo)
  fun contains(:Chars): Bool
  fun contains(:Regex): Bool
  fun split(:Arg[Str], n:Cnt=-1)
  fun split(:Args[Char], n:Cnt=-1)

  fun filter(p:FnTest[Char]) = filter[StrBuild](p).Str

  type Posited:
    fun with(sub:Str): Bool
    fun without(sub:Str)
    fun pad(n:Cnt, :Char)
    fun padLines(n:Cnt, :Char, lf=CKase.LF)
    /** reverses [pad] */
    fun trim: Str
    fun trimMargin(before: Str): Str
    val pad2pad
    maxOf

  -enum Case:
    Upcase; Lowcase; Title

  -named:
    'R'fun ignore(msdos:Fun1[CNoKase,R]) = CNoKase.msdos

/** `"string文", "abc"` consts are of this type: [Chars] with Unicode, uppercase, sort support  */
data Str() Chars CKase CanSort:
  fun BGets(:Charset=UTF_8)

  /** `sel=i~+1` for surrogate pair(UTF16) */
  fun UnicodeN(sel:Range[Idx])
  fun UnicodeAt(:Idx)


  fun lines


  fun Trie



/** `add("1"[0~1]).add(*'a'~'z')` */
type StrBuild:
  @Below(3, ''' fun _:This = VMOp.xx''')
  fun add(: Args[Chars?])
  fun addLn(: Chars) fun addLn

/** See immutable [Str], [StrBuild] */
type Chars Ary[Char]
  /** Use `Regex.Flag.empty()-G` for only-first matching */
  fun replace(:Regex, :Fn1[Regrp,Str])Str
  fun replace(:Range[Idx], :Str)
  fun split
  fun `like`(:Regex)
  /** get substr for [Y](range or full), others for [N], then concat back. "a.2".partition(`first('.')?~NO`, `it`, "")=="2" */
  fun partition(:Fun1[Str]-RangeHalf[Idx]?, Y:FnNew[Str], N:FnNew[Str])
  /** [partition], if no match then `N(this)` */
  fun partition(:Regex, Y:FnNew[Str], N:FnNew[Str])

'N'fun Range[N].`+`(:N) = Range(A+n,B+n)
'N'fun Range[N].`-`(inner:Range[N]) Ary[Range<N]>


Chars.notBlank





fun Cnt.`**`(repeated: Fn0):
  var n this
  loop if n!=0: repeated(); n=n-1

fun Str?.`+`(orEmpty: Any?) = (this?:"")+(orEmpty?.Str ?:"")

-enum TermColor

''TermBicolor = Word_On[TermColor, TermColor]

fun Str.wasCall(c:) = LinkLn(this to c)

-fun LinkLn[]-Pair[Str,TermBicolor] as:
  fun as were Str:
    var*: lA; lB
    return joinStr(end=TermColor.glass.esc):[==s to (A on B)]
      B.esc.ifNew(lB)+A.esc.ifNew(lA)+s
  where
    fun Str.ifNew(:Var[Str])=(this==var).way("") : var.v=this; this
fun-data TermColor:
  fun as=this on glass

data Flag:
  -named:
    'E'(E:Enum) fun all()
    'E'(E:Enum) fun get(name:Str)

  impl? data Bit(name: String, ordinal: Int, mask=2**ordinal)

'This'impl?? data Enum(name: String, ordinal: Int) as CanSort



/** Ranged data, no get() or see() funs for [Set], [weak.Set] with only a size */
type Sized
  val size: Cnt
  val `empty` = size==0
val Ary[*].lastIdx Idx = size-1
val Ary[*].fullIdx = 0~lastIdx
@_("无则")
'T'(T:Sized) fun T.`ifEmpty`(vzero: T) = empty.way(vzero,this)
'T'(T:Sized) fun T.`ifEmptyOr`(forbids:FnTest[T], vzero: T) = (empty|forbits(this)).way(vzero,this)
'T'(T:Sized) fun T?.ifEmptyOrNO = ifEmptyOr(NO).as[T]

fun Chars.`ifBlank`(vzero: T) = isBlank.way(vzero,this)
fun Chars.`ifBlankOr`(forbids:FnTest[T], vzero: T) = (isBlank|forbits(this)).way(vzero,this)
fun T?.ifBlankOrNO = ifBlankOr(NO).as[T]

@_("空作0项")
'T'(T:Empty) fun T?.`orEmpty` = this?:empty()

/** `NO` means str "No xxx" */
eval fun Var[Any?].noAsNO(no=_("空 en No")) = when this:
  Var.V: "$no $name"
  Var.I: "$no #$i+1"
  Var.K: '$no "$k"'

/** [Line] with fixed size, not actually "Array" in JVM or tuple(`Ary[get T]`) in Py. see: unboxed [AryN], [Args] */
'T this'impl? data Ary() Sized Copy CanSee[T] Vars[T]
  fun get(:Idx): T
  /** Try to make 0-copy viewport(`subList`,.), or do [slice] */
  fun get(sel:Range[Idx]): This
  fun set(:Idx, x:T)
  fun set(sel:[Rn Idx], vs: Seq[T]) = vs.toIdx.see: [==x to i] this[i]=x
  fun set(sel:Range[Idx], fill: T) = set(seq, Seq.repeat(fill))
  /** for JDK:[System.arraycopy] */
  fun set(sel:Range[Idx], vs: Ary[Var<T]>) = (vs[0] to vs.getN(-1)!!).seen[Var.I]:
    System.arraycopy(a,A.i, this,0,B.i-A.i)
  impl fun see(op: Fn1[T]): fullIdx.see { op(this[it]) }
  -named Impl:
    /** Native impl for `T[]` type&VM operators. */
    'T'(T:Empty) fun wasCall(n:Cnt, init: Fn1[Idx, T]): AryN[T] = aryOfZeros(n).let:
      fullIdx.see: set(it, init(it))

  @Below(4, '''@SafeVariance("set T") ''')
  fun sort(ord:Sort=MinAt0, cmp:Fn2[T,T]-Sort)
  fun reverse
  /** sequence randomly shuffled */
  fun shuffle(ran=Random())
  val vars = seenLine: this[it].as[Var]
  /** defaults to 0-copy. but for [filter], even dup2 is better than *inplace* Bubble Sort's slow */
  fun seen(set:FnNew[T]) = let:
    toIdx.see:[==x to i] this[i]=x.set()

'TR'(R:CanSort) fun Ary[T].sortBy(ord:Sort=MinAt0, key:Fn1[T,R]) = sort(ord):[a,b] key(a).compare(key(b))
'T'(T:CanSort) fun Ary[T].sort(ord:Sort=MinAt0) = sortBy(ord,noOp)

'T'fun Ary[T].getN(ineg:Int) = lets:
  val i=(ineg<0).way(size+i, i)
  (i<size).way(`this[i]`, NO)
'TA'(A: CanAdd[T]) eval fun CanSee[T].copyTo(a=empty[A]()) = a.let { you.see: add(it) }

'T'(T Sort) fun Ary selectionSort
  (0~lastI):[i]
    (i.posR~lastI):[ri] this[i] must< this[ri]
here:
  'T'(T Sort)fun Var `must<`(r:Var)
    if v !< r.v: Any.swap(this,r)

/** May asList(for int[] do copy) to `Ary[T]`. On JVM [get] returns `int`, not `Integer` boxed,
  `Ary[Int]` can't do this for it can be a [Line]. Supports JVM `Object[]`, or [T]: Int,. for typed array */
'T'impl? eval data AryN() Ary[T]
/** Compile-time known expr list, use it for const expansion or destruct */
'T'eval data Args () Ary[T]
/** `fun pair(:ArgsName[Str, 2 to "ab"] )` */
'TK'(K: eval, K: Pair[Int,Str]) eval data ArgsName as Args[T]


/** means `Fn1[Flag<E]>` canBe `Fn1[Line<E]>`. NOTE member in class-named implicts 'eval impl' */
'E'fun Ary[Flag.Bit[]-E] as: Flag[E] = copyTo() // this(Fold.To(Flag[E]()): add(it) )

@_("可变")
Var
@_("晚设")
later = ("debug" in Platform.flag).way(Var(),Hint())
@_("值继承")
ByImpl
/** Run calcuation only when needed. May use `=Lazy` for thing-val & arg */
@_("懒")
'E'eval data ByLazy(@_("跨线程多次") thrCallTwice:Bool3=NO)
@_("值最新")
ByNewest

Platform
//值变；值晚；值懒；值改；值继承

at:
  urls (File/"top5.txt").lines lets: trim
  htmls urls.lets: req.get(this)

at num=Rw.PairOf(0,0)
htmls:[s]
  ('http(s?)://' has s).way[Var](num.A,num.B) goesR


data Bond
  ^named
    at here price=5

  - sell=TYPE lets:
    if price!<10: return $N
    price goesR
    return $Y
    
    - main(:[Ary Str])
      (1~3):
        Bond().sell
      say(price)


- main 
  at story Fun1[Animal]: speak()
  at c Animal.Cat
  c.story
  c.水豚.story

type Animal
  - speak Str
when-- as
  Cat; Dog(name:Str)

when- Dog.to Animal
^now
  - speak "good $name"
when- Cat.to Animal
^now
  - speak "meow"

when- Animal 水豚
^now
  - speak "..."

type 'AB'Way2 “Either”
  A(:A); B(:B)


type Animal
  - speak Str
-when as() Data
  Dog(name:Str) Cat Bat
-data Bat as Animal
  ^- speak="emm"

trait Aniaml{
  fn speak()->str
}
struct Dog;
impl Animal for Dog {
  fn speak(){return "good"}
}

type Geo
  fun area N
type Draw
  fun draw(:Graph)

- Point(:Arg["xy"N])@ourpkg impl?
  !fun Str="$x,$y"
- Rect(x,y, :Arg["wh"N]) Point()
  !fun Str=as[super].Str+"+$w,$h"
/*Smooth line
  better than polyline?
*/
/,py ,/ is good
/, it.draw(app.view) ,/ is correct
/, PrtScr(it{draw}) ,/ is good
/, dasdas ,/
- Spline(ps:Args[Point]) Draw
  !fun draw(g)
    ps.for1st {g.moveTo(it)}: g.lineTo(this)
    ps.zipWithNext:[==A to B] g.line(A,B)

-fun Rect as Geo
  !fun area=w*h

val kv = JSON.cat[KV[Str]-Any](buffer.Str)
kv: [==str to obj]
  say("name = $str\tvalue= $obj")

data Stud(name:Str, age:Int, birth:Date)

type Geo interface{func area() int}
type Point struct {x,y int}
type Rect struct {Point; w,h int}

?? Geo
  x Int; y Int
  - area Int
  Point()
  Rect'wh'(_:Int)

/*去水果店买苹果

  - 先得看看店是不是在营业
  - 如果有苹果的话，就买 1 个
  - 如果钱不够，就回家取钱再来*///

- Nerd buyFriut(:Store)
  store.isOpen or: "closed"!
  store["apple"] !isEmpty or: "no apples"!
  store["apple"]*1 let:
    you.canAfford(this).way {
      store["apple"] =: -1
    }: goHome();getMoney(this)

^now
  - Str`!`=error(this)
  ''StoreOpen=Store: it.isOpen

- Nerd buyFriut(:StoreOpen)
  store["apple"].must("have apples")*1 let:[$]
    if canAfford($):
      store["apple"] =: -1
    or: goHome();getMoney($)

- 数.它=判我，
  正书，(-1)去它。
  或，0。

- 数.它(：正书)=(-1)去它
- 数.它(：数)=0

'AB'(get) data Pair(:A,:B) Data Send
'ABC'(get) when- as
  Pair(:A,:B) Pair3(:A,:B,:C)

- lerp 'ABt'(:N)= (t)*B+(1-t)*A

at x: Either[Rw.Set[Int]]-Int = [3 2 ]()
x.A?.let: add 1
Must:
  Pair(2+3, 6).let(B=5).B==5

-'T' T as=Either.A(this)
'AB'when- Either
  A(v:A) B(v:B)
  at A /*get*/=mayAs[A]?.v
  - flip=way(B,A)
  'R'- way(A:Fn1[A],B:Fn1[B])

把data和 type(instance) 解偶就不需要子类关系 而能实现type，但真的很不模块化
我喜欢后者：

when- Calc
  N(:N)
  Op(:PairOf[Calc],k="+")

- `+`(e:Calc)=when e:
  N: e.n
  Op(a to b, "+"): +a + +b

data- Calc.Op1(k="-")
  “不支持 {+}”

这是 1事:N物(N定死了)，而 1物:N事 为

when- Calc
  - eval N
  N(:N)
    ^- eval=n
  Op(:PairOf[Calc],k="+")
    ^- eval=when k: "+": +a + +b

data- Calc.Op1(k="-")
  ^- eval=when k: "-": -(+you) 

把eval 改成 visit(:子类重载)R, 或者说 fun Op.seen():Int 就能解偶
把R改成Eval接口就能用新类型添加操作，也就像

type Eval
  - eval N
'R'when- Calc
  Op(PairOf[R]); N

type EvalX Eval
  - Str Str
data- [Calc.Op EvalX] as EvalX
  ^- eval=折叠两次eval

这样只添子类，也可以定义(新)操作。也可以在编译期，虽然不实用
Str lets: Op(N(2), N(0))

'R'type Exp
  - N(:N)R
  - Op(:PairOf[R],k="+")R

data- N.TYPE as Exp[N]
  - N(n)=n
  - Op(e, k)=e.lets: A+B
data- Str.TYPE as Exp[Str]
  - N(n)="$n"
  - Op(e, k)=e.lets: "$A${k}$B"

- addTypeExt(:[KtFileScope KtFile You], :Str)@ourpkg = whileAdding(str, T1):
  buildFn.lets(KtFunctionInfo)
  .lets(GeneratedTypeSpecExtension)
  .let:[T]
    addFunction(T.typeName):
      T.parameters.let{addParameter}
      addScopeLambdaBlock(T1)
      returnStatement[TypeSpec](T.typeBuilderStatement)

    addFunction(T.funcNameAddType):
      receiver(T1.generatedClass)
      T.parameters.let{addParameter} “删掉这个,fn(T)就能是this”
      addScopeLambdaBlock(T1)
      returnStatement(T.addTypeStatment)
-now
  at T1=Generated.TYPE
  at buildFn=you.get[KtClass]!.companionObjects.first
  .Seq.asOnly[KtNamedFunction].only: modifierList?.has PUBLIC
  .only: typeFqName == "com.squareup.kotlinpoet.TypeSpec.Builder"
  
  - You[KtFileScope KtFunction].addBy'str add'= addFunction(str):
    T.parameters.let{addParameter}; add()

data GeneratedTypeSpecExtension(typeBuilder:Str, param:Ln[ParamDef]) Data
    made:
      typeID typeBuilder('Builder$',to="Type")
      paramStr param.Str
      fnAdd typeID.to(Capitalize)
      stmtAdd "$typeName(${ paramStr.may{!isEmpty}? +"," }block).let()"

use! org jline
use! jline reader terminal
use! java.nio.charset.Charset

- main
  lets:
    at ln=s.readLine("中文>")
    s.printAbove("= $ln")
    loop()
^now
  at:
    s  TerminalBuilder.terminal() lets:
      LineReaderBuilder.builder().terminal(this).build()
    cfg Pair??(Env["file.encoding"], defaultCharset.name)
    chcp nt?.GetConsoleCP ??()

at nt=com.sun.jna.platform.win32.Kernel32.INSTANCE .may: "Windows" in Env["os.name"]

named Env
  - get==System.getProperty

- Ary[Int] mergeSort=go(0~lastI)
^now
  - [Int Len] go(:[Idx Rn]) = rn.div2:[I]
    now:
      //a,b 半都指向升序
      a (rn(B=I-1):go(this)).Seq
      b (rn(A=I):go(this)).Seq
      i rn.A
    loop if a.posR & b.posR:
      this[i:goesR]=popMin(a,b){get}
      a: this[i:goesR]=get(it)
      b: this[i:goesR]=get(it)
  -'NR' Rn.div2(:Fn1[Idx])
    (size/2).may{it!=0}:fn(it)
  
  -'TR'(R Sort) popMin(a:Seq,b:Seq,key:Fn1) = key(a) to key(b) lets:
      if A<B: a goesR; A
      or: b goesR; B

- Ary[Int] mergeSort=go(0~lastI)
^now
  - Ary[Int] go(:Rn[Idx]) = rn.size/2 lets:[d2]
    if d2==0: return
    at now:
      i rn.A
      N i+d2
      a (rn(B=N-1):go(this)).Seq
      b (rn(A=N):go(this)).Seq
      //a,b 半都指向升序

    loop if a.posR & b.posR:
      this[i]=get(a) to get(b) lets:
        if A<B: a goesR; A
        or: b goesR; B
      i goesR
    a: this[i]=get(it); i goesR
    b: this[i]=get(it); i goesR
//or “简化”代码
    loop if a.posR or b.posR: this[i:goesR]=when:
      !a.posR: get(b:goesR) ;;  !b.posR: get(a:goesR)
      or: get(a) to get(b) lets:
        if A<B: a goesR; A
        or: b goesR; B

'S'Arr=[S Len]

-'S'Arr qsort(A=0,B=n-1)
  A<B \: over
  sep2:[p]
    qsort(A,p-1)
    qsort(p+1,B)
^name
  - sep2 as:
    pv me.A
    now: i A+1; j B
    now $Y:
      now i<B  me.i<pv: i.goR
      now j>A  me.j>pv: j.goL
      i>j: over^2
      Var.swap(me.i,me.j)
    Var.swap(me.A,me.j)
    j
  - sep2(i=A+1,j=B) me.A:[pv]
    j>A  me.j\>pv: now(i,j-1)
    i<B  me.i\<pv: now(i+1,j)
    i<j : Var.swap(me.i,me.j); now()
    Var.swap(me.A,me.j) // [1 0 2]=>?
    j

- 'S'Arr qsort n>2 \{me} :
  me:[[p {xs}]] xs.is{<p}.qsort add [p] add xs.is{\>p}.qsort

- [Int Len] qsort(:[Idx Rn]) = rn:
- qsort(:[Ln You], :[Idx Rn]) = rn:
- Ary[Int] qsort(:Rn[Idx]) = rn:
  if A!<B: return
  at now:
    a=A; b=B
    mid this[A]
  loop if a<b:
    loop if a[b& get(b)]mid: b goesL
    this[a]=b //选中太小的b. 下同
    loop if a<b& get(a)<mid: a goesR
    this[b]=a
  this[A]=mid
  qsort(a~A-1); qsort(A+1~b)

- qsort(x:[[Int Len] You], A:Idx,B:Idx)
  at: p x[(A+B)/2]
  at: sep2 Fn2:[A B]
    loop x[a]<p: a=:+1
    loop x[b]>p: b=:-1
    loop(a!>b, a+1,b-1)
    Var.swap(x[a],x[b])

    (a<B):qsort(x,a,B)
    (b>A):qsort(x,A,b)
  sep2(A,B)

- id(now,a=0,b=0)=as:
  loop(a!=0, a-1,b+1)
  b

-'T'(T Sort) quickSort(:[Ary You])=on(this,0,iLast)
^now
  - on(:Ary, A:Idx,B:Idx)
    A<B:
      at p=partition()
      on(A,p.posL); on(p.posR,B)
  ^now
    at partition=Fn0:
      at now: i A+1 j B
      at mid=ary[A]
      as:
        loop i!>B, ary[i]<mid: i.goesR
        loop j![A, ary[j]]mid: j.goesL
        loop(i!<j)
        Var.swap(ary[i],ary[j])
      Var.swap(ary[A],ary[j])
      j

-'T'(T Sort) Ary qsort(rn=iEach)
  rn: sep2(this):[p] qsort(A,p-1); qsort(p+1,B)
^now
  - Rn[Idx] sep2(it:Ary)
    at mid=it[A]
    at now: a A+1 b B
    as:
      loop a!>B, it[a]<mid: a.goesR
      loop b![A, it[b]]mid: b.goesL
      loop(a!=b)
      less(a,b)
    less(A,b)
    return b
  ^now
    at less=Fn2:[A B]Var.swap(it[A],it[B])

- Ln[Int] qsort=zero{this}:
  this[0]:[p]
    (this{<p}+this{!<p}).qsort
- main
  d=[2 3 6 8 1 4].qsort

- qsort(it:[Int Len],range=iEach)=range: (A<B): “two”
  now:
    mid this[A]
    a A+1; b B
  as:
    a!>B, it[a]<mid loop: a.goesR
    b!<A, it[b]>mid loop: b.goesL
    loop(a!=b)
    less(a,b) “交换逆序ab”
  less(A,b“min”)
  qsort(it,A~b-1); qsort(it,b+1~B)
^now
  at less=Fn2:[A B]Var.swap(it[A],it[B])

-'KVR'(K Sort) KV.values(fn: Fn2[V K]-R) = rw.KV[K R]()|:[res]
  this:[k|v] res[k]=fn(v,k)

-'AB' zip2(a:Ln[A],b:Ln[B]) Ln[Pair]

accurateLrc  PLAYER!"not exist":
  path identity() .:
    "mpv":say.W("");NO
    "ElectronNCM","Qcm":
      getSongID:[meta] “get可以外提”
        meta["trackid"]!.Str.posR.sep(2,'/')[1]
        .as:[songID]
          songID|NeteaseLyricProvider()
    "YesPlayMusic":
      getSongID: it.url().strip("/trackid/")
    
    "feeluown":
      getSongID:
        it.url()?.strip("fuo:") {this|Use.Netease()}:
          strip("qq:") {this|Use.QQLyrics()}: NO
    or:NO  


[网见]
绝地
- 1指/上下左右  速览代码和鸟瞰图
- 2指/Alt(移动行 选区折叠/展开)  右执行 左命令
- 3指/Ctrl(移动项 选区+-1段/1词) 右调试 左文档
- 4指/Ctrl-Alt(向上下复制) 左右部标签
- Alt上下上下 n指操作选功能、复制/列选区
- Ctrl- 在每行选区首添加光标

鸟瞰图UI
- 双击添加书签、行号添加断点；右滑选区 、/鸟瞰:常驻
- 切分球拖拽-滑选 功能,文件:打开和拆分编辑 单击打开首功能  /球:添加 瞬移
- 左球可打开面板: 运行/符号表/mvn 调试 文件 插件 搜索
- 底板:  VCS 报错(终端) - 行号/+选区(书签,改动,问题) 缩进  编码,换行(转换) 语法
- inline标签、二进制格式-等价。所有菜单都可被固定

编辑
- 可Shift: Tab, Z, O, Alt-O N 缩进 撤销 打开 打开文件夹 新建
- P 跳到对应 Shift连击 随处搜索 L 打开于 F 搜索/替换 '/'注释选区或行 R重构
- Ctrl点击 跳到文件/声明-实现/引用
- CXV复制剪切粘贴 S W Q 保存 关标签 关窗口

‘编解码函数。 cat谈=load, cut吐=dump
也适于将问题谈为易懂概念再计算，如 `可同 ，pad(+1)去吐(234)是233 且 (!数())去谈做(3、「它+"0"」)是30。`
或者接龙：
`可同(UTF()、Base[64])去吐("你好ao")`
--
cat 谈
cut 吐
oncat 谈做
’“”
对何[AB] 类 可同
  - 谈（：A）：B
  - 吐（：B）：A

  !- 谈吐下(：A、改=函新[B]，它。)=吐(改(谈(a)))
  - 谈吐(a、改)=谈吐下(a、改)()
  ‘’- 谈吐(：A、改=函1[B 待<B]>，它。 )=待，吐(改(谈(a))! )。

  同名例
    恒- 受调用(pipe：组参[可同[_ _]]）类型递归[pipe]
    私下恒- 类型递归(项：组[类型]) = 项[0]的参[0] 令其，[A]
      类型.参(可同、A、项去叠(A)，[a b] b的参[0]可为a；b的参[1]。)

    物 数(进制：计）可同[文 数]
    物 UTF(字符集=默认）可同[字节 文]
      同名例
        量 支持：集[文]
        量 别名：表组[文 文]
        变文 默认="utf8"
    例 Base
      - 取(k：计）可同[文 字节]
      量 码表：改表[计 文]
      变文 pad="="

对何[AB] 物-「!」(原：可同）可同[B A]
  !- 谈（：B）=原去吐(b)
  !- 吐（：A）=原去谈(a)

对何[AB] - A.「到」(对应：B)=俩项(我、对应)
对何[读A读B] 储物 俩项(首：A、次：B)
  !- 文="($首 $次)"
对何[读A读B读C] 储物 俩项3(首：A、次：B、末：C)
  !- 文="($首 $次 $末)"

对何[读A读B读C] 判物 可为3
  A(值：A)；B(值：B)；C(值：C)

对何[读A读B] 判物 可为
  A(值：A)；B(值：B)
  对何[R] - 令(成：函1[B R]) = ，B(它)。
  对何[R] - 或(败：函1[A R]) = 路(败、无-)
  对何[LR] - 令(成：函1[B]-可为[L R]) = 路(无-)，成(它)。

  对何[ab] - 路(a：函1[A a]、b：函1[B b]) = 况 令其，
    判我属于，
      A，a(值)。B，b(值)。
对何[AB] -「!」(况：可为) = 况去路(可为「B」、可为「A」)


'R'物 待 @可定
  -「!」(：函续) @可定
  同名例
    对何[R]- 受调用(：函1[函续])
    对何[R]- 全(：组参[待]）组[R]
    对何[R]- 首(：组参[待]）R
    量 Main：协程上文
    量 IO：协程上文

'R'物 待完结：待
  - 入队
  - 撤队
  -「限时」

对何[R]- 待完(：函1[函续]）R

对何[R]- 待完(loop：协程队?、：函1[函续]）待完结

量 数.「阶乘」=(我是1)去路(1)，我左阶乘*我。
‘=(1~我)去叠算「*」的值 ’

宫水家 去首否，[她]
  名字是"三叶"且手机的聊天记录去数「发送者是"他"」>50
空则"忘了"

宫水家 去首不空，[她]
  她的名字 取否「是"三叶"」

楼，
  我，[人]
    若枪存于人的包，人被报警察；略过。

楼去看平(2)滤出「枪存于包」令「我被报警察」

说("你好~")
变数答案 初42
恒量 半百=50 “可以在局部使用”
量，
  整数 70
  小数 70.0
  显小 .1去作[浮4]

  名 "宽度"；值 94
  标签 名+值去文

3到5 ，[是苹果到橘子]
  '我有"${苹果}"个苹果
   我有'${苹果+橘子}'个水果
  '

文本变量，
  量购物单=改，{鱼 水 花}。
  购物单，我[1]=水瓶。添"颜料"
  造行(小二对船长、小王对机械师)，
    我[小王]=公关
  '$购物单'
  量 可缺：文?=你好
  '${可缺是空} ${可缺!!}'
  '${(2~<100)的末}'

量 空组：组[文]=空白
量 空字典=造表[文 文]

变数 得分初0
{75 43 103 87 12}，[分数]
  得分=得分+判分数 存于，
    0~50，1。否则，3。
    (0~50)(score). {$Y 1 $N 3}

0~<10 步2 令(说)

变，
  名 "鸟不拉斯基"作[文?]；问候 "吃了么"
名?，问候=名+问候。

文本变量，
  量建议=判你"甜椒"，
    芹菜，纤维素高。
    黄瓜、胡萝卜，干啃不错。
    略、判(你)似，
      "椒$"，"好辣"。
    否则，"炖汤"。

量 人物=文本变量，{:唐僧 人 孙悟空 猴 猪八戒 猪 沙僧 人}。
人物 ，[是人到型]
  说("$型 $人")
人物的键 带号，
  说("$次 $首")

文本变量，
  {名字 追求 喜爱颜色}到
  {玄奘 真经 空}
去令其，[问题到答案]
  问题带答案 ，
    说("你的${首}是什么？答曰，$次")

量数们=文本变量，{:
  质数{2 3 5 7 11 13}
  Fibo{1 1 2 3 5 8}
  平方{1 4 9 16 25}
}。

变数最大 初0
数们，[是种类到数]
  数，
    若我>最大，最大=我。

变数i初0
重复若i<10，i移右。“完成. i=10”
i=0；重复再若i<10，i移右。 “i=10. 但若有 i++, i完成时是11”

变数 二次初2
重复若二次<100，二次=「它*2」。
二次=2
重复再若二次<100，二次=「它*2」。

(0~<4)去叠(0)，首+次。

- 有你[文 文].「问好」="($你) 吃了么$我"
量本周：周=二
本周 ，
  "江小白"问好+"马东梅"问好

例物 周
  一；二；三；四
  五；六；日
  - 作="$名"；- 作=号+1

对何[数]
- 列[数]统计：仨[数]
  变，a +极大；b -极大；c 0
  我，[它]
    判，
      它[a，a=它。它]b，b=它。
    c=c+它
  回仨(a、b、c)

-『15』：数
  变数y初0；加()；回y
其中，
  - 加=令， y=「它+5」。

- 累加器(acc=0，说("好加!")。、n：数、：参颗粒化[1 1])数
  acc=acc+n；回acc

物 累加器(变acc=0，说("好加!")。)函1[数 数]
  - 受调用(n：数）数
    acc=acc+n；回acc

累加器()，
  我(7)必是7；我(3)必是10

对何[T]- 列 存匹配(：函试）@私下 真假
  我，
    若此函试()，回真。
  回假

- 符合(：数)=此数<10

{20 19 7 12}取否，存匹配(符合)。?，
  量a=令其，3*我。
  说(a+空白、a去序)
  a[0]<a[1]必真

- atoi(：文、进制=10)=此文去叠(0)，首*进制+ (次-'0')。
- itoa(：数、进制="0123456789")=此数去叠展(「交进制[它%d]；它/d」、「它是0」)去序逆去凑
“=(它%d)+(它/d是0)去路(""、「重复(它/d)」)”
其中，量d=进制的长。

量 资料：@传输 身份要求["消费者"]
  读，
    当前用户(用户服务「取资料」) (传输)
    空则，抛下Business错("")。

对何[T](T：可序) - 组.冒泡排序
  满针 ，[i]
    (0~i)，
      若我[它]不<我[i]，交换(i、它)。
      “交换(我[i]、我[它])”

对何[T] - 组.交换(A：针、B：针)
  我[A]=我[B]；我[B]=a
其中，量a=我[A]

对何[T] - 交换(A：可变、B：可变)
  A的值=B；B的值=a
其中，量a=A

- 说妖精(：参名组["妖精 能耐 原型 降服人" 文])=说("尽管精进$能耐，${妖精}仍被${降服人}制服，变回$原型")

文本变量，
  函1，说妖精("白骨精"、原型=枯骨 、降服人=孙悟空 、能耐=它)。(百般变化)

例 随机生成 App
  !- 起点 = 听去提("输入数目：")去数 ，[n]
    随机数集的首(n)去凑(" ") (说)
    说("<==以上$n 个")
    听去Enter

量 随机数集=列，
  量 池=内存池() “apr”
  重复若真，
    交 Random去nextInt(1、分配器=池)

‘py式文本流’
- 说(：值?) = 文件的std[1]，添此值去文；添"\n"。
量 说点=文件的std[1]「添」

量 配置=(文件/"hello" 到"text/*")去读去泡 作[文]

对何[T]恒- 造行(项：组参)=项去行 ‘项的满针 令其，项[我]。’

- 素数筛(n=20) 组(n、真) 令其，
  半 n/2；选 2~~半
  选，[a]
    选，[b]
      c a*b
      我[c-1]=c不>a ，
        若我“太大”，停下。
      “若c>a，停下。我[c-1]=假”
  选 滤不空，[i]
    (i是末针)必假
    i取否「我[i]」

- 起点  冰箱，
  门去开 塞入大象；门去关闭
  “冰箱的门“()” 塞入大象”
  量歌者=播放器()，加载("大象.wav")；时=0；态=播放。
  1去文，"+"+我。必 "+1"

例 冰箱
  例 门 有开闭
    !- 关闭 说
    - 开 我

  - 有开闭.「塞入」说
  “- 有开闭.「塞入」令，说；关闭()。”

- 起点(：组[文])
  恒量N 1_000
  量 亲 组(N、0)
  (0~[N)，[i] 亲[i]作<可变]的值=i 。
  “亲=组(N)「i」”
  变数，b；c。
  重复若听(b、c)，
    量a 亲[b]
    若亲[c]是a，停次。
    亲去作[组[]-可变]带号 ，[是x到i]
      若i是c，x的值=a。
    说({b c}去凑)

例物 喜爱程度
  爱；很爱；非常爱；私生饭

- 娱乐.夸夸群 @公开
  明星，
    话=判我多爱你，
      爱，"爱你！"。很爱，"永远给$名 打call！"。
      非常爱，"不要你以为，只要我以为"。

- 鸡兔(头：数、足：数)=
  列去乘((1~头)、(1~头) )“阶乘Xuniq” 去首，足是首*2+次*4。
  去令其，:"$首 鸡 $次 兔" 。

- 双主语[文 文件].find="$你/$名" ，
  你去列()?去展(至={我})，它去find。空则{我}

- 文件.find(：文)="$此文/$名" ，[fp]
  列()?去展(至={fp})，它去find(fp)。空则{fp}

对何[T]符=函2[T T]-T
对何[T]判物 式
  Op(a：T、b：T、f：符)；N(：T)
  - 值=判我，
    N(x)，x。Op(a、b、f)，f(a去值、b去值)。
  同名例
    对何[数]- 数.「+」是封「+」
    对何[T]恒- 封(：符)=函2[T T Op]，[a b] Op(a、b、此符)。

?? 'T'Expr
  Op(A:T,B:T,sym:Str)
  N(x:T)
  - eval me .:
    N: x
    Op sym .:
      "+": A.eval+B.eval

式，
  (1+2+3)去值

'T'符=Fn2[T T T]
'T'-when 式
  Op(a:T,b:T, f:符); N(:T)
  fun 值=when this:
    N(x):x  Op(a,b,f):f(a.值,b.值)
  -named
    'N'fun N.`+`== 封`+`
    'T'eval fun 封(：符)=Fn2[T T Op]，[a b] Op(a,b,此符)。

式 let:
  (1+2+3).值

“没有单行注释”
‘文档 **粗体** `示例` ’

书 com.example.jueju

- 起点
  量foo=10
  变，bar 10。bar=20
  量fooL：数8=10
  
  令，
    量，
      foo"你好"
      bar"你-\n今天好吗"
      baz"$foo\t耶"
    {foo bar baz} (说)
  
  量raw'
    我
    很多行
  '
  变文?，nul "abc"。
  量any：值 Obj
  说(nul?的长)；nul=空
  说(nul?的长 空则-1)
  
  说(hello())；说(hello(名="Jake"))
  :narg(1、2)
  量f=「它%2是0」
  (6~7)去序两半(f)
  量notZ=「它是0」的反
  (0~4)，[x]
    :"${notZ(x)} ${f的反}"
    
  :(某(1)+3 到 某(2)(4) )
  
  某点(1、2、4)，
    :我
    我(y=100) ，[p1]
      :p1
      量p1是 某点(a、b、c)
      :"$a $b $c"
    {我}，[是某点(a、b、c)]
      :"$a $b $c"
  
  {:"a"1 "b"2}，[是k到v]
    :"$k -> $v"
  {:"a"8 "b"7}，我["a"]必8；"a"存于K 必真；"z"存于K 必假。
  'c'存于"hello"
 
  改某点(7、4、9)，
    x=「它-2」
    y=「它+2」
    z左移
    我必 改某点(5、6、8)
    
  "abc"去拆 ，
    :"长度 首 我[1] 尾"
    改(我)，
      添"d"
      :"长度 尾"
  
  :"Hello, world!"去除('l')
  量，
    小 列(0)，它+1。[0~10]
    fib 列，
      变数，a 0；b 1。
      重复若真，
        量c=a+b；a=b；b=c；添c
        
    z (1~9)令其，我*3。去滤，我<20。(叠算，分组(f、行)。)去表，K去路 “if”("even"、"odd")到V。
  
  变，i 0。
  重复再若i<10，:i；i移右。
  判，
    i<7
    "你好"首为"你"
    否则
  判i，
    0、21
    1~20
  
此刻，
  - hello(名="明") "你好，$名！"
  - narg(n：组参[数]) n的长
  对何[T]量 函1[T 真假].反 「非 我去受调用(它)」

  物 某(x：数)
    -「+」(：数) x+此数
    - 受调用(：数) x*此数
    
  储物 某点(：组参名["xyz" 数])
  
  储物 改某点(变x：数、：组参名["yz" 数])
  
  - cast(x：值) 判x，
    真假，x。数，x>0。
    文，x不为空。否则，假。
    
  - 文.除(：字)=滤，[c]c不是此字。去文
  
  例物 Enum
    A；B；C
  例物 Enum(值：数)
    A(2)；B(3)；C(3)
    - 说=:"$值 $号"
  例 Obj
    - 文="${类型[Obj]的名}"
    
  储物 计数(变ac=0)
    - 移右=，ac移右。
    -「+」(n：可为[数 计数])=，ac+n去路(「它」、「它的ac」)。
    - 有(它：计数)=ac是它dac
    - 受写(i：针、x：数)
      ac=i+x
  -「-」(它：计数)=它，ac=-ac。

对何[R]类 Exp
  - Op(：俩[Exp]）R；- N(：数）R

“提早到编译期DSL,”
可定物 ExpA：Exp[数]
  !- Op是函1，[是a到b] a+b。
  !- N(：数)=此数

可定物 ExpB：Exp[文]
  !- Op是函1，[是a到b] "$a+$b"。
  !- N(：数)="$此数"

“双向扩展, 构造侧Visitor 能随便添子类/返回值”
对何[R]类 ExpN1：Exp
  - N1(：数)

可定物 ExpAN1：ExpA ExpN1
  !- Op是函1，[是a到b] a+b。
  !- N(：数)=此数
  !- N1(：数)=-此数

“要实现AB间互换 只需替换 ExpN1的实现”
对何[R] ExpN1.求= Op(N(1), N1(2))

“也可以让 R=Eval, 但依旧是把构造式当数据”
对何[] Eval=函0[数]


type'AB'(set A) Foo
  - apply(:A)B
  -'AR' map(:Fn1) [A R Foo]
  -'BR' chain(:[B R Foo]) [A R Foo]



ACC_PUBLIC (0x0001)
ACC_PRIVATE (0x0002)
ACC_PROTECTED (0x0004)
ACC_STATIC (0x0008)
ACC_FINAL (0x0010)
  ACC_SYNCHRONIZED (0x0020)
  ACC_BRIDGE (0x0040)
  ACC_VARARGS (0x0080)
  ACC_NATIVE (0x0100)
  ACC_ABSTRACT (0x0400)
  ACC_STRICT (0x0800)
  ACC_SYNTHETIC (0x1000)
-
  ACC_VOLATILE (0x0040)
  ACC_TRANSIENT (0x0080)
  ACC_SYNTHETIC (0x1000)
  ACC_ENUM (0x4000)

ACC_PUBLIC (0x0001)
ACC_FINAL (0x0010)
ACC_SUPER (0x0020)
ACC_INTERFACE (0x0200)
ACC_ABSTRACT (0x0400)
ACC_SYNTHETIC (0x1000)
ACC_ANNOTATION (0x2000)
ACC_ENUM (0x4000)

[P(7, 9, 10, 11,
8, 3, 4, 5, 6,
12, 1, 15, 16, 18), 
Class, FieldRef, MethodRef, InterfaceMethodRef,
String, Integer, Float, Long, Double,
NameAndType, Utf8, MethodHandle, MethodType, InvokeDynamic]

ClassFile: [u4 magic, u2 minor_version, u2 major_version, u2 constant_pool_count, cp_info constant_pool[constant_pool_count-1], u2 access_flags, u2 this_class, u2 super_class, u2 interfaces_count, u2 interfaces[interfaces_count], u2 fields_count, field_info fields[fields_count], u2 methods_count, method_info methods[methods_count], u2 attributes_count, attribute_info attributes[attributes_count]]

field_info: [u2, u2 iName, u2 iDesc, ['*',u2, attribute_info]]
method_info: 
attribute_info: [u2 attribute_name_index, u4 attribute_length, info[attribute_length]]

Builder 匿名单例 模板方法|type配置词典,name配置词器 扩展函数
适配器 装饰/代理 抽象类桥接|加构器 补充器
共享元 Context Factory(抽象)|加构器 type..OS协议工厂
单例 策略,外观,Controller 责任链,命令,组合|被函数、模块和事件式编程取代: 如静态^name, F.a1:[x]
Iter 观察者|被Rx和yield取代: Saw(0)=., Inc(0):+1
状态模式 Visitor模式|.:表,AStor
copy原型,备忘录|纯函数


factor
|1|1 #单参省略,
|N|N>0, [factor N-1]*N

def db/use (xx)
def User(id Str age Int)
a(User)| (0 18) ()
$getU == User(id 关键字参数), id=$0, MaxAt0(id)
CRUD(User, id)

User
|Int Str
|age id
|18 0
-- age
User  id=0

Add
|[[] y] y
|[[x0 x] y] [x0 [Add x y]]

friends
,gigity peter

friend
,[friends A B] [friends B A]

mother _ M
,[child M _]  [female M]

单恋
,[loves A B]  [\loves B A]

单恋 A
|loves(A R), !loves(R A)

friends
|john julia
|john jack

-- julia
friends,sam molly

[friend john V]

v
|color 0
|wolf 1
-- color
v|red green blue
cv X| [db X 0]

colorify A B C D E
|cv(A), cv(B), cv(C), cv(D), cv(E),
! A=B, ! A=C, ! A=D, ! A=E,
! B=C, ! C=D, ! D=E


v
|woman 0
|man 1
|loc 2
|weapon 3
-- man
v|george john robert
-- woman
v|barbara christine yolanda
-- loc
v|bath dining kitchen livin pantry study
-- weapon
v|bag firearm gas knife poison rope

Pantry=Gas, Pantry=X, Gas=X,

a(man Kitchen), 
!Kitchen in [Rope Knife Bag Firearm]

a(woman Bath), a(woman Study),
barbara=Bath, yolanda=Study

a(woman Rope), Rope=Study,

man(Livingroom), \+Livingroom=robert,
\+Knife=Dining,
\+yolanda=Pantry, \+yolanda=Study,
Firearm=george,


\+barbara=Bag, \+george=Bag, 
\+Bag=Bathroom, \+Bag=Dining,


one X| a(man X)|a(women X)

uniq_pplace A B C D E F
|one(A), one(B), one(C), 
 one(D), one(E), one(F),  
!A=B, !A=C, !A=D, !A=E, !A=F, 
!B=C, !B=D, !B=E, !B=F, 
!C=D, !C=E, !C=F, 
!D=E, !D=F, 
!E=F

murder X
|uniq_pplace[
  [Bath Dining Kitchen Livin Pantry Study]
  [bag firearm gas knife poison rope]
]


| 名字 | 相关语言 | 注释 |
| --- | --- | --- |
| Alan Perlis | ALGOL 和 APL | 语言设计的贡献者 |
| Gerald Sussman | Scheme | 编程语言的联合设计师（与 Guy Steele 一起），是 SICP 第一版和第二版的 Lisp 方言 |
| Daniel Friedman | Scheme | 杰出贡献者，也是许多编程教科书的作者 |
| Matthias Felleisen | Racket | Friedman 的学生，也是一个名为 Racket 的计划版本的共同设计者，该版本旨在用于实现编程语言 |
| Alan Kay | Smalltalk 和 Squeak | 联合设计师 |
| Mitchel Resnick | Scratch | 儿童编程语言的联合设计师 |
| Robert Bruce Findler,Matthew Flatt,Shriram Krishnamurthi | Racket | Felleisen 的学生、Racket 的共同开发者，并与他合着了《如何设计程序：编程和计算简介 (HtDP) 7》  ，该书旨在解决他们在教授 SICP 时发现的许多问题文本 |
| Casey Reas, Ben Fry | Processing | 架构师 |
| Lauren McCarthy | P5.js | 设计师 |
| Seymour Papert | Logo | Sussman 的论文导师和共同设计者，与 Wally Feurzeig 和 Cynthia Solomon 一起设计了 Logo（一种儿童语言），Abelson 也对此做出了贡献 |
| John Kemeny,Thomas Kurtz | BASIC | 发明人

- 九九
  td ["{b}{a}={a*b}" (a==b)("\n","")] .:
    (1~9)(a)
    (1~a)(b)
    //1~9:[a] 1~a:[b] ""
  say: '{td.Str(" ")}'



func Flock(n“seagulls”:Cnt)
  - conjoin(:Flock) this|:
    n=: +it.n
  - breed(:Flock) this|:
    n=: *it.n

- main
  a Flock(4); b Flock(2); c Flock(0)
  a.conjoin(c).breed(b) .conjoin(a.breed(b)).n
  “(4+0)*2 + 4*2”

  A 4; B 2; C 0
  conjoin(breed(conjoin(A,C), B), breed(A,B)):
    this==B*(A+A) “by [rules]”
^now
  - conjoin'ab' a+b
  - breed'ab' a*b

- rules'xyz'
  x+y==y+x
  (x+y)+z==x+(y+z)
  x+0==x
  x*(y+z)==(x*y+x*z)

at:
  hi Fn1:[name]'Hi {name}'
  _greeting Fn1:hi(it)
  greeting hi

-'T' [Seq T?] compact if{it!=NO}

- pureSlices
  xs [1 2 3 4 5]
  1~3:
    xs[0~2]
  1~3:
    xs.pop(0~~3)

  at _checkAge Fn1:[age] age!<min
  at checkAge Fn1:[age]
    at min 21
    age!<min
^now
  at min 21


- add'x' Fn1[Int]:[y] x+y


- id'ab'(b=0) as:
  now(a+1,b-1) : b==0
  a

- id(a:Int,b=0)
  now b!=0: a=a+1; b=b-1
  return a

id(a,b)=b if a==0 else id(a-1,b+1)
a\=0 {b}: id(a-1,b+1)

?? Nat
  Zero; Inc(:Nat)

- Nat `+`(b:Nat) b .:
  Zero: you
  Inc(B): Inc(you)+B

-'T'(T PosNeg) `-`(:T) it.not
?? 'u'PosNeg
  - not u
  - abs u

?? 'u'Num
  - `*`(:u)u
  - `+`sep`*`
  - `~`sep`+`
  - `<`sep`+`

?? Any
  - `==`sep`<` (:Any?)YN
- 'T'Var `=`sep`or`
  
?? YN
  - `,`sep`<` //默认
  - `or`sepR`,`  (:YN)


- http_error'stat' stat .:
  400: "Bad"
  404: say:'..'; "Not found"
  401 403: "Not allow"
  or: "Net wrong"

-'T' Ln cons(:Ln) ln .:
  []: me; [x {xs}]: (me add [x]).cons(xs)

point .:
  0|0:"Origin"
  0|y:"Y{y}"
  x|0:"X{x}"
  x|y:"{x},{y}" 

?? RGB
  R;G;B

[RGB.R]: me.{
  R"Red" or"Good"
}
?? Tree
  Sum(:[Tree Pairs])
  N(:N); Zero
- `+`(e:Tree)N e .:
  Zero: 0; N(n).: n!=0:n
  Sum(es): es(Sum(0): A+(+B))

"$ abc" .:
  (RE:'$ {s.[Str too]}'): s
  (RE:'$ {i.[Int too]}'): i

[1~35]*2 .:
  x!=0 .:
    x+y==35,4*x+2*y==94: say:'鸡{x}兔{y}'

[users posts] .:
  u.id<10, u==po.owner: "LEFT JOIN, not us[po.id]"

[x y] .:
  x+y==35
  4*x+2*y==94
  (1~35)(x,y)

[I] .:
  s[i]==me[I+i]
  s==me[I~~I+s.n]
  (0~~n-s.n)(I)

- Str sub(:Str) std.[IdxM1 as]:
  (0~n-s.n):[I]
    s.iEach:[i]
      s[i]\=me[I+i]: return^2
    return I
  return -1

    


at now: i 0
at addr (1~10):
  i= :+ 1
  x= :max y
  at use  Fn.[Int Str Int a2]:[x] x+i
- use(x:Int,:Str)


- main /??/
func App(home="", fs=(FS.ROOT /[etc mtab])) CLI('home ??')
  - main(:[Str Ln]) ln.n>0: say:'{ln[0]} {home}'
  - exist CPU.exit(fs zero{1}:0)
  - test(:FS) CPU.exit(Try{fs .r; 0} or 1)
  - os
    (CoFS:'false') .r:
      say: '{me.exited("failed","done")}'
  - sed(:FS)
    ""(fs): it(RE:'#.*', "")

- main
  a 1; b 2
  say: '{a}+{b}={a+b}'
  [[1] [2] [3]] .:
    a+b==c: say:'good ALU'

  [a.eachI]*2 .:
    i0\<i, s[i0+i]==s[i], i==n: say:'{i}'

  ints:[x] x .:
   x>3: 
   x==NO: 
  [ints] .:
    x!=NO: 
    x>3: 
- bmiTell(x:N) x:me .:
  >18.5: "underweight range"
  >25.0: "normal range"
  >30.0: "overweight range"
  or: "obese range"

- max'ab' a .:
  a>b: a ; or: b
- cmp'ab' a .:
  a<b: -1 ; a==b: 0 ; a>b: 1

- fact'nr'(r=1) as:
  now(n-1, n*n) : n==0
  r

- fib'nab'(b=1) as:
  now(n-1, b,a+b) : n==0
  b

- fib'n' n.{
  0 0 1 1 or fib(n-1)+fib(n-2)
}
- fib2'nab'(a=0,b=1) as:
  now(n-1,b,a+b) : n==0
  a

sum_of_bigger_than_2([{1~5}])
- sum_of_bigger_than_2(A:[Int Len]) as:
  now: i 0; sum 0
  now( i \< A.n):
    A[i]\>2 {sum =:+ A[i]}; i=i+1
  sum

- init
  double Fn.[Int A1]: *2
  small-than Fn.[Int a1]: Fn.[Int Bool a1]:[B] B<A 

  ls (1~5).Ln (double)(small-than(9))
  sum ls(Sum(0):A+B)
  len ls.Len
  dd=ls
  dd=sum; dd=len

?? 'T'Any
  Li(x:T, xs:Li?)

-'T' concat(:[Li? me], u:Li) me .:
  NO: u ; Li(x,rs): Li(x, rs.concat(u))

-'TR' map(:[Li? me], :Fn.a1) me .:
  NO: NO
  Li(x,rs): Li(fn(x), Fn.a2.map(rs,fn))

- levenshtein(ab:[Str Pairs])Int (ab:n):[n|m]
  at s (ab:Len(n+1, 0)).Len
  //for(j in 1..m) { s[0][j]=j }
  (1~m):[j] s[0][j]=j
  (1~n):[i] S(i,0)=i; (1~m):[j]
    S(i,j) = (ab.A[i-1]==ab.B[j-1]).{$N 1+pose $Y S(i-1,j-1)}
  s[1][j]
^name
  - S'ij' s[i.rem/2][j]
  - pose [S(i-1,j-1) S(i,j-1) S(i-1,j)](Sum: min(A,B))

- min'ab'(_:Int) (a\<b)(a,b)

at:
  a T(0) ; b T(2)
dd=(a+b).x
type Any
  T(x:Int)
    - `+`(other:T) T: -x x+other.x

at now T.A: a ; b B
say:
  'Hello a: {a} & b: {b} -- wow~'
  at: 🤣 "string" add " to" add " append"
  '{🤣}'

type T
  A ; B
  - Str me.{A"A" B"B"}

ary [1 3 6 8 20]
res ary.bsearch(20)
say: '{res}'

-'S' [S Ln] bsearch(:S) as:
  n==0 {-1}: find(0,iLast)
  return -1
names
  - find'AB' as:
    mid A+(B-A)/2
    S.sortFn(me[mid],u) .:
       0: return mid
       1: now(A,B-1)
      -1: now(A+1,B)

type User
  id seat.[Int too]
type User
  EmailUser(id:Int, email:[our Str]="")
  ^name
    - as(x0:Var, x1:Var) as:
      id==x0, email==x1

funcs Person(name:Str)
  children Inc.[Person Ln]
  - setSuper say:''
^name
  - as(name,parent:Person) as(name) : parent.children add me

now Student("",{}):
  stu ("San" {"语文"98})
?? Data
  Student(name:Str, testScore:[Str Int KV])

data'T' Inc.Set LogCollection()
  - add(:T) add(u) : say:'{u}'

- Person countryName std.[val as]: company?.address?.country \: "UNK"
(0~10 sep-1).Str:"{me},"
msg Message(): -recever "" -title ""
msg.send: d=me

d Dog("Zeus").doTricks
c Cat("Rusty").doTricks
- Pet doTricks as: walk();speak()add comeToMaster()

func Pet(name:Str)
  - walk say:
    'walking, {speak()}'
^??
  - speak "Yo"
  - comeToMaster

data Pet Dog()
  - speak "Woof"
  - comeToMaster "Hi"

data Pet Cat
  - speak "Meow"
  - comeToMaster "Nope"

name MyPet Pet
  now [our]: nLegs 4
  now: actuallyLikesPeople $N
^type
  furColor Str
