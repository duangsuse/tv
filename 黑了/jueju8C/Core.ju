pkg jueju

/** Any value(!=null) provided to fun-[Args]ument and val/vars, maybe const literal, system registry or user input.
  expr and its subexpr/vars comes with 1 value&type. types are implicitly `:(extends) Any` and canBe(it's subtype) [Break] */
/**: -å‚æ•°å’Œå˜é‡æ¥å—çš„ä»»æ„(éç©º)å€¼ï¼Œå¯èƒ½ç”±å¸¸é‡å­—é¢ã€ç³»ç»Ÿç™»è®°æˆ–äººç±»è¾“å…¥ã€‚
  ç®—å¼åŠå…¶å­å¼/æœ«ç«¯å•é‡éƒ½æœ‰1å€¼å’Œå…¶ç±»å‹ã€‚ä»»ä½•ç‰©ç±»éšå¼ `ï¼š(å±äº) å€¼` ä¸”å¯ä¸º(å³æœ‰å­ç±») [æ–­æ­¢] */ 
impl? data Any()
  /** Test content equality(provided any!=NO), see [CanSort]: math rules, [Vars]: memAddr equality */
  /**: å®ç°å†…å®¹ç›¸ç­‰æ€§ï¼Œä»»ä½•å€¼!=ç©ºï¼Œæ•°å­¦æ€§è´¨è§ [å¯åº], å†…å­˜åœ°å€ç›¸ç­‰è§ [å˜é‡é›†] */
  @_("æ˜¯") @CopyInfix(_("ä¸æ˜¯ en !="))
  fun `==`(:This): Bool = VMOp.eq
  /** Brief obj(&inners), rarely used outside debugging (except [StrBuild]). Add :[CanSend] for load/dump */
  /**: ç®€è¿°å¯¹è±¡å’Œå…¶å†…é¡¹æ•°æ®ï¼Œå¾ˆå°‘åœ¨è°ƒè¯•å¤–æœ‰ç”¨ï¼ˆé™¤åœ¨ [æ–‡æ‹¼]ï¼‰ã€‚å¯¼å…¥å¯¼å‡ºè¯·åŠ  :[CanSend] */
  fun Str: Str = VMOp.objStr
  /** Pregrouping key for optimizing [==] lookup, must pure(equals->sameHash)
    or [KV.get] becomes UB. Hashes are sparse like pseudo-[Random] */
  /**: ä¼˜åŒ–â€œé  [==] æŸ¥è¡¨â€çš„é¢„åˆ†ç»„çº¿ç´¢ï¼Œå¿…é¡»çº¯ï¼ˆç›¸ç­‰->æ•£åˆ—ç›¸åŒï¼‰
    å¦åˆ™ [è¡¨.å–] bugã€‚ç›¸é‚»å€¼æ•£åˆ—ä¸æ‰å †è¿™ç‚¹åƒä¼ª[éšæœº] */
  fun Hash: Int = VMOp.objID

  /** `Any` canBe `Str,Int,Ary`,. (`"" is Any`), if provided value implements([is]) [T] e.g. Str&you can't change type signature(e.g. Any), cast `any.as[Str]` is efficient
    for `int1.as[Int4]` widen, `int.as[Int1]` lose precision it's C-like(& lit-int=>float,Char!=Int2). for JVM APIs autoboxing `Ary[Int] == int[]` supported (slower). see [WasConvert] */
  /** å€¼å¯ä¸ºæ–‡,æ•°,ç»„,. ä¹Ÿå³ `"" å±äº å€¼`ã€‚è‹¥æä¾›çš„å€¼æœ‰å®ç°([is]) [T] å¦‚=[æ–‡]ï¼Œä¸”ä½ ä¸èƒ½ç²¾ç¡®åŒ–ç±»å‹ç­¾åå¦‚[å€¼]ï¼Œå¼ºè½¬ `æ­¤å€¼å»ä½œ[æ–‡]` ä¸æ…¢
    å¯¹æ•°1ä½œæ•°4 å®½åŒ–ã€æ•°4ä½œæ•°1 ç²¾åº¦ä¸¢å¤±å±Cè¯­è¨€æ—ï¼ˆä½†åªæœ‰å­—é¢int=>floatã€[å­—]!=[æ•°2]ï¼‰ã€‚å¯¹JVMæ¥å£ï¼Œæ”¯æŒç•¥æ…¢è‡ªåŠ¨è£…ç®±å¦‚ `ç»„[æ•°] == int[]`ã€‚è§ [WasConvert] */
  'T'impl! eval fun as: T = VMOp.checkcast
  /** Check if typeof this inherits [T], or have `class-named T This`. `class: named as XX: ` inherits, like [Empty]
    Such [Bool] infix supports `!is` and `when x is:` syntax. "type" is statically(compiler-time) known part whatever (func)value, or "def" order is, faster&safer */
  /** æ£€æŸ¥å€¼çš„ç±»å‹æ˜¯å¦ç»§æ‰¿[T]çš„å…¨å‘˜ï¼Œæˆ–æœ‰ `ç±»ä¾‹ T æˆ‘ç±»å‹`ã€‚ ç±»çš„æ— ååŒåä¾‹ä¼šè¢«ç»§æ‰¿å¦‚ [å€¼ç©º]ã€‚
    ç±»ä¼¼çœŸå‡å‡½æ•°æ”¯æŒ `ä¸å±äº` å’Œ `åˆ¤xå±äºï¼Œ` è¯­æ³•ã€‚å€¼çš„ç±»å‹/å‹å‚é™æ€(ç¼–è¯‘å™¨)å·²çŸ¥ã€‚æ— è®ºå€¼ç”±è°ä½•æ—¶æä¾›ï¼Œæ›´å¿«é€Ÿè€Œå®‰å…¨  */
  @_("å±äº")
  'T'impl! eval fun `is`: Bool = VMOp.instanceof

@Below(4+3, '''eval ''')
'T'fun Any.asMay = is[T].way(`as[T]`, NO)
@_("å­˜äº")
'T'fun T.`in`(set:[CanSee T]) = set.contains(this)
'N'fun `-`(:N): N = VMOp.neg
'N'fun `+`(:N) = n //later def N=Vec,Sort
@Below(3, '''@CopyInfix''')
@_("é")
fun `!`(q:Bool) = q.not //del "!!"
/**: åªèƒ½ `1ä¸>2` è€Œæ— â€œ1ä¸å¤§2â€ã€‚å¦è¿ç®—lteq "<=" */
'N'fun N.`>`(:N): Bool = VMOp.gt
/** [>] */
'N'fun N.`<`(:N): Bool = VMOp.lt

/** Any?=Any+NO: `null`, nullptr or None */
named NO: Any?
/** See [HalfRange] */
eval val Omit=NO

/** Instrinic stub, impls are inlined */
samepkg impl?? data VMOp
/** TO distinguish int & Integer(e.g. how Ary[Int] => Integer[]) , var on VMT changes */
samepkg impl?? data VMT
/** typeof `throw` or [Exec.exit], never has value so anydata canBe Break. `Any?<T<Break` in memberSet */
/**: `æŠ›ä¸‹` å’Œ [è¿›ç¨‹.ç»“æŸ] çš„ç±»å‹ï¼Œä¸è¿”å›å€¼æ•…ä»»ä½•ç±»å‹å¯ä¸ºæ–­æ­¢ã€‚è¯(æˆå‘˜)æ•°ä¸Š `å€¼?<T<æ–­æ­¢` */
impl! data Break

// scope fun
'T'fun T.takeIf(p:[FnTest T]) = p(this).way(this,NO)

// helper
eval fun TODO(reason:Str="I'm tired"): Break = throw ErrNoImpl(reason)
fun error(msg:Str): Break = throw ErrVars(msg)

fun require(q:Bool, msgr: Fn0[Str]):
  if !q: throw ErrArg(msgr())
'T'fun requireNot(it: T?, value: T?, msgr: Fn0[Str]): T
'T'fun requireNotNO

/** See [assert] for testing */
fun check(q:Bool, msgr: Fn0[Str])
'T'fun checkNot(it: T?, value: T?, msgr: Fn0[Str]): T

'R'fun trys(:Fn0[R]) = try { Res.Ok(fn()) } catch(CanThrow) { Res.Err(you) }

/** Switch `$Y` or `$N` (true|false) */
/**: åœ¨ `çœŸ` å’Œ `å‡` é—´é€‰æ‹© */
data Bool() CanSort
  /** use [!] instead */
  fun not: Bool = VMOp.not
  @_("ä¸”")
  fun `&`(:Bool): Bool = VMOp.and
  @_("æˆ–")
  fun `|`(:Bool): Bool = VMOp.or
  /** Only 1 Bool true? see [Int.xor] */
  /**: åªæœ‰ä¸€ä¸ªçœŸå€¼ï¼Ÿè§ [æ•°.xor] */
  fun xor(:Bool): Bool = VMOp.xor

@Compiled("bidir(-1,MinAt0,Eq,MaxAt0)")
-enum Sort(sign:Int):
  MinAt0(-1); MaxAt0(+1); Eq(0)
  //min,max
/** Type with comparator. to sort [compareTo] must: 0. not random (pure) 1. a=b&b=c&a=c (refl,identical & transitive) 2. a>b & b<a (!symmetric) */
'this'type CanSort:
  fun `compareTo`(:This): Sort
  //by rev nullsFirst  thenBy


@Compiled("bidir(-1,NO,$N,$Y)")
''Bool3 = Bool?

'AB'A.`to`(:B) = Pair(this,b)
/** Typical data with 2 [Vars]. use [PairOf] for (type)A=B, [Vec] for numeric AryæŒ‡é’ˆä¹Ÿæ˜¯ç”¨aåˆ°ks,å–(k) è¡¨ç¤º */
'AB'(get A B) - Pair(A:A,B:B) Send:
  impl fun toStr="$A:$B"
'ABC'(get A B C) - Pair3(A:A,B:B,C:C) Send:
  impl fun toStr="$A,$B,$C"
'T'PairOf=[Pair T T]
'T'PairOf3=Pair3[T,T,T]

'N'-when RangeHalf(A:N) as CanSee[N]:
  fun contains(:N) = n!<A
  fun see(:Fn1[N]) = (this step 1).see(fn)
  fun gotSize(it:Sized) = A~it.size

'N'data Range(A:N, B:N) as RangeHalf(A):
  fun contains(:N) = n![A & n!]B
  fun see(:Fn1[N]) = (this step 1).see(fn)
  fun moveAndPad(:Int,n:Cnt)

'N'RangeSub=PairOf[Range[N]?]

'TR'PairOf[T?].joinOr(v0:T, :Fn2[T,T,R]) = fn(A?:v0, B?:v0)

'N'fun N.`~`(:NO) = RangeHalf(this)
'N'fun N.`~`(last:N) = Range(this,last)
'N'fun N.`~+`(right:N) = Range(this,this+right)
/** `0~+-5` = Â±5 */
'N'fun N.`~+-`(pad:N) = Range(this-pad,this+pad)
'N'fun RangeHalf[N].`step`(d:N) = RangeStep(this,d)
'N'fun RangeHalf[N].`div`(:N) = this step (B-A)/n

/** `0~10 step 2`. [d]: delta, increment */
'N'data RangeStep(rn:RangeHalf, d:N) as CanSee[N]:
  fun see(:Fn1[N]):
    var N: i A; n B-1
    val fwd:Fn0[Bool] = (rn is Range).way( (b.remDiv(d).A==0).way(`i!=n`, `i<n`), `$Y`)
    loop if fwd(): fn(i); i=i+d
  fun contains(:N) = (n in rn)& n.remDiv(d).A==0

data Char() Zeros CKase CanSort:
  fun Int = as[Int]
  fun `+`(:Int) = (as[Int] + i).Char

  -named:
    eval val surrogate=(56320~57343).seen{Char} to (55296~56319).seen{Char}
    impl val N_BYTE = 2
    impl val sign = $N


'This'type CKase:
  var noCase=$N
  fun equals(:This)
  fun retype(need:Case, lo:Locale) = when need:
    Upcase: uppercase(lo)
    Lowcase: lowercase(lo)
    Title: titlecase(lo)
  fun contains(:Chars): Bool
  fun contains(:Regex): Bool
  fun split(:Arg[Str], n:Cnt=-1)
  fun split(:Args[Char], n:Cnt=-1)

  fun filter(p:FnTest[Char]) = filter[StrBuild](p).Str

  type Posited:
    fun with(sub:Str): Bool
    fun without(sub:Str)
    fun pad(n:Cnt, :Char)
    fun padLines(n:Cnt, :Char, lf=CKase.LF)
    /** reverses [pad] */
    fun trim: Str
    fun trimMargin(before: Str): Str
    val pad2pad
    maxOf

  -enum Case:
    Upcase; Lowcase; Title

  -named:
    'R'fun ignore(msdos:Fun1[CNoKase,R]) = CNoKase.msdos

/** `"stringæ–‡", "abc"` consts are of this type: [Chars] with Unicode, uppercase, sort support  */
data Str() Chars CKase CanSort:
  fun BGets(:Charset=UTF_8)

  /** `sel=i~+1` for surrogate pair(UTF16) */
  fun UnicodeN(sel:Range[Idx])
  fun UnicodeAt(:Idx)


  fun lines


  fun Trie



/** `add("1"[0~1]).add(*'a'~'z')` */
type StrBuild:
  @Below(3, ''' fun _:This = VMOp.xx''')
  fun add(: Args[Chars?])
  fun addLn(: Chars) fun addLn

/** See immutable [Str], [StrBuild] */
type Chars Ary[Char]
  /** Use `Regex.Flag.empty()-G` for only-first matching */
  fun replace(:Regex, :Fn1[Regrp,Str])Str
  fun replace(:Range[Idx], :Str)
  fun split
  fun `like`(:Regex)
  /** get substr for [Y](range or full), others for [N], then concat back. "a.2".partition(`first('.')?~NO`, `it`, "")=="2" */
  fun partition(:Fun1[Str]-RangeHalf[Idx]?, Y:FnNew[Str], N:FnNew[Str])
  /** [partition], if no match then `N(this)` */
  fun partition(:Regex, Y:FnNew[Str], N:FnNew[Str])

'N'fun Range[N].`+`(:N) = Range(A+n,B+n)
'N'fun Range[N].`-`(inner:Range[N]) Ary[Range<N]>


Chars.notBlank





fun Cnt.`**`(repeated: Fn0):
  var n this
  loop if n!=0: repeated(); n=n-1

fun Str?.`+`(orEmpty: Any?) = (this?:"")+(orEmpty?.Str ?:"")

-enum TermColor

''TermBicolor = Word_On[TermColor, TermColor]

fun Str.wasCall(c:) = LinkLn(this to c)

-fun LinkLn[]-Pair[Str,TermBicolor] as:
  fun as were Str:
    var*: lA; lB
    return joinStr(end=TermColor.glass.esc):[==s to (A on B)]
      B.esc.ifNew(lB)+A.esc.ifNew(lA)+s
  where
    fun Str.ifNew(:Var[Str])=(this==var).way("") : var.v=this; this
fun-data TermColor:
  fun as=this on glass

data Flag:
  -named:
    'E'(E:Enum) fun all()
    'E'(E:Enum) fun get(name:Str)

  impl? data Bit(name: String, ordinal: Int, mask=2**ordinal)

'This'impl?? data Enum(name: String, ordinal: Int) as CanSort



/** Ranged data, no get() or see() funs for [Set], [weak.Set] with only a size */
type Sized
  val size: Cnt
  val `empty` = size==0
val Ary[*].lastIdx Idx = size-1
val Ary[*].fullIdx = 0~lastIdx
@_("æ— åˆ™")
'T'(T:Sized) fun T.`ifEmpty`(vzero: T) = empty.way(vzero,this)
'T'(T:Sized) fun T.`ifEmptyOr`(forbids:FnTest[T], vzero: T) = (empty|forbits(this)).way(vzero,this)
'T'(T:Sized) fun T?.ifEmptyOrNO = ifEmptyOr(NO).as[T]

fun Chars.`ifBlank`(vzero: T) = isBlank.way(vzero,this)
fun Chars.`ifBlankOr`(forbids:FnTest[T], vzero: T) = (isBlank|forbits(this)).way(vzero,this)
fun T?.ifBlankOrNO = ifBlankOr(NO).as[T]

@_("ç©ºä½œ0é¡¹")
'T'(T:Empty) fun T?.`orEmpty` = this?:empty()

/** `NO` means str "No xxx" */
eval fun Var[Any?].noAsNO(no=_("ç©º en No")) = when this:
  Var.V: "$no $name"
  Var.I: "$no #$i+1"
  Var.K: '$no "$k"'

/** [Line] with fixed size, not actually "Array" in JVM or tuple(`Ary[get T]`) in Py. see: unboxed [AryN], [Args] */
'T this'impl? data Ary() Sized Copy CanSee[T] Vars[T]
  fun get(:Idx): T
  /** Try to make 0-copy viewport(`subList`,.), or do [slice] */
  fun get(sel:Range[Idx]): This
  fun set(:Idx, x:T)
  fun set(sel:[Rn Idx], vs: Seq[T]) = vs.toIdx.see: [==x to i] this[i]=x
  fun set(sel:Range[Idx], fill: T) = set(seq, Seq.repeat(fill))
  /** for JDK:[System.arraycopy] */
  fun set(sel:Range[Idx], vs: Ary[Var<T]>) = (vs[0] to vs.getN(-1)!!).seen[Var.I]:
    System.arraycopy(a,A.i, this,0,B.i-A.i)
  impl fun see(op: Fn1[T]): fullIdx.see { op(this[it]) }
  -named Impl:
    /** Native impl for `T[]` type&VM operators. */
    'T'(T:Empty) fun wasCall(n:Cnt, init: Fn1[Idx, T]): AryN[T] = aryOfZeros(n).let:
      fullIdx.see: set(it, init(it))

  @Below(4, '''@SafeVariance("set T") ''')
  fun sort(ord:Sort=MinAt0, cmp:Fn2[T,T]-Sort)
  fun reverse
  /** sequence randomly shuffled */
  fun shuffle(ran=Random())
  val vars = seenLine: this[it].as[Var]
  /** defaults to 0-copy. but for [filter], even dup2 is better than *inplace* Bubble Sort's slow */
  fun seen(set:FnNew[T]) = let:
    toIdx.see:[==x to i] this[i]=x.set()

'TR'(R:CanSort) fun Ary[T].sortBy(ord:Sort=MinAt0, key:Fn1[T,R]) = sort(ord):[a,b] key(a).compare(key(b))
'T'(T:CanSort) fun Ary[T].sort(ord:Sort=MinAt0) = sortBy(ord,noOp)

'T'fun Ary[T].getN(ineg:Int) = lets:
  val i=(ineg<0).way(size+i, i)
  (i<size).way(`this[i]`, NO)
'TA'(A: CanAdd[T]) eval fun CanSee[T].copyTo(a=empty[A]()) = a.let { you.see: add(it) }

'T'(T Sort) fun Ary selectionSort
  (0~lastI):[i]
    (i.posR~lastI):[ri] this[i] must< this[ri]
here:
  'T'(T Sort)fun Var `must<`(r:Var)
    if v !< r.v: Any.swap(this,r)

/** May asList(for int[] do copy) to `Ary[T]`. On JVM [get] returns `int`, not `Integer` boxed,
  `Ary[Int]` can't do this for it can be a [Line]. Supports JVM `Object[]`, or [T]: Int,. for typed array */
'T'impl? eval data AryN() Ary[T]
/** Compile-time known expr list, use it for const expansion or destruct */
'T'eval data Args () Ary[T]
/** `fun pair(:ArgsName[Str, 2 to "ab"] )` */
'TK'(K: eval, K: Pair[Int,Str]) eval data ArgsName as Args[T]


/** means `Fn1[Flag<E]>` canBe `Fn1[Line<E]>`. NOTE member in class-named implicts 'eval impl' */
'E'fun Ary[Flag.Bit[]-E] as: Flag[E] = copyTo() // this(Fold.To(Flag[E]()): add(it) )

@_("å¯å˜")
Var
@_("æ™šè®¾")
later = ("debug" in Platform.flag).way(Var(),Hint())
@_("å€¼ç»§æ‰¿")
ByImpl
/** Run calcuation only when needed. May use `=Lazy` for thing-val & arg */
@_("æ‡’")
'E'eval data ByLazy(@_("è·¨çº¿ç¨‹å¤šæ¬¡") thrCallTwice:Bool3=NO)
@_("å€¼æœ€æ–°")
ByNewest

Platform
//å€¼å˜ï¼›å€¼æ™šï¼›å€¼æ‡’ï¼›å€¼æ”¹ï¼›å€¼ç»§æ‰¿

at:
  urls (File/"top5.txt").lines lets: trim
  htmls urls.lets: req.get(this)

at num=Rw.PairOf(0,0)
htmls:[s]
  ('http(s?)://' has s).way[Var](num.A,num.B) goesR


data Bond
  ^named
    at here price=5

  - sell=TYPE lets:
    if price!<10: return $N
    price goesR
    return $Y
    
    - main(:[Ary Str])
      (1~3):
        Bond().sell
      say(price)


- main 
  at story Fun1[Animal]: speak()
  at c Animal.Cat
  c.story
  c.æ°´è±š.story

type Animal
  - speak Str
when-- as
  Cat; Dog(name:Str)

when- Dog.to Animal
^now
  - speak "good $name"
when- Cat.to Animal
^now
  - speak "meow"

when- Animal æ°´è±š
^now
  - speak "..."

type 'AB'Way2 â€œEitherâ€
  A(:A); B(:B)


type Animal
  - speak Str
-when as() Data
  Dog(name:Str) Cat Bat
-data Bat as Animal
  ^- speak="emm"

trait Aniaml{
  fn speak()->str
}
struct Dog;
impl Animal for Dog {
  fn speak(){return "good"}
}

type Geo
  fun area N
type Draw
  fun draw(:Graph)

- Point(:Arg["xy"N])@ourpkg impl?
  !fun Str="$x,$y"
- Rect(x,y, :Arg["wh"N]) Point()
  !fun Str=as[super].Str+"+$w,$h"
/*Smooth line
  better than polyline?
*/
/,py ,/ is good
/, it.draw(app.view) ,/ is correct
/, PrtScr(it{draw}) ,/ is good
/, dasdas ,/
- Spline(ps:Args[Point]) Draw
  !fun draw(g)
    ps.for1st {g.moveTo(it)}: g.lineTo(this)
    ps.zipWithNext:[==A to B] g.line(A,B)

-fun Rect as Geo
  !fun area=w*h

val kv = JSON.cat[KV[Str]-Any](buffer.Str)
kv: [==str to obj]
  say("name = $str\tvalue= $obj")

data Stud(name:Str, age:Int, birth:Date)

type Geo interface{func area() int}
type Point struct {x,y int}
type Rect struct {Point; w,h int}

?? Geo
  x Int; y Int
  - area Int
  Point()
  Rect'wh'(_:Int)

/*å»æ°´æœåº—ä¹°è‹¹æœ

  - å…ˆå¾—çœ‹çœ‹åº—æ˜¯ä¸æ˜¯åœ¨è¥ä¸š
  - å¦‚æœæœ‰è‹¹æœçš„è¯ï¼Œå°±ä¹° 1 ä¸ª
  - å¦‚æœé’±ä¸å¤Ÿï¼Œå°±å›å®¶å–é’±å†æ¥*///

- Nerd buyFriut(:Store)
  store.isOpen or: "closed"!
  store["apple"] !isEmpty or: "no apples"!
  store["apple"]*1 let:
    you.canAfford(this).way {
      store["apple"] =: -1
    }: goHome();getMoney(this)

^now
  - Str`!`=error(this)
  ''StoreOpen=Store: it.isOpen

- Nerd buyFriut(:StoreOpen)
  store["apple"].must("have apples")*1 let:[$]
    if canAfford($):
      store["apple"] =: -1
    or: goHome();getMoney($)

- æ•°.å®ƒ=åˆ¤æˆ‘ï¼Œ
  æ­£ä¹¦ï¼Œ(-1)å»å®ƒã€‚
  æˆ–ï¼Œ0ã€‚

- æ•°.å®ƒ(ï¼šæ­£ä¹¦)=(-1)å»å®ƒ
- æ•°.å®ƒ(ï¼šæ•°)=0

'AB'(get) data Pair(:A,:B) Data Send
'ABC'(get) when- as
  Pair(:A,:B) Pair3(:A,:B,:C)

- lerp 'ABt'(:N)= (t)*B+(1-t)*A

at x: Either[Rw.Set[Int]]-Int = [3 2 ]()
x.A?.let: add 1
Must:
  Pair(2+3, 6).let(B=5).B==5

-'T' T as=Either.A(this)
'AB'when- Either
  A(v:A) B(v:B)
  at A /*get*/=mayAs[A]?.v
  - flip=way(B,A)
  'R'- way(A:Fn1[A],B:Fn1[B])

æŠŠdataå’Œ type(instance) è§£å¶å°±ä¸éœ€è¦å­ç±»å…³ç³» è€Œèƒ½å®ç°typeï¼Œä½†çœŸçš„å¾ˆä¸æ¨¡å—åŒ–
æˆ‘å–œæ¬¢åè€…ï¼š

when- Calc
  N(:N)
  Op(:PairOf[Calc],k="+")

- `+`(e:Calc)=when e:
  N: e.n
  Op(a to b, "+"): +a + +b

data- Calc.Op1(k="-")
  â€œä¸æ”¯æŒ {+}â€

è¿™æ˜¯ 1äº‹:Nç‰©(Nå®šæ­»äº†)ï¼Œè€Œ 1ç‰©:Näº‹ ä¸º

when- Calc
  - eval N
  N(:N)
    ^- eval=n
  Op(:PairOf[Calc],k="+")
    ^- eval=when k: "+": +a + +b

data- Calc.Op1(k="-")
  ^- eval=when k: "-": -(+you) 

æŠŠeval æ”¹æˆ visit(:å­ç±»é‡è½½)R, æˆ–è€…è¯´ fun Op.seen():Int å°±èƒ½è§£å¶
æŠŠRæ”¹æˆEvalæ¥å£å°±èƒ½ç”¨æ–°ç±»å‹æ·»åŠ æ“ä½œï¼Œä¹Ÿå°±åƒ

type Eval
  - eval N
'R'when- Calc
  Op(PairOf[R]); N

type EvalX Eval
  - Str Str
data- [Calc.Op EvalX] as EvalX
  ^- eval=æŠ˜å ä¸¤æ¬¡eval

è¿™æ ·åªæ·»å­ç±»ï¼Œä¹Ÿå¯ä»¥å®šä¹‰(æ–°)æ“ä½œã€‚ä¹Ÿå¯ä»¥åœ¨ç¼–è¯‘æœŸï¼Œè™½ç„¶ä¸å®ç”¨
Str lets: Op(N(2), N(0))

'R'type Exp
  - N(:N)R
  - Op(:PairOf[R],k="+")R

data- N.TYPE as Exp[N]
  - N(n)=n
  - Op(e, k)=e.lets: A+B
data- Str.TYPE as Exp[Str]
  - N(n)="$n"
  - Op(e, k)=e.lets: "$A${k}$B"

- addTypeExt(:[KtFileScope KtFile You], :Str)@ourpkg = whileAdding(str, T1):
  buildFn.lets(KtFunctionInfo)
  .lets(GeneratedTypeSpecExtension)
  .let:[T]
    addFunction(T.typeName):
      T.parameters.let{addParameter}
      addScopeLambdaBlock(T1)
      returnStatement[TypeSpec](T.typeBuilderStatement)

    addFunction(T.funcNameAddType):
      receiver(T1.generatedClass)
      T.parameters.let{addParameter} â€œåˆ æ‰è¿™ä¸ª,fn(T)å°±èƒ½æ˜¯thisâ€
      addScopeLambdaBlock(T1)
      returnStatement(T.addTypeStatment)
-now
  at T1=Generated.TYPE
  at buildFn=you.get[KtClass]!.companionObjects.first
  .Seq.asOnly[KtNamedFunction].only: modifierList?.has PUBLIC
  .only: typeFqName == "com.squareup.kotlinpoet.TypeSpec.Builder"
  
  - You[KtFileScope KtFunction].addBy'str add'= addFunction(str):
    T.parameters.let{addParameter}; add()

data GeneratedTypeSpecExtension(typeBuilder:Str, param:Ln[ParamDef]) Data
    made:
      typeID typeBuilder('Builder$',to="Type")
      paramStr param.Str
      fnAdd typeID.to(Capitalize)
      stmtAdd "$typeName(${ paramStr.may{!isEmpty}? +"," }block).let()"

use! org jline
use! jline reader terminal
use! java.nio.charset.Charset

- main
  lets:
    at ln=s.readLine("ä¸­æ–‡>")
    s.printAbove("= $ln")
    loop()
^now
  at:
    s  TerminalBuilder.terminal() lets:
      LineReaderBuilder.builder().terminal(this).build()
    cfg Pair??(Env["file.encoding"], defaultCharset.name)
    chcp nt?.GetConsoleCP ??()

at nt=com.sun.jna.platform.win32.Kernel32.INSTANCE .may: "Windows" in Env["os.name"]

named Env
  - get==System.getProperty

- Ary[Int] mergeSort=go(0~lastI)
^now
  - [Int Len] go(:[Idx Rn]) = rn.div2:[I]
    now:
      //a,b åŠéƒ½æŒ‡å‘å‡åº
      a (rn(B=I-1):go(this)).Seq
      b (rn(A=I):go(this)).Seq
      i rn.A
    loop if a.posR & b.posR:
      this[i:goesR]=popMin(a,b){get}
      a: this[i:goesR]=get(it)
      b: this[i:goesR]=get(it)
  -'NR' Rn.div2(:Fn1[Idx])
    (size/2).may{it!=0}:fn(it)
  
  -'TR'(R Sort) popMin(a:Seq,b:Seq,key:Fn1) = key(a) to key(b) lets:
      if A<B: a goesR; A
      or: b goesR; B

- Ary[Int] mergeSort=go(0~lastI)
^now
  - Ary[Int] go(:Rn[Idx]) = rn.size/2 lets:[d2]
    if d2==0: return
    at now:
      i rn.A
      N i+d2
      a (rn(B=N-1):go(this)).Seq
      b (rn(A=N):go(this)).Seq
      //a,b åŠéƒ½æŒ‡å‘å‡åº

    loop if a.posR & b.posR:
      this[i]=get(a) to get(b) lets:
        if A<B: a goesR; A
        or: b goesR; B
      i goesR
    a: this[i]=get(it); i goesR
    b: this[i]=get(it); i goesR
//or â€œç®€åŒ–â€ä»£ç 
    loop if a.posR or b.posR: this[i:goesR]=when:
      !a.posR: get(b:goesR) ;;  !b.posR: get(a:goesR)
      or: get(a) to get(b) lets:
        if A<B: a goesR; A
        or: b goesR; B

'S'Arr=[S Len]

-'S'Arr qsort(A=0,B=n-1)
  A<B \: over
  sep2:[p]
    qsort(A,p-1)
    qsort(p+1,B)
^name
  - sep2 as:
    pv me.A
    now: i A+1; j B
    now $Y:
      now i<B  me.i<pv: i.goR
      now j>A  me.j>pv: j.goL
      i>j: over^2
      Var.swap(me.i,me.j)
    Var.swap(me.A,me.j)
    j
  - sep2(i=A+1,j=B) me.A:[pv]
    j>A  me.j\>pv: now(i,j-1)
    i<B  me.i\<pv: now(i+1,j)
    i<j : Var.swap(me.i,me.j); now()
    Var.swap(me.A,me.j) // [1 0 2]=>?
    j

- 'S'Arr qsort n>2 \{me} :
  me:[[p {xs}]] xs.is{<p}.qsort add [p] add xs.is{\>p}.qsort

- [Int Len] qsort(:[Idx Rn]) = rn:
- qsort(:[Ln You], :[Idx Rn]) = rn:
- Ary[Int] qsort(:Rn[Idx]) = rn:
  if A!<B: return
  at now:
    a=A; b=B
    mid this[A]
  loop if a<b:
    loop if a[b& get(b)]mid: b goesL
    this[a]=b //é€‰ä¸­å¤ªå°çš„b. ä¸‹åŒ
    loop if a<b& get(a)<mid: a goesR
    this[b]=a
  this[A]=mid
  qsort(a~A-1); qsort(A+1~b)

- qsort(x:[[Int Len] You], A:Idx,B:Idx)
  at: p x[(A+B)/2]
  at: sep2 Fn2:[A B]
    loop x[a]<p: a=:+1
    loop x[b]>p: b=:-1
    loop(a!>b, a+1,b-1)
    Var.swap(x[a],x[b])

    (a<B):qsort(x,a,B)
    (b>A):qsort(x,A,b)
  sep2(A,B)

- id(now,a=0,b=0)=as:
  loop(a!=0, a-1,b+1)
  b

-'T'(T Sort) quickSort(:[Ary You])=on(this,0,iLast)
^now
  - on(:Ary, A:Idx,B:Idx)
    A<B:
      at p=partition()
      on(A,p.posL); on(p.posR,B)
  ^now
    at partition=Fn0:
      at now: i A+1 j B
      at mid=ary[A]
      as:
        loop i!>B, ary[i]<mid: i.goesR
        loop j![A, ary[j]]mid: j.goesL
        loop(i!<j)
        Var.swap(ary[i],ary[j])
      Var.swap(ary[A],ary[j])
      j

-'T'(T Sort) Ary qsort(rn=iEach)
  rn: sep2(this):[p] qsort(A,p-1); qsort(p+1,B)
^now
  - Rn[Idx] sep2(it:Ary)
    at mid=it[A]
    at now: a A+1 b B
    as:
      loop a!>B, it[a]<mid: a.goesR
      loop b![A, it[b]]mid: b.goesL
      loop(a!=b)
      less(a,b)
    less(A,b)
    return b
  ^now
    at less=Fn2:[A B]Var.swap(it[A],it[B])

- Ln[Int] qsort=zero{this}:
  this[0]:[p]
    (this{<p}+this{!<p}).qsort
- main
  d=[2 3 6 8 1 4].qsort

- qsort(it:[Int Len],range=iEach)=range: (A<B): â€œtwoâ€
  now:
    mid this[A]
    a A+1; b B
  as:
    a!>B, it[a]<mid loop: a.goesR
    b!<A, it[b]>mid loop: b.goesL
    loop(a!=b)
    less(a,b) â€œäº¤æ¢é€†åºabâ€
  less(A,bâ€œminâ€)
  qsort(it,A~b-1); qsort(it,b+1~B)
^now
  at less=Fn2:[A B]Var.swap(it[A],it[B])

-'KVR'(K Sort) KV.values(fn: Fn2[V K]-R) = rw.KV[K R]()|:[res]
  this:[k|v] res[k]=fn(v,k)

-'AB' zip2(a:Ln[A],b:Ln[B]) Ln[Pair]

accurateLrc  PLAYER!"not exist":
  path identity() .:
    "mpv":say.W("");NO
    "ElectronNCM","Qcm":
      getSongID:[meta] â€œgetå¯ä»¥å¤–æâ€
        meta["trackid"]!.Str.posR.sep(2,'/')[1]
        .as:[songID]
          songID|NeteaseLyricProvider()
    "YesPlayMusic":
      getSongID: it.url().strip("/trackid/")
    
    "feeluown":
      getSongID:
        it.url()?.strip("fuo:") {this|Use.Netease()}:
          strip("qq:") {this|Use.QQLyrics()}: NO
    or:NO  


[ç½‘è§]
ç»åœ°
- 1æŒ‡/ä¸Šä¸‹å·¦å³  é€Ÿè§ˆä»£ç å’Œé¸Ÿç°å›¾
- 2æŒ‡/Alt(ç§»åŠ¨è¡Œ é€‰åŒºæŠ˜å /å±•å¼€)  å³æ‰§è¡Œ å·¦å‘½ä»¤
- 3æŒ‡/Ctrl(ç§»åŠ¨é¡¹ é€‰åŒº+-1æ®µ/1è¯) å³è°ƒè¯• å·¦æ–‡æ¡£
- 4æŒ‡/Ctrl-Alt(å‘ä¸Šä¸‹å¤åˆ¶) å·¦å³éƒ¨æ ‡ç­¾
- Altä¸Šä¸‹ä¸Šä¸‹ næŒ‡æ“ä½œé€‰åŠŸèƒ½ã€å¤åˆ¶/åˆ—é€‰åŒº
- Ctrl- åœ¨æ¯è¡Œé€‰åŒºé¦–æ·»åŠ å…‰æ ‡

é¸Ÿç°å›¾UI
- åŒå‡»æ·»åŠ ä¹¦ç­¾ã€è¡Œå·æ·»åŠ æ–­ç‚¹ï¼›å³æ»‘é€‰åŒº ã€/é¸Ÿç°:å¸¸é©»
- åˆ‡åˆ†çƒæ‹–æ‹½-æ»‘é€‰ åŠŸèƒ½,æ–‡ä»¶:æ‰“å¼€å’Œæ‹†åˆ†ç¼–è¾‘ å•å‡»æ‰“å¼€é¦–åŠŸèƒ½  /çƒ:æ·»åŠ  ç¬ç§»
- å·¦çƒå¯æ‰“å¼€é¢æ¿: è¿è¡Œ/ç¬¦å·è¡¨/mvn è°ƒè¯• æ–‡ä»¶ æ’ä»¶ æœç´¢
- åº•æ¿:  VCS æŠ¥é”™(ç»ˆç«¯) - è¡Œå·/+é€‰åŒº(ä¹¦ç­¾,æ”¹åŠ¨,é—®é¢˜) ç¼©è¿›  ç¼–ç ,æ¢è¡Œ(è½¬æ¢) è¯­æ³•
- inlineæ ‡ç­¾ã€äºŒè¿›åˆ¶æ ¼å¼-ç­‰ä»·ã€‚æ‰€æœ‰èœå•éƒ½å¯è¢«å›ºå®š

ç¼–è¾‘
- å¯Shift: Tab, Z, O, Alt-O N ç¼©è¿› æ’¤é”€ æ‰“å¼€ æ‰“å¼€æ–‡ä»¶å¤¹ æ–°å»º
- P è·³åˆ°å¯¹åº” Shiftè¿å‡» éšå¤„æœç´¢ L æ‰“å¼€äº F æœç´¢/æ›¿æ¢ '/'æ³¨é‡Šé€‰åŒºæˆ–è¡Œ Ré‡æ„
- Ctrlç‚¹å‡» è·³åˆ°æ–‡ä»¶/å£°æ˜-å®ç°/å¼•ç”¨
- CXVå¤åˆ¶å‰ªåˆ‡ç²˜è´´ S W Q ä¿å­˜ å…³æ ‡ç­¾ å…³çª—å£

â€˜ç¼–è§£ç å‡½æ•°ã€‚ catè°ˆ=load, cutå=dump
ä¹Ÿé€‚äºå°†é—®é¢˜è°ˆä¸ºæ˜“æ‡‚æ¦‚å¿µå†è®¡ç®—ï¼Œå¦‚ `å¯åŒ ï¼Œpad(+1)å»å(234)æ˜¯233 ä¸” (!æ•°())å»è°ˆåš(3ã€ã€Œå®ƒ+"0"ã€)æ˜¯30ã€‚`
æˆ–è€…æ¥é¾™ï¼š
`å¯åŒ(UTF()ã€Base[64])å»å("ä½ å¥½ao")`
--
cat è°ˆ
cut å
oncat è°ˆåš
â€™â€œâ€
å¯¹ä½•[AB] ç±» å¯åŒ
  - è°ˆï¼ˆï¼šAï¼‰ï¼šB
  - åï¼ˆï¼šBï¼‰ï¼šA

  !- è°ˆåä¸‹(ï¼šAã€æ”¹=å‡½æ–°[B]ï¼Œå®ƒã€‚)=å(æ”¹(è°ˆ(a)))
  - è°ˆå(aã€æ”¹)=è°ˆåä¸‹(aã€æ”¹)()
  â€˜â€™- è°ˆå(ï¼šAã€æ”¹=å‡½1[B å¾…<B]>ï¼Œå®ƒã€‚ )=å¾…ï¼Œå(æ”¹(è°ˆ(a))! )ã€‚

  åŒåä¾‹
    æ’- å—è°ƒç”¨(pipeï¼šç»„å‚[å¯åŒ[_ _]]ï¼‰ç±»å‹é€’å½’[pipe]
    ç§ä¸‹æ’- ç±»å‹é€’å½’(é¡¹ï¼šç»„[ç±»å‹]) = é¡¹[0]çš„å‚[0] ä»¤å…¶ï¼Œ[A]
      ç±»å‹.å‚(å¯åŒã€Aã€é¡¹å»å (A)ï¼Œ[a b] bçš„å‚[0]å¯ä¸ºaï¼›bçš„å‚[1]ã€‚)

    ç‰© æ•°(è¿›åˆ¶ï¼šè®¡ï¼‰å¯åŒ[æ–‡ æ•°]
    ç‰© UTF(å­—ç¬¦é›†=é»˜è®¤ï¼‰å¯åŒ[å­—èŠ‚ æ–‡]
      åŒåä¾‹
        é‡ æ”¯æŒï¼šé›†[æ–‡]
        é‡ åˆ«åï¼šè¡¨ç»„[æ–‡ æ–‡]
        å˜æ–‡ é»˜è®¤="utf8"
    ä¾‹ Base
      - å–(kï¼šè®¡ï¼‰å¯åŒ[æ–‡ å­—èŠ‚]
      é‡ ç è¡¨ï¼šæ”¹è¡¨[è®¡ æ–‡]
      å˜æ–‡ pad="="

å¯¹ä½•[AB] ç‰©-ã€Œ!ã€(åŸï¼šå¯åŒï¼‰å¯åŒ[B A]
  !- è°ˆï¼ˆï¼šBï¼‰=åŸå»å(b)
  !- åï¼ˆï¼šAï¼‰=åŸå»è°ˆ(a)

å¯¹ä½•[AB] - A.ã€Œåˆ°ã€(å¯¹åº”ï¼šB)=ä¿©é¡¹(æˆ‘ã€å¯¹åº”)
å¯¹ä½•[è¯»Aè¯»B] å‚¨ç‰© ä¿©é¡¹(é¦–ï¼šAã€æ¬¡ï¼šB)
  !- æ–‡="($é¦– $æ¬¡)"
å¯¹ä½•[è¯»Aè¯»Bè¯»C] å‚¨ç‰© ä¿©é¡¹3(é¦–ï¼šAã€æ¬¡ï¼šBã€æœ«ï¼šC)
  !- æ–‡="($é¦– $æ¬¡ $æœ«)"

å¯¹ä½•[è¯»Aè¯»Bè¯»C] åˆ¤ç‰© å¯ä¸º3
  A(å€¼ï¼šA)ï¼›B(å€¼ï¼šB)ï¼›C(å€¼ï¼šC)

å¯¹ä½•[è¯»Aè¯»B] åˆ¤ç‰© å¯ä¸º
  A(å€¼ï¼šA)ï¼›B(å€¼ï¼šB)
  å¯¹ä½•[R] - ä»¤(æˆï¼šå‡½1[B R]) = ï¼ŒB(å®ƒ)ã€‚
  å¯¹ä½•[R] - æˆ–(è´¥ï¼šå‡½1[A R]) = è·¯(è´¥ã€æ— -)
  å¯¹ä½•[LR] - ä»¤(æˆï¼šå‡½1[B]-å¯ä¸º[L R]) = è·¯(æ— -)ï¼Œæˆ(å®ƒ)ã€‚

  å¯¹ä½•[ab] - è·¯(aï¼šå‡½1[A a]ã€bï¼šå‡½1[B b]) = å†µ ä»¤å…¶ï¼Œ
    åˆ¤æˆ‘å±äºï¼Œ
      Aï¼Œa(å€¼)ã€‚Bï¼Œb(å€¼)ã€‚
å¯¹ä½•[AB] -ã€Œ!ã€(å†µï¼šå¯ä¸º) = å†µå»è·¯(å¯ä¸ºã€ŒBã€ã€å¯ä¸ºã€ŒAã€)


'R'ç‰© å¾… @å¯å®š
  -ã€Œ!ã€(ï¼šå‡½ç»­) @å¯å®š
  åŒåä¾‹
    å¯¹ä½•[R]- å—è°ƒç”¨(ï¼šå‡½1[å‡½ç»­])
    å¯¹ä½•[R]- å…¨(ï¼šç»„å‚[å¾…]ï¼‰ç»„[R]
    å¯¹ä½•[R]- é¦–(ï¼šç»„å‚[å¾…]ï¼‰R
    é‡ Mainï¼šåç¨‹ä¸Šæ–‡
    é‡ IOï¼šåç¨‹ä¸Šæ–‡

'R'ç‰© å¾…å®Œç»“ï¼šå¾…
  - å…¥é˜Ÿ
  - æ’¤é˜Ÿ
  -ã€Œé™æ—¶ã€

å¯¹ä½•[R]- å¾…å®Œ(ï¼šå‡½1[å‡½ç»­]ï¼‰R

å¯¹ä½•[R]- å¾…å®Œ(loopï¼šåç¨‹é˜Ÿ?ã€ï¼šå‡½1[å‡½ç»­]ï¼‰å¾…å®Œç»“

é‡ æ•°.ã€Œé˜¶ä¹˜ã€=(æˆ‘æ˜¯1)å»è·¯(1)ï¼Œæˆ‘å·¦é˜¶ä¹˜*æˆ‘ã€‚
â€˜=(1~æˆ‘)å»å ç®—ã€Œ*ã€çš„å€¼ â€™

å®«æ°´å®¶ å»é¦–å¦ï¼Œ[å¥¹]
  åå­—æ˜¯"ä¸‰å¶"ä¸”æ‰‹æœºçš„èŠå¤©è®°å½•å»æ•°ã€Œå‘é€è€…æ˜¯"ä»–"ã€>50
ç©ºåˆ™"å¿˜äº†"

å®«æ°´å®¶ å»é¦–ä¸ç©ºï¼Œ[å¥¹]
  å¥¹çš„åå­— å–å¦ã€Œæ˜¯"ä¸‰å¶"ã€

æ¥¼ï¼Œ
  æˆ‘ï¼Œ[äºº]
    è‹¥æªå­˜äºäººçš„åŒ…ï¼Œäººè¢«æŠ¥è­¦å¯Ÿï¼›ç•¥è¿‡ã€‚

æ¥¼å»çœ‹å¹³(2)æ»¤å‡ºã€Œæªå­˜äºåŒ…ã€ä»¤ã€Œæˆ‘è¢«æŠ¥è­¦å¯Ÿã€

è¯´("ä½ å¥½~")
å˜æ•°ç­”æ¡ˆ åˆ42
æ’é‡ åŠç™¾=50 â€œå¯ä»¥åœ¨å±€éƒ¨ä½¿ç”¨â€
é‡ï¼Œ
  æ•´æ•° 70
  å°æ•° 70.0
  æ˜¾å° .1å»ä½œ[æµ®4]

  å "å®½åº¦"ï¼›å€¼ 94
  æ ‡ç­¾ å+å€¼å»æ–‡

3åˆ°5 ï¼Œ[æ˜¯è‹¹æœåˆ°æ©˜å­]
  'æˆ‘æœ‰"${è‹¹æœ}"ä¸ªè‹¹æœ
   æˆ‘æœ‰'${è‹¹æœ+æ©˜å­}'ä¸ªæ°´æœ
  '

æ–‡æœ¬å˜é‡ï¼Œ
  é‡è´­ç‰©å•=æ”¹ï¼Œ{é±¼ æ°´ èŠ±}ã€‚
  è´­ç‰©å•ï¼Œæˆ‘[1]=æ°´ç“¶ã€‚æ·»"é¢œæ–™"
  é€ è¡Œ(å°äºŒå¯¹èˆ¹é•¿ã€å°ç‹å¯¹æœºæ¢°å¸ˆ)ï¼Œ
    æˆ‘[å°ç‹]=å…¬å…³
  '$è´­ç‰©å•'
  é‡ å¯ç¼ºï¼šæ–‡?=ä½ å¥½
  '${å¯ç¼ºæ˜¯ç©º} ${å¯ç¼º!!}'
  '${(2~<100)çš„æœ«}'

é‡ ç©ºç»„ï¼šç»„[æ–‡]=ç©ºç™½
é‡ ç©ºå­—å…¸=é€ è¡¨[æ–‡ æ–‡]

å˜æ•° å¾—åˆ†åˆ0
{75 43 103 87 12}ï¼Œ[åˆ†æ•°]
  å¾—åˆ†=å¾—åˆ†+åˆ¤åˆ†æ•° å­˜äºï¼Œ
    0~50ï¼Œ1ã€‚å¦åˆ™ï¼Œ3ã€‚
    (0~50)(score). {$Y 1 $N 3}

0~<10 æ­¥2 ä»¤(è¯´)

å˜ï¼Œ
  å "é¸Ÿä¸æ‹‰æ–¯åŸº"ä½œ[æ–‡?]ï¼›é—®å€™ "åƒäº†ä¹ˆ"
å?ï¼Œé—®å€™=å+é—®å€™ã€‚

æ–‡æœ¬å˜é‡ï¼Œ
  é‡å»ºè®®=åˆ¤ä½ "ç”œæ¤’"ï¼Œ
    èŠ¹èœï¼Œçº¤ç»´ç´ é«˜ã€‚
    é»„ç“œã€èƒ¡èåœï¼Œå¹²å•ƒä¸é”™ã€‚
    ç•¥ã€åˆ¤(ä½ )ä¼¼ï¼Œ
      "æ¤’$"ï¼Œ"å¥½è¾£"ã€‚
    å¦åˆ™ï¼Œ"ç‚–æ±¤"ã€‚

é‡ äººç‰©=æ–‡æœ¬å˜é‡ï¼Œ{:å”åƒ§ äºº å­™æ‚Ÿç©º çŒ´ çŒªå…«æˆ’ çŒª æ²™åƒ§ äºº}ã€‚
äººç‰© ï¼Œ[æ˜¯äººåˆ°å‹]
  è¯´("$å‹ $äºº")
äººç‰©çš„é”® å¸¦å·ï¼Œ
  è¯´("$æ¬¡ $é¦–")

æ–‡æœ¬å˜é‡ï¼Œ
  {åå­— è¿½æ±‚ å–œçˆ±é¢œè‰²}åˆ°
  {ç„å¥˜ çœŸç» ç©º}
å»ä»¤å…¶ï¼Œ[é—®é¢˜åˆ°ç­”æ¡ˆ]
  é—®é¢˜å¸¦ç­”æ¡ˆ ï¼Œ
    è¯´("ä½ çš„${é¦–}æ˜¯ä»€ä¹ˆï¼Ÿç­”æ›°ï¼Œ$æ¬¡")

é‡æ•°ä»¬=æ–‡æœ¬å˜é‡ï¼Œ{:
  è´¨æ•°{2 3 5 7 11 13}
  Fibo{1 1 2 3 5 8}
  å¹³æ–¹{1 4 9 16 25}
}ã€‚

å˜æ•°æœ€å¤§ åˆ0
æ•°ä»¬ï¼Œ[æ˜¯ç§ç±»åˆ°æ•°]
  æ•°ï¼Œ
    è‹¥æˆ‘>æœ€å¤§ï¼Œæœ€å¤§=æˆ‘ã€‚

å˜æ•°iåˆ0
é‡å¤è‹¥i<10ï¼Œiç§»å³ã€‚â€œå®Œæˆ. i=10â€
i=0ï¼›é‡å¤å†è‹¥i<10ï¼Œiç§»å³ã€‚ â€œi=10. ä½†è‹¥æœ‰ i++, iå®Œæˆæ—¶æ˜¯11â€

å˜æ•° äºŒæ¬¡åˆ2
é‡å¤è‹¥äºŒæ¬¡<100ï¼ŒäºŒæ¬¡=ã€Œå®ƒ*2ã€ã€‚
äºŒæ¬¡=2
é‡å¤å†è‹¥äºŒæ¬¡<100ï¼ŒäºŒæ¬¡=ã€Œå®ƒ*2ã€ã€‚

(0~<4)å»å (0)ï¼Œé¦–+æ¬¡ã€‚

- æœ‰ä½ [æ–‡ æ–‡].ã€Œé—®å¥½ã€="($ä½ ) åƒäº†ä¹ˆ$æˆ‘"
é‡æœ¬å‘¨ï¼šå‘¨=äºŒ
æœ¬å‘¨ ï¼Œ
  "æ±Ÿå°ç™½"é—®å¥½+"é©¬ä¸œæ¢…"é—®å¥½

ä¾‹ç‰© å‘¨
  ä¸€ï¼›äºŒï¼›ä¸‰ï¼›å››
  äº”ï¼›å…­ï¼›æ—¥
  - ä½œ="$å"ï¼›- ä½œ=å·+1

å¯¹ä½•[æ•°]
- åˆ—[æ•°]ç»Ÿè®¡ï¼šä»¨[æ•°]
  å˜ï¼Œa +æå¤§ï¼›b -æå¤§ï¼›c 0
  æˆ‘ï¼Œ[å®ƒ]
    åˆ¤ï¼Œ
      å®ƒ[aï¼Œa=å®ƒã€‚å®ƒ]bï¼Œb=å®ƒã€‚
    c=c+å®ƒ
  å›ä»¨(aã€bã€c)

-ã€15ã€ï¼šæ•°
  å˜æ•°yåˆ0ï¼›åŠ ()ï¼›å›y
å…¶ä¸­ï¼Œ
  - åŠ =ä»¤ï¼Œ y=ã€Œå®ƒ+5ã€ã€‚

- ç´¯åŠ å™¨(acc=0ï¼Œè¯´("å¥½åŠ !")ã€‚ã€nï¼šæ•°ã€ï¼šå‚é¢—ç²’åŒ–[1 1])æ•°
  acc=acc+nï¼›å›acc

ç‰© ç´¯åŠ å™¨(å˜acc=0ï¼Œè¯´("å¥½åŠ !")ã€‚)å‡½1[æ•° æ•°]
  - å—è°ƒç”¨(nï¼šæ•°ï¼‰æ•°
    acc=acc+nï¼›å›acc

ç´¯åŠ å™¨()ï¼Œ
  æˆ‘(7)å¿…æ˜¯7ï¼›æˆ‘(3)å¿…æ˜¯10

å¯¹ä½•[T]- åˆ— å­˜åŒ¹é…(ï¼šå‡½è¯•ï¼‰@ç§ä¸‹ çœŸå‡
  æˆ‘ï¼Œ
    è‹¥æ­¤å‡½è¯•()ï¼Œå›çœŸã€‚
  å›å‡

- ç¬¦åˆ(ï¼šæ•°)=æ­¤æ•°<10

{20 19 7 12}å–å¦ï¼Œå­˜åŒ¹é…(ç¬¦åˆ)ã€‚?ï¼Œ
  é‡a=ä»¤å…¶ï¼Œ3*æˆ‘ã€‚
  è¯´(a+ç©ºç™½ã€aå»åº)
  a[0]<a[1]å¿…çœŸ

- atoi(ï¼šæ–‡ã€è¿›åˆ¶=10)=æ­¤æ–‡å»å (0)ï¼Œé¦–*è¿›åˆ¶+ (æ¬¡-'0')ã€‚
- itoa(ï¼šæ•°ã€è¿›åˆ¶="0123456789")=æ­¤æ•°å»å å±•(ã€Œäº¤è¿›åˆ¶[å®ƒ%d]ï¼›å®ƒ/dã€ã€ã€Œå®ƒæ˜¯0ã€)å»åºé€†å»å‡‘
â€œ=(å®ƒ%d)+(å®ƒ/dæ˜¯0)å»è·¯(""ã€ã€Œé‡å¤(å®ƒ/d)ã€)â€
å…¶ä¸­ï¼Œé‡d=è¿›åˆ¶çš„é•¿ã€‚

é‡ èµ„æ–™ï¼š@ä¼ è¾“ èº«ä»½è¦æ±‚["æ¶ˆè´¹è€…"]
  è¯»ï¼Œ
    å½“å‰ç”¨æˆ·(ç”¨æˆ·æœåŠ¡ã€Œå–èµ„æ–™ã€) (ä¼ è¾“)
    ç©ºåˆ™ï¼ŒæŠ›ä¸‹Businessé”™("")ã€‚

å¯¹ä½•[T](Tï¼šå¯åº) - ç»„.å†’æ³¡æ’åº
  æ»¡é’ˆ ï¼Œ[i]
    (0~i)ï¼Œ
      è‹¥æˆ‘[å®ƒ]ä¸<æˆ‘[i]ï¼Œäº¤æ¢(iã€å®ƒ)ã€‚
      â€œäº¤æ¢(æˆ‘[i]ã€æˆ‘[å®ƒ])â€

å¯¹ä½•[T] - ç»„.äº¤æ¢(Aï¼šé’ˆã€Bï¼šé’ˆ)
  æˆ‘[A]=æˆ‘[B]ï¼›æˆ‘[B]=a
å…¶ä¸­ï¼Œé‡a=æˆ‘[A]

å¯¹ä½•[T] - äº¤æ¢(Aï¼šå¯å˜ã€Bï¼šå¯å˜)
  Açš„å€¼=Bï¼›Bçš„å€¼=a
å…¶ä¸­ï¼Œé‡a=A

- è¯´å¦–ç²¾(ï¼šå‚åç»„["å¦–ç²¾ èƒ½è€ åŸå‹ é™æœäºº" æ–‡])=è¯´("å°½ç®¡ç²¾è¿›$èƒ½è€ï¼Œ${å¦–ç²¾}ä»è¢«${é™æœäºº}åˆ¶æœï¼Œå˜å›$åŸå‹")

æ–‡æœ¬å˜é‡ï¼Œ
  å‡½1ï¼Œè¯´å¦–ç²¾("ç™½éª¨ç²¾"ã€åŸå‹=æ¯éª¨ ã€é™æœäºº=å­™æ‚Ÿç©º ã€èƒ½è€=å®ƒ)ã€‚(ç™¾èˆ¬å˜åŒ–)

ä¾‹ éšæœºç”Ÿæˆ App
  !- èµ·ç‚¹ = å¬å»æ("è¾“å…¥æ•°ç›®ï¼š")å»æ•° ï¼Œ[n]
    éšæœºæ•°é›†çš„é¦–(n)å»å‡‘(" ") (è¯´)
    è¯´("<==ä»¥ä¸Š$n ä¸ª")
    å¬å»Enter

é‡ éšæœºæ•°é›†=åˆ—ï¼Œ
  é‡ æ± =å†…å­˜æ± () â€œaprâ€
  é‡å¤è‹¥çœŸï¼Œ
    äº¤ Randomå»nextInt(1ã€åˆ†é…å™¨=æ± )

â€˜pyå¼æ–‡æœ¬æµâ€™
- è¯´(ï¼šå€¼?) = æ–‡ä»¶çš„std[1]ï¼Œæ·»æ­¤å€¼å»æ–‡ï¼›æ·»"\n"ã€‚
é‡ è¯´ç‚¹=æ–‡ä»¶çš„std[1]ã€Œæ·»ã€

é‡ é…ç½®=(æ–‡ä»¶/"hello" åˆ°"text/*")å»è¯»å»æ³¡ ä½œ[æ–‡]

å¯¹ä½•[T]æ’- é€ è¡Œ(é¡¹ï¼šç»„å‚)=é¡¹å»è¡Œ â€˜é¡¹çš„æ»¡é’ˆ ä»¤å…¶ï¼Œé¡¹[æˆ‘]ã€‚â€™

- ç´ æ•°ç­›(n=20) ç»„(nã€çœŸ) ä»¤å…¶ï¼Œ
  åŠ n/2ï¼›é€‰ 2~~åŠ
  é€‰ï¼Œ[a]
    é€‰ï¼Œ[b]
      c a*b
      æˆ‘[c-1]=cä¸>a ï¼Œ
        è‹¥æˆ‘â€œå¤ªå¤§â€ï¼Œåœä¸‹ã€‚
      â€œè‹¥c>aï¼Œåœä¸‹ã€‚æˆ‘[c-1]=å‡â€
  é€‰ æ»¤ä¸ç©ºï¼Œ[i]
    (iæ˜¯æœ«é’ˆ)å¿…å‡
    iå–å¦ã€Œæˆ‘[i]ã€

- èµ·ç‚¹  å†°ç®±ï¼Œ
  é—¨å»å¼€ å¡å…¥å¤§è±¡ï¼›é—¨å»å…³é—­
  â€œå†°ç®±çš„é—¨â€œ()â€ å¡å…¥å¤§è±¡â€
  é‡æ­Œè€…=æ’­æ”¾å™¨()ï¼ŒåŠ è½½("å¤§è±¡.wav")ï¼›æ—¶=0ï¼›æ€=æ’­æ”¾ã€‚
  1å»æ–‡ï¼Œ"+"+æˆ‘ã€‚å¿… "+1"

ä¾‹ å†°ç®±
  ä¾‹ é—¨ æœ‰å¼€é—­
    !- å…³é—­ è¯´
    - å¼€ æˆ‘

  - æœ‰å¼€é—­.ã€Œå¡å…¥ã€è¯´
  â€œ- æœ‰å¼€é—­.ã€Œå¡å…¥ã€ä»¤ï¼Œè¯´ï¼›å…³é—­()ã€‚â€

- èµ·ç‚¹(ï¼šç»„[æ–‡])
  æ’é‡N 1_000
  é‡ äº² ç»„(Nã€0)
  (0~[N)ï¼Œ[i] äº²[i]ä½œ<å¯å˜]çš„å€¼=i ã€‚
  â€œäº²=ç»„(N)ã€Œiã€â€
  å˜æ•°ï¼Œbï¼›cã€‚
  é‡å¤è‹¥å¬(bã€c)ï¼Œ
    é‡a äº²[b]
    è‹¥äº²[c]æ˜¯aï¼Œåœæ¬¡ã€‚
    äº²å»ä½œ[ç»„[]-å¯å˜]å¸¦å· ï¼Œ[æ˜¯xåˆ°i]
      è‹¥iæ˜¯cï¼Œxçš„å€¼=aã€‚
    è¯´({b c}å»å‡‘)

ä¾‹ç‰© å–œçˆ±ç¨‹åº¦
  çˆ±ï¼›å¾ˆçˆ±ï¼›éå¸¸çˆ±ï¼›ç§ç”Ÿé¥­

- å¨±ä¹.å¤¸å¤¸ç¾¤ @å…¬å¼€
  æ˜æ˜Ÿï¼Œ
    è¯=åˆ¤æˆ‘å¤šçˆ±ä½ ï¼Œ
      çˆ±ï¼Œ"çˆ±ä½ ï¼"ã€‚å¾ˆçˆ±ï¼Œ"æ°¸è¿œç»™$å æ‰“callï¼"ã€‚
      éå¸¸çˆ±ï¼Œ"ä¸è¦ä½ ä»¥ä¸ºï¼Œåªè¦æˆ‘ä»¥ä¸º"ã€‚

- é¸¡å…”(å¤´ï¼šæ•°ã€è¶³ï¼šæ•°)=
  åˆ—å»ä¹˜((1~å¤´)ã€(1~å¤´) )â€œé˜¶ä¹˜Xuniqâ€ å»é¦–ï¼Œè¶³æ˜¯é¦–*2+æ¬¡*4ã€‚
  å»ä»¤å…¶ï¼Œ:"$é¦– é¸¡ $æ¬¡ å…”" ã€‚

- åŒä¸»è¯­[æ–‡ æ–‡ä»¶].find="$ä½ /$å" ï¼Œ
  ä½ å»åˆ—()?å»å±•(è‡³={æˆ‘})ï¼Œå®ƒå»findã€‚ç©ºåˆ™{æˆ‘}

- æ–‡ä»¶.find(ï¼šæ–‡)="$æ­¤æ–‡/$å" ï¼Œ[fp]
  åˆ—()?å»å±•(è‡³={fp})ï¼Œå®ƒå»find(fp)ã€‚ç©ºåˆ™{fp}

å¯¹ä½•[T]ç¬¦=å‡½2[T T]-T
å¯¹ä½•[T]åˆ¤ç‰© å¼
  Op(aï¼šTã€bï¼šTã€fï¼šç¬¦)ï¼›N(ï¼šT)
  - å€¼=åˆ¤æˆ‘ï¼Œ
    N(x)ï¼Œxã€‚Op(aã€bã€f)ï¼Œf(aå»å€¼ã€bå»å€¼)ã€‚
  åŒåä¾‹
    å¯¹ä½•[æ•°]- æ•°.ã€Œ+ã€æ˜¯å°ã€Œ+ã€
    å¯¹ä½•[T]æ’- å°(ï¼šç¬¦)=å‡½2[T T Op]ï¼Œ[a b] Op(aã€bã€æ­¤ç¬¦)ã€‚

?? 'T'Expr
  Op(A:T,B:T,sym:Str)
  N(x:T)
  - eval me .:
    N: x
    Op sym .:
      "+": A.eval+B.eval

å¼ï¼Œ
  (1+2+3)å»å€¼

'T'ç¬¦=Fn2[T T T]
'T'-when å¼
  Op(a:T,b:T, f:ç¬¦); N(:T)
  fun å€¼=when this:
    N(x):x  Op(a,b,f):f(a.å€¼,b.å€¼)
  -named
    'N'fun N.`+`== å°`+`
    'T'eval fun å°(ï¼šç¬¦)=Fn2[T T Op]ï¼Œ[a b] Op(a,b,æ­¤ç¬¦)ã€‚

å¼ let:
  (1+2+3).å€¼

â€œæ²¡æœ‰å•è¡Œæ³¨é‡Šâ€
â€˜æ–‡æ¡£ **ç²—ä½“** `ç¤ºä¾‹` â€™

ä¹¦ com.example.jueju

- èµ·ç‚¹
  é‡foo=10
  å˜ï¼Œbar 10ã€‚bar=20
  é‡fooLï¼šæ•°8=10
  
  ä»¤ï¼Œ
    é‡ï¼Œ
      foo"ä½ å¥½"
      bar"ä½ -\nä»Šå¤©å¥½å—"
      baz"$foo\tè€¶"
    {foo bar baz} (è¯´)
  
  é‡raw'
    æˆ‘
    å¾ˆå¤šè¡Œ
  '
  å˜æ–‡?ï¼Œnul "abc"ã€‚
  é‡anyï¼šå€¼ Obj
  è¯´(nul?çš„é•¿)ï¼›nul=ç©º
  è¯´(nul?çš„é•¿ ç©ºåˆ™-1)
  
  è¯´(hello())ï¼›è¯´(hello(å="Jake"))
  :narg(1ã€2)
  é‡f=ã€Œå®ƒ%2æ˜¯0ã€
  (6~7)å»åºä¸¤åŠ(f)
  é‡notZ=ã€Œå®ƒæ˜¯0ã€çš„å
  (0~4)ï¼Œ[x]
    :"${notZ(x)} ${fçš„å}"
    
  :(æŸ(1)+3 åˆ° æŸ(2)(4) )
  
  æŸç‚¹(1ã€2ã€4)ï¼Œ
    :æˆ‘
    æˆ‘(y=100) ï¼Œ[p1]
      :p1
      é‡p1æ˜¯ æŸç‚¹(aã€bã€c)
      :"$a $b $c"
    {æˆ‘}ï¼Œ[æ˜¯æŸç‚¹(aã€bã€c)]
      :"$a $b $c"
  
  {:"a"1 "b"2}ï¼Œ[æ˜¯kåˆ°v]
    :"$k -> $v"
  {:"a"8 "b"7}ï¼Œæˆ‘["a"]å¿…8ï¼›"a"å­˜äºK å¿…çœŸï¼›"z"å­˜äºK å¿…å‡ã€‚
  'c'å­˜äº"hello"
 
  æ”¹æŸç‚¹(7ã€4ã€9)ï¼Œ
    x=ã€Œå®ƒ-2ã€
    y=ã€Œå®ƒ+2ã€
    zå·¦ç§»
    æˆ‘å¿… æ”¹æŸç‚¹(5ã€6ã€8)
    
  "abc"å»æ‹† ï¼Œ
    :"é•¿åº¦ é¦– æˆ‘[1] å°¾"
    æ”¹(æˆ‘)ï¼Œ
      æ·»"d"
      :"é•¿åº¦ å°¾"
  
  :"Hello, world!"å»é™¤('l')
  é‡ï¼Œ
    å° åˆ—(0)ï¼Œå®ƒ+1ã€‚[0~10]
    fib åˆ—ï¼Œ
      å˜æ•°ï¼Œa 0ï¼›b 1ã€‚
      é‡å¤è‹¥çœŸï¼Œ
        é‡c=a+bï¼›a=bï¼›b=cï¼›æ·»c
        
    z (1~9)ä»¤å…¶ï¼Œæˆ‘*3ã€‚å»æ»¤ï¼Œæˆ‘<20ã€‚(å ç®—ï¼Œåˆ†ç»„(fã€è¡Œ)ã€‚)å»è¡¨ï¼ŒKå»è·¯ â€œifâ€("even"ã€"odd")åˆ°Vã€‚
  
  å˜ï¼Œi 0ã€‚
  é‡å¤å†è‹¥i<10ï¼Œ:iï¼›iç§»å³ã€‚
  åˆ¤ï¼Œ
    i<7
    "ä½ å¥½"é¦–ä¸º"ä½ "
    å¦åˆ™
  åˆ¤iï¼Œ
    0ã€21
    1~20
  
æ­¤åˆ»ï¼Œ
  - hello(å="æ˜") "ä½ å¥½ï¼Œ$åï¼"
  - narg(nï¼šç»„å‚[æ•°]) nçš„é•¿
  å¯¹ä½•[T]é‡ å‡½1[T çœŸå‡].å ã€Œé æˆ‘å»å—è°ƒç”¨(å®ƒ)ã€

  ç‰© æŸ(xï¼šæ•°)
    -ã€Œ+ã€(ï¼šæ•°) x+æ­¤æ•°
    - å—è°ƒç”¨(ï¼šæ•°) x*æ­¤æ•°
    
  å‚¨ç‰© æŸç‚¹(ï¼šç»„å‚å["xyz" æ•°])
  
  å‚¨ç‰© æ”¹æŸç‚¹(å˜xï¼šæ•°ã€ï¼šç»„å‚å["yz" æ•°])
  
  - cast(xï¼šå€¼) åˆ¤xï¼Œ
    çœŸå‡ï¼Œxã€‚æ•°ï¼Œx>0ã€‚
    æ–‡ï¼Œxä¸ä¸ºç©ºã€‚å¦åˆ™ï¼Œå‡ã€‚
    
  - æ–‡.é™¤(ï¼šå­—)=æ»¤ï¼Œ[c]cä¸æ˜¯æ­¤å­—ã€‚å»æ–‡
  
  ä¾‹ç‰© Enum
    Aï¼›Bï¼›C
  ä¾‹ç‰© Enum(å€¼ï¼šæ•°)
    A(2)ï¼›B(3)ï¼›C(3)
    - è¯´=:"$å€¼ $å·"
  ä¾‹ Obj
    - æ–‡="${ç±»å‹[Obj]çš„å}"
    
  å‚¨ç‰© è®¡æ•°(å˜ac=0)
    - ç§»å³=ï¼Œacç§»å³ã€‚
    -ã€Œ+ã€(nï¼šå¯ä¸º[æ•° è®¡æ•°])=ï¼Œac+nå»è·¯(ã€Œå®ƒã€ã€ã€Œå®ƒçš„acã€)ã€‚
    - æœ‰(å®ƒï¼šè®¡æ•°)=acæ˜¯å®ƒdac
    - å—å†™(iï¼šé’ˆã€xï¼šæ•°)
      ac=i+x
  -ã€Œ-ã€(å®ƒï¼šè®¡æ•°)=å®ƒï¼Œac=-acã€‚

å¯¹ä½•[R]ç±» Exp
  - Op(ï¼šä¿©[Exp]ï¼‰Rï¼›- N(ï¼šæ•°ï¼‰R

â€œææ—©åˆ°ç¼–è¯‘æœŸDSL,â€
å¯å®šç‰© ExpAï¼šExp[æ•°]
  !- Opæ˜¯å‡½1ï¼Œ[æ˜¯aåˆ°b] a+bã€‚
  !- N(ï¼šæ•°)=æ­¤æ•°

å¯å®šç‰© ExpBï¼šExp[æ–‡]
  !- Opæ˜¯å‡½1ï¼Œ[æ˜¯aåˆ°b] "$a+$b"ã€‚
  !- N(ï¼šæ•°)="$æ­¤æ•°"

â€œåŒå‘æ‰©å±•, æ„é€ ä¾§Visitor èƒ½éšä¾¿æ·»å­ç±»/è¿”å›å€¼â€
å¯¹ä½•[R]ç±» ExpN1ï¼šExp
  - N1(ï¼šæ•°)

å¯å®šç‰© ExpAN1ï¼šExpA ExpN1
  !- Opæ˜¯å‡½1ï¼Œ[æ˜¯aåˆ°b] a+bã€‚
  !- N(ï¼šæ•°)=æ­¤æ•°
  !- N1(ï¼šæ•°)=-æ­¤æ•°

â€œè¦å®ç°ABé—´äº’æ¢ åªéœ€æ›¿æ¢ ExpN1çš„å®ç°â€
å¯¹ä½•[R] ExpN1.æ±‚= Op(N(1), N1(2))

â€œä¹Ÿå¯ä»¥è®© R=Eval, ä½†ä¾æ—§æ˜¯æŠŠæ„é€ å¼å½“æ•°æ®â€
å¯¹ä½•[] Eval=å‡½0[æ•°]


type'AB'(set A) Foo
  - apply(:A)B
  -'AR' map(:Fn1) [A R Foo]
  -'BR' chain(:[B R Foo]) [A R Foo]



ACC_PUBLIC (0x0001)
ACC_PRIVATE (0x0002)
ACC_PROTECTED (0x0004)
ACC_STATIC (0x0008)
ACC_FINAL (0x0010)
  ACC_SYNCHRONIZED (0x0020)
  ACC_BRIDGE (0x0040)
  ACC_VARARGS (0x0080)
  ACC_NATIVE (0x0100)
  ACC_ABSTRACT (0x0400)
  ACC_STRICT (0x0800)
  ACC_SYNTHETIC (0x1000)
-
  ACC_VOLATILE (0x0040)
  ACC_TRANSIENT (0x0080)
  ACC_SYNTHETIC (0x1000)
  ACC_ENUM (0x4000)

ACC_PUBLIC (0x0001)
ACC_FINAL (0x0010)
ACC_SUPER (0x0020)
ACC_INTERFACE (0x0200)
ACC_ABSTRACT (0x0400)
ACC_SYNTHETIC (0x1000)
ACC_ANNOTATION (0x2000)
ACC_ENUM (0x4000)

[P(7, 9, 10, 11,
8, 3, 4, 5, 6,
12, 1, 15, 16, 18), 
Class, FieldRef, MethodRef, InterfaceMethodRef,
String, Integer, Float, Long, Double,
NameAndType, Utf8, MethodHandle, MethodType, InvokeDynamic]

ClassFile: [u4 magic, u2 minor_version, u2 major_version, u2 constant_pool_count, cp_info constant_pool[constant_pool_count-1], u2 access_flags, u2 this_class, u2 super_class, u2 interfaces_count, u2 interfaces[interfaces_count], u2 fields_count, field_info fields[fields_count], u2 methods_count, method_info methods[methods_count], u2 attributes_count, attribute_info attributes[attributes_count]]

field_info: [u2, u2 iName, u2 iDesc, ['*',u2, attribute_info]]
method_info: 
attribute_info: [u2 attribute_name_index, u4 attribute_length, info[attribute_length]]

Builder åŒ¿åå•ä¾‹ æ¨¡æ¿æ–¹æ³•|typeé…ç½®è¯å…¸,nameé…ç½®è¯å™¨ æ‰©å±•å‡½æ•°
é€‚é…å™¨ è£…é¥°/ä»£ç† æŠ½è±¡ç±»æ¡¥æ¥|åŠ æ„å™¨ è¡¥å……å™¨
å…±äº«å…ƒ Context Factory(æŠ½è±¡)|åŠ æ„å™¨ type..OSåè®®å·¥å‚
å•ä¾‹ ç­–ç•¥,å¤–è§‚,Controller è´£ä»»é“¾,å‘½ä»¤,ç»„åˆ|è¢«å‡½æ•°ã€æ¨¡å—å’Œäº‹ä»¶å¼ç¼–ç¨‹å–ä»£: å¦‚é™æ€^name, F.a1:[x]
Iter è§‚å¯Ÿè€…|è¢«Rxå’Œyieldå–ä»£: Saw(0)=., Inc(0):+1
çŠ¶æ€æ¨¡å¼ Visitoræ¨¡å¼|.:è¡¨,AStor
copyåŸå‹,å¤‡å¿˜å½•|çº¯å‡½æ•°


factor
|1|1 #å•å‚çœç•¥,
|N|N>0, [factor N-1]*N

def db/use (xx)
def User(id Str age Int)
a(User)| (0 18) ()
$getU == User(id å…³é”®å­—å‚æ•°), id=$0, MaxAt0(id)
CRUD(User, id)

User
|Int Str
|age id
|18 0
-- age
User  id=0

Add
|[[] y] y
|[[x0 x] y] [x0 [Add x y]]

friends
,gigity peter

friend
,[friends A B] [friends B A]

mother _ M
,[child M _]  [female M]

å•æ‹
,[loves A B]  [\loves B A]

å•æ‹ A
|loves(A R), !loves(R A)

friends
|john julia
|john jack

-- julia
friends,sam molly

[friend john V]

v
|color 0
|wolf 1
-- color
v|red green blue
cv X| [db X 0]

colorify A B C D E
|cv(A), cv(B), cv(C), cv(D), cv(E),
! A=B, ! A=C, ! A=D, ! A=E,
! B=C, ! C=D, ! D=E


v
|woman 0
|man 1
|loc 2
|weapon 3
-- man
v|george john robert
-- woman
v|barbara christine yolanda
-- loc
v|bath dining kitchen livin pantry study
-- weapon
v|bag firearm gas knife poison rope

Pantry=Gas, Pantry=X, Gas=X,

a(man Kitchen), 
!Kitchen in [Rope Knife Bag Firearm]

a(woman Bath), a(woman Study),
barbara=Bath, yolanda=Study

a(woman Rope), Rope=Study,

man(Livingroom), \+Livingroom=robert,
\+Knife=Dining,
\+yolanda=Pantry, \+yolanda=Study,
Firearm=george,


\+barbara=Bag, \+george=Bag, 
\+Bag=Bathroom, \+Bag=Dining,


one X| a(man X)|a(women X)

uniq_pplace A B C D E F
|one(A), one(B), one(C), 
 one(D), one(E), one(F),  
!A=B, !A=C, !A=D, !A=E, !A=F, 
!B=C, !B=D, !B=E, !B=F, 
!C=D, !C=E, !C=F, 
!D=E, !D=F, 
!E=F

murder X
|uniq_pplace[
  [Bath Dining Kitchen Livin Pantry Study]
  [bag firearm gas knife poison rope]
]


| åå­— | ç›¸å…³è¯­è¨€ | æ³¨é‡Š |
| --- | --- | --- |
| Alan Perlis | ALGOL å’Œ APL | è¯­è¨€è®¾è®¡çš„è´¡çŒ®è€… |
| Gerald Sussman | Scheme | ç¼–ç¨‹è¯­è¨€çš„è”åˆè®¾è®¡å¸ˆï¼ˆä¸ Guy Steele ä¸€èµ·ï¼‰ï¼Œæ˜¯ SICP ç¬¬ä¸€ç‰ˆå’Œç¬¬äºŒç‰ˆçš„ Lisp æ–¹è¨€ |
| Daniel Friedman | Scheme | æ°å‡ºè´¡çŒ®è€…ï¼Œä¹Ÿæ˜¯è®¸å¤šç¼–ç¨‹æ•™ç§‘ä¹¦çš„ä½œè€… |
| Matthias Felleisen | Racket | Friedman çš„å­¦ç”Ÿï¼Œä¹Ÿæ˜¯ä¸€ä¸ªåä¸º Racket çš„è®¡åˆ’ç‰ˆæœ¬çš„å…±åŒè®¾è®¡è€…ï¼Œè¯¥ç‰ˆæœ¬æ—¨åœ¨ç”¨äºå®ç°ç¼–ç¨‹è¯­è¨€ |
| Alan Kay | Smalltalk å’Œ Squeak | è”åˆè®¾è®¡å¸ˆ |
| Mitchel Resnick | Scratch | å„¿ç«¥ç¼–ç¨‹è¯­è¨€çš„è”åˆè®¾è®¡å¸ˆ |
| Robert Bruce Findler,Matthew Flatt,Shriram Krishnamurthi | Racket | Felleisen çš„å­¦ç”Ÿã€Racket çš„å…±åŒå¼€å‘è€…ï¼Œå¹¶ä¸ä»–åˆç€äº†ã€Šå¦‚ä½•è®¾è®¡ç¨‹åºï¼šç¼–ç¨‹å’Œè®¡ç®—ç®€ä»‹ (HtDP) 7ã€‹  ï¼Œè¯¥ä¹¦æ—¨åœ¨è§£å†³ä»–ä»¬åœ¨æ•™æˆ SICP æ—¶å‘ç°çš„è®¸å¤šé—®é¢˜æ–‡æœ¬ |
| Casey Reas, Ben Fry | Processing | æ¶æ„å¸ˆ |
| Lauren McCarthy | P5.js | è®¾è®¡å¸ˆ |
| Seymour Papert | Logo | Sussman çš„è®ºæ–‡å¯¼å¸ˆå’Œå…±åŒè®¾è®¡è€…ï¼Œä¸ Wally Feurzeig å’Œ Cynthia Solomon ä¸€èµ·è®¾è®¡äº† Logoï¼ˆä¸€ç§å„¿ç«¥è¯­è¨€ï¼‰ï¼ŒAbelson ä¹Ÿå¯¹æ­¤åšå‡ºäº†è´¡çŒ® |
| John Kemeny,Thomas Kurtz | BASIC | å‘æ˜äºº

- ä¹ä¹
  td ["{b}{a}={a*b}" (a==b)("\n","")] .:
    (1~9)(a)
    (1~a)(b)
    //1~9:[a] 1~a:[b] ""
  say: '{td.Str(" ")}'



func Flock(nâ€œseagullsâ€:Cnt)
  - conjoin(:Flock) this|:
    n=: +it.n
  - breed(:Flock) this|:
    n=: *it.n

- main
  a Flock(4); b Flock(2); c Flock(0)
  a.conjoin(c).breed(b) .conjoin(a.breed(b)).n
  â€œ(4+0)*2 + 4*2â€

  A 4; B 2; C 0
  conjoin(breed(conjoin(A,C), B), breed(A,B)):
    this==B*(A+A) â€œby [rules]â€
^now
  - conjoin'ab' a+b
  - breed'ab' a*b

- rules'xyz'
  x+y==y+x
  (x+y)+z==x+(y+z)
  x+0==x
  x*(y+z)==(x*y+x*z)

at:
  hi Fn1:[name]'Hi {name}'
  _greeting Fn1:hi(it)
  greeting hi

-'T' [Seq T?] compact if{it!=NO}

- pureSlices
  xs [1 2 3 4 5]
  1~3:
    xs[0~2]
  1~3:
    xs.pop(0~~3)

  at _checkAge Fn1:[age] age!<min
  at checkAge Fn1:[age]
    at min 21
    age!<min
^now
  at min 21


- add'x' Fn1[Int]:[y] x+y


- id'ab'(b=0) as:
  now(a+1,b-1) : b==0
  a

- id(a:Int,b=0)
  now b!=0: a=a+1; b=b-1
  return a

id(a,b)=b if a==0 else id(a-1,b+1)
a\=0 {b}: id(a-1,b+1)

?? Nat
  Zero; Inc(:Nat)

- Nat `+`(b:Nat) b .:
  Zero: you
  Inc(B): Inc(you)+B

-'T'(T PosNeg) `-`(:T) it.not
?? 'u'PosNeg
  - not u
  - abs u

?? 'u'Num
  - `*`(:u)u
  - `+`sep`*`
  - `~`sep`+`
  - `<`sep`+`

?? Any
  - `==`sep`<` (:Any?)YN
- 'T'Var `=`sep`or`
  
?? YN
  - `,`sep`<` //é»˜è®¤
  - `or`sepR`,`  (:YN)


- http_error'stat' stat .:
  400: "Bad"
  404: say:'..'; "Not found"
  401 403: "Not allow"
  or: "Net wrong"

-'T' Ln cons(:Ln) ln .:
  []: me; [x {xs}]: (me add [x]).cons(xs)

point .:
  0|0:"Origin"
  0|y:"Y{y}"
  x|0:"X{x}"
  x|y:"{x},{y}" 

?? RGB
  R;G;B

[RGB.R]: me.{
  R"Red" or"Good"
}
?? Tree
  Sum(:[Tree Pairs])
  N(:N); Zero
- `+`(e:Tree)N e .:
  Zero: 0; N(n).: n!=0:n
  Sum(es): es(Sum(0): A+(+B))

"$ abc" .:
  (RE:'$ {s.[Str too]}'): s
  (RE:'$ {i.[Int too]}'): i

[1~35]*2 .:
  x!=0 .:
    x+y==35,4*x+2*y==94: say:'é¸¡{x}å…”{y}'

[users posts] .:
  u.id<10, u==po.owner: "LEFT JOIN, not us[po.id]"

[x y] .:
  x+y==35
  4*x+2*y==94
  (1~35)(x,y)

[I] .:
  s[i]==me[I+i]
  s==me[I~~I+s.n]
  (0~~n-s.n)(I)

- Str sub(:Str) std.[IdxM1 as]:
  (0~n-s.n):[I]
    s.iEach:[i]
      s[i]\=me[I+i]: return^2
    return I
  return -1

    


at now: i 0
at addr (1~10):
  i= :+ 1
  x= :max y
  at use  Fn.[Int Str Int a2]:[x] x+i
- use(x:Int,:Str)


- main /??/
func App(home="", fs=(FS.ROOT /[etc mtab])) CLI('home ??')
  - main(:[Str Ln]) ln.n>0: say:'{ln[0]} {home}'
  - exist CPU.exit(fs zero{1}:0)
  - test(:FS) CPU.exit(Try{fs .r; 0} or 1)
  - os
    (CoFS:'false') .r:
      say: '{me.exited("failed","done")}'
  - sed(:FS)
    ""(fs): it(RE:'#.*', "")

- main
  a 1; b 2
  say: '{a}+{b}={a+b}'
  [[1] [2] [3]] .:
    a+b==c: say:'good ALU'

  [a.eachI]*2 .:
    i0\<i, s[i0+i]==s[i], i==n: say:'{i}'

  ints:[x] x .:
   x>3: 
   x==NO: 
  [ints] .:
    x!=NO: 
    x>3: 
- bmiTell(x:N) x:me .:
  >18.5: "underweight range"
  >25.0: "normal range"
  >30.0: "overweight range"
  or: "obese range"

- max'ab' a .:
  a>b: a ; or: b
- cmp'ab' a .:
  a<b: -1 ; a==b: 0 ; a>b: 1

- fact'nr'(r=1) as:
  now(n-1, n*n) : n==0
  r

- fib'nab'(b=1) as:
  now(n-1, b,a+b) : n==0
  b

- fib'n' n.{
  0 0 1 1 or fib(n-1)+fib(n-2)
}
- fib2'nab'(a=0,b=1) as:
  now(n-1,b,a+b) : n==0
  a

sum_of_bigger_than_2([{1~5}])
- sum_of_bigger_than_2(A:[Int Len]) as:
  now: i 0; sum 0
  now( i \< A.n):
    A[i]\>2 {sum =:+ A[i]}; i=i+1
  sum

- init
  double Fn.[Int A1]: *2
  small-than Fn.[Int a1]: Fn.[Int Bool a1]:[B] B<A 

  ls (1~5).Ln (double)(small-than(9))
  sum ls(Sum(0):A+B)
  len ls.Len
  dd=ls
  dd=sum; dd=len

?? 'T'Any
  Li(x:T, xs:Li?)

-'T' concat(:[Li? me], u:Li) me .:
  NO: u ; Li(x,rs): Li(x, rs.concat(u))

-'TR' map(:[Li? me], :Fn.a1) me .:
  NO: NO
  Li(x,rs): Li(fn(x), Fn.a2.map(rs,fn))

- levenshtein(ab:[Str Pairs])Int (ab:n):[n|m]
  at s (ab:Len(n+1, 0)).Len
  //for(j in 1..m) { s[0][j]=j }
  (1~m):[j] s[0][j]=j
  (1~n):[i] S(i,0)=i; (1~m):[j]
    S(i,j) = (ab.A[i-1]==ab.B[j-1]).{$N 1+pose $Y S(i-1,j-1)}
  s[1][j]
^name
  - S'ij' s[i.rem/2][j]
  - pose [S(i-1,j-1) S(i,j-1) S(i-1,j)](Sum: min(A,B))

- min'ab'(_:Int) (a\<b)(a,b)

at:
  a T(0) ; b T(2)
dd=(a+b).x
type Any
  T(x:Int)
    - `+`(other:T) T: -x x+other.x

at now T.A: a ; b B
say:
  'Hello a: {a} & b: {b} -- wow~'
  at: ğŸ¤£ "string" add " to" add " append"
  '{ğŸ¤£}'

type T
  A ; B
  - Str me.{A"A" B"B"}

ary [1 3 6 8 20]
res ary.bsearch(20)
say: '{res}'

-'S' [S Ln] bsearch(:S) as:
  n==0 {-1}: find(0,iLast)
  return -1
names
  - find'AB' as:
    mid A+(B-A)/2
    S.sortFn(me[mid],u) .:
       0: return mid
       1: now(A,B-1)
      -1: now(A+1,B)

type User
  id seat.[Int too]
type User
  EmailUser(id:Int, email:[our Str]="")
  ^name
    - as(x0:Var, x1:Var) as:
      id==x0, email==x1

funcs Person(name:Str)
  children Inc.[Person Ln]
  - setSuper say:''
^name
  - as(name,parent:Person) as(name) : parent.children add me

now Student("",{}):
  stu ("San" {"è¯­æ–‡"98})
?? Data
  Student(name:Str, testScore:[Str Int KV])

data'T' Inc.Set LogCollection()
  - add(:T) add(u) : say:'{u}'

- Person countryName std.[val as]: company?.address?.country \: "UNK"
(0~10 sep-1).Str:"{me},"
msg Message(): -recever "" -title ""
msg.send: d=me

d Dog("Zeus").doTricks
c Cat("Rusty").doTricks
- Pet doTricks as: walk();speak()add comeToMaster()

func Pet(name:Str)
  - walk say:
    'walking, {speak()}'
^??
  - speak "Yo"
  - comeToMaster

data Pet Dog()
  - speak "Woof"
  - comeToMaster "Hi"

data Pet Cat
  - speak "Meow"
  - comeToMaster "Nope"

name MyPet Pet
  now [our]: nLegs 4
  now: actuallyLikesPeople $N
^type
  furColor Str
