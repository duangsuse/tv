
单项到列表
  表键不重
  区间、有序、复选 按号 首中MayAt0 有序:[] 按,~+,~~ 隔N,dxy
  num{>0}与首尾 滤首([])
  俩:两侧两有序,两面两路通 数计1~8、向量N2<N> 闭添计列 [|a b]:[K|V]
  单多项滤 not(,)or: chk.isOk{} 可空?{}: 可路{}{} SQL: str(has,in,换)
可空值 at now when return 加data-made(糖,集句),可再做,@参-函=封抽 判-物-
  at=atKV,Send,FnKV 常量.wasAt解构
  参组和kw参 尾伪参 泛型参组:真子类型
  '?'是装饰器 跳/你^0^ to:[x ^] to:loop(=):条件 Try{}.Way enum与类型域 IdxM1
  做到调用链 简记gsat|: 文件rwx {真假}?回,或回
  重复无若 if,else,loop是函宏 才不是var_fn to:跳出^0^
  量纲是T的单位 公式验证'' 具名'NThis于括号 QuickCheck
  单多行注释 裂注释/??/ 提问对话FixEEM,折叠 倒计时 ?内嵌码配
  重复或递归 二分 时分秒 FFT
  值.内存 函/句 特征码,词判数判 [gsl]et,getVar容器 wasQuote("$",TYPE,外语,Fn)wasVar生成-Arg捕获
列与集
  改和复制 滤{}:滤有
  正则、文.AZ
  叠加组 Sum(v0|_,add) 按步按{长} Sum(let可造,add) item0{it}:ok by拆分至
  有按隔 皆一仅 按KV 按.隔N,隔N:2 “LRC分段” 阶乘Xuniq
函与我
  Any接口的例T:TYPE  T,T0,TDef
  JVM数值重载 列事->行优化 据参换码eval/waitFun =Type断|Str模板
  函续靠函许 待命建立域 异步=惰性待做 流过滤
物类面向对象 PC=Mac? @可见定 @set形变
    可为 点矩 可继承
  pkgs.
  造于、在=读写 File.sh/socks
  同名例的元类 Send typedArg和cond Conf 跨平台 标于词
  恒事-受 内[码变参] 参树
  私下性检查 可见性>上, 此物>可定性!>上

Send<Pair> 查找并组装元类, 最终调用As{T(Made,to=condTypeTag),_T(Made,byWrite),n=(-1), $Int4,. }实现 JSON(as流).cat(to=new)

Send<Any> 支持弱类型接口: "",1L,enumBool,[]{}

A|B
:--|:--
做滤叠按首|观行键队列
: {} Sum by Sort|Saw Ln KV Pipe Seq
数N文字无俩|围复试必同参

读 写  做 到 在 物 例 类 判 ^例   我 造于 书 回 的 去 、 你 它 上我 此刻 可定 未定 终定 公开 私下 族内 组内 SymCmt
📤 📥 👉 👍 @ ✨ ❤️ 🚩 🤔 ^❤️  😶 🤌 📖 ✅ . . ,   🧲 🤌 🙄   👀  🙋  👶  🧑‍🎓    🔓  🔒   🔐  🔏 Eng

行  围 复选 KV 俩  两面 两路 两同 改同 可变 谈 吐 两侧 两序  闭 晚 可继承  观 列  队  集 格 改 问 说 抛回
👀 🤏 ☑️  👁 🆎👈 🌓 😊 🔀  😋  💾  📥 📤  👣  🤔📈  🚪😴 👍📤   📭 📬 📪 📫 🧮 🙏 🗣 💬 🗯
做 滤  序  带 叠 长  添 泡  有 存于 不重 Math 正则 log
👉 🔍 📈 🖖 🤓 🍡 📥 📤 🔜 🔚  🦶  🤓   ∞文 📝💬

待 两路 否 或 重复 停下 停次 函续 函许 线程 待做 待命 试做 接应 皆应 错 错败 测试
🥺 😊 🤔 😒 🔁  ⏹  ⏭   ⏸  ⚙️  CPU 📝🙏 📝  🤔❌ 🧐  😠   ❌ 😰 🎯

数 计 文 $YN  针 且 必  函 参组 组  值 受 断止 类型 TYPE
🔢 🔟 文 ❓ 👆 & 👍😠 🙏 🍡 👀N 📩 🔮 🚫 📩🤔 ❤️
⏪⏩⏮⏭🎲 🔗.$ 🤌 📂,SIG 📦.👀 📅⏰.文 📖🎼🌿 📊⛓☕️🏁  🖼🌠📷 🎧🎤🎬📹🎮



用wOSK设计静态页
  wOp可编辑 “按键精灵” 冒泡的“软键盘” 拖拽和acty “尺子”(ev0.xy) 手势热键和滚轮IME
  wOp优化 awaitF5 CSS.rateLim(tap,0~3,rule2).v wKbd vscroll files,Blob,Obj onNet  of,'once only stop!first'
  wSty.内嵌CSS和FT特效 {$class:$YN} fg:Nd.hsl(+) bg:渐变  hiDPI grid
  wKV和全屏,菜单 if,show xy:PLen,abs! “焦点拖影” 边框!和resize offset于父元素slot:Eq.if N2.ptr(P{tap}?)和inscr use.ptr
树关系“括起问” body(doc?,var=>),html bodys取代qsAll lets(a{sortNO},fe,e0清空) when(css,ce)选&验证 edit:NO
  模板“选说问” ask sel say ee.use 富btn-menu is.lang
  it和.parent #frag父级或自身  html``-Intl
  双变Eq.at,双向it.var lets(num(+1)) v(x=>)和v([]) sep(csv) it('asRow')
  efx原理 Dtable触发sort-let深赋值 ondiff=移/删出,挤入 id:或全刷新
函数化组件({},my)=> my和局部 ask,it,it.super.(ev) Eq.at(0s.rate回调) “音游” 带配数组 “定时拆弹” onvar直到手删
  $css可多项_mix wSty(".主题文件")  _变量ease, $tbody[`tr,th`][`*`] :has悬停动效
  div__idSSR支持 wSty(it,元素组件) is.ssr发变量收HTML wOp{ask:id,}
  宏 lets,when(class{}),T.it Dform(v)双边验证
区间类型.. chk plen _4way
  rn:has,cut,clamp,cycle,pick,by
  分组Sum byTo(/,0,%)
  say.d 调试 d=$Y dxdd dm=[x,/fn/] dt=(A,time)=>
  e.pos,Rn选区 is(v树监听,'>tag'|''?,{kv,v0}) hov act foc eHide bold(cmd)

界面 ee.TOADHIRE
  Tab(ul[n],{rn:e.label, i:0,corner,url,kbd}, let) _easer动画:_n 取整
  HI(class baseURL{ 'user/$'([name],{url}, r) }); res.card()||ee(res); CRUD
  Reload F5异步流 wait,stop []求和拼接和reSum
  App 通知和Share inscr.bgPlay
  efx 擦拭 erase:{4向飞出} a.easeList(i延时)并_efx 翻斗ease “视差拖拽”
  Paint Worklet_imgVar Shader向量
    ee.svgg滤镜图DSL N参{}R出 “抖音Logo” “圆角云玻璃”
    Intl 1,Mar,01,March ${d,}h24,${[,,,0,2,2]}
传输 is.STPM
  is.use`npm ./xx`   
  ST(env.url) 使用上次数据(载入会话); Sep:'_',transfer,undo:/key/,-1; Blob,Form,Hash
  PM(port) 调用其他进程; Rn.clip可触发[i,msg] 变量复制 播放控制-缓存rn
  通知,GPS “闹钟” “摇一摇”
  T.it(rWx读写函) 点号代理 ee._of到T 
  恶行易施-eval,waitFun  生成(js,[o,f]|js) OUTPUT[fp]
  标题树deep,nest 深先(a,late) copy=(dfs,ord?)(P0) conf all(POJO) 走迷宫
计算 it.QNd
  Q支持==,in,undef函数 Nd支持['*']重载
  滤 首尾指针
  env,doc,is.wdoc 和typeof,nNd(ary) Ary.letsPose{rot90}
  CSS.paint 与GL滤镜 精灵图
  物理类型 abijnm cokv dxywh ef gpl is,sz
  关系式EQL x+y=3与排列abc fn$|条件 函且或-'=R'

to({k:v1}).as(_=>k)  Eq.at({a,b},_=>) N2.ptr|1s.rate(it.evVar)
it={k:{key,v,onvar=then, call(x=>+1),
   as(x=>Fork) ([pipe]) },
   ondiff(movd,add)=onvar,  a/p/sorts=['k'],to(a=>a1ByIDKey),it}
it={keys:'k', call([v1=>,], once?)}

it={__lazy(), _rWx_key:Eq(x=>), __(k,set?), fn:bind}
when(class OrCond{ T(){checks} }) T.it={ cap(_){with proto} }

Eq={num(+), open bold(cmd)} use.NS svgg
bodys((ab,vars)=> $app(is(`p,:hov act foc`,sig, {kv,v0?}), sig(x=>qsAll)) ).live

wOSKita rn chk PLen-menu 4向fxAB在as绑定 rule2 Sum
btn(Op,[]) sel Dform({alert}) say.dbg
efx($YN,str,easeAB) +-ball(yes) i=_n 剩onvar[0] t:0~1/erase灰布/GL双布

ee.$qs,wSty(it,{$mix:$YN,$$li})(by ".主题css")= Nd HI,ST
slot 
Reload(F5=>)

pos={e/copy, L,R,n:NO, css:NO ,eHide,e0}

那些仅仅是用词的东西，改了多少次呢？

语义|管道it|配置it|管道|配置Builder|体系
:-:|:--|:--|:--|:--|:--
Kotlin|let|also|run|apply|Scope funs
EQ(新)|1.as(x=>|user.to({age:1})|as(_=>)|to(_=>)|做/到函数
绝句(旧)|lets:[x]|let:[x]|lets同apply -多项map|let -forEach|把被字句
老绝句|itLets|itLet|lets -seen|let -see|令为函数

（seen 这类是从中文翻译的， `[1 2]去看， (它==1)去路(真、假) ` 直译如此

（`obj.it.to()` 还被用于数据绑定，as 则用于深拷贝等递归转化 ，总之asto就是太有用了！为let默哀1s





照片馆的Linux控：截图冰箱、用OBS+SRS广播屏幕

1. 用 Icebox/A-new.scrcat ，选择窗口，会在同目录下生成“相框” (右键点选,把鼠标移开或按Ctrl,可录制GIF)
2. 打开 应用.scrcat，再次 A-new 便会截图到“照片目录”
3. 触碰照片 "应用/8-17 12:00.scrcat"，就会让进程回到截图的时间点

- 全屏窗口选择页，有滤镜 theme: 毛玻璃(blur) 黄金体验(sepia) ， 按 Ctrl-= 还可缩放屏幕/OCR
- env.yml 添加 setsid: $taskmgr 后在任务管理器按“停止”可备份单命令，docker: '' 启用文件隔离
- Doze.scrcat pid 会将任务休眠到相框的“照片0”。在之前缓存0秒
- 在 tty1 (cage kitty 后支持中文)，$ scrcat 将 X11变可点击字符画

asciicast 和 

IP网络：用nc和proxychains实现剪贴板共享和全局代理(深挖原理)




刚开始，我们有个功能
say(1+1, end="\n")

^汇编(带数值类型,参数宏)

创建变量
-- pressF2(x)
  say(x, end="\n")
明确类型
- sayNum(x:Int)
  say(x, end="\n")

再用类型里的词汇去改进，乃至重新组合
- sayNum(x:Int)
  (x!=0):
    say(x)
    at opts=[1 2 3]
    opts:
      (this==x): say("small")

- as(ln:You<Ln<Int>>, :Fun1<Int>)
  at now: i 0; N ln.n
  N!=0:
    fn(ln[i]); loop(i!=N, i=i+1)

type 'T'Ln
  at n: Cnt
  - get(:Idx)T

^结构化(带list,GC,方法封装)

但是，如何复用at变量？先复用函数吧

- sayNum(x:Int)
  say(x)
  [1 2 3]{this==x}: say("small")
^now
  - 'T'Ln as(:Test, :Fn0)
    this:[x] test(x): fn()

然后把私下的^now 简化并公开！
data- SayNum(at, x:Int) Filters
  say(x)
  [1 2 3].only: say("small")
^now
  - 'T'Ln only(do:Fn0)
    this:[it] (it==x): do()

增加一点细节，为调用侧。
type 'T'Filters
  - Ln only(do:Fn0)@ourpkg impl??

- main=SayNumFilters(0)|: “！读作 to:”
  this()
  x=3; this()

^面向对象(仅接口多态)

又或者，你的需求太简单，懒得去继承框架呢？
- main
  “demo, list filters”
  ask(at now Int: num)
  at onlyIf=Test{it==num} “覆写”
  num:[x] TODO"sayNum"

酷酷地可变量、伪递归
-- Var<Int>`++`=this|: v=v+1
-- `++`(:Var<Int>)=as: v=v+1; v

- noop'ab'(:Int,b=0)=as:
  loop(a!=0, a-1,b+1)
  b

^函数式(非纯)

类型可以随意扩展
- SayNum odds(max=100)
  (0~max by 2):[x]
    this.x=x; this()

物类的类型，是一个单例'T'(T Type)。单例自己就是类型，就像 `pkg 命名空间`
data 'AB'Pair(A:A,B:B)
^named T
  at mjs=Pair("Michael","Jackson")

--'AB' A`|`(:B)=Pair(A,B)
at Pair.T.jsm="Jasmine"|"Flower"

T提供了值域，而 T.Def==(name,[T0],{}) 反射其定义域。如果继承自Send，就能让序列化/注入器看到 T.cols,T.conds
- main=Pair: ([mjs jsm]):[A|B]
  say("name:${A} family:${B}")

^面向对象

有数据的单例，要保存Enum,Is 等接口，就像Data
when- as
  Pair(A:A,B:B)
when- Color
  R;G;B
  Bad
    - Str=error("")

也可以模式匹配
when- 'AB'Way3
  A(:A); B(:B); NO

接口随便扩充
- Int8|Int4=this.Int
data- Str|Sorts
^now
  at sort=Fn1: it[0]

-'N'(N Num) Half=N.Rn: (A+B)/2.
type 'this'Num
^named T() .Const
  type 'this'Const
    at Rn:Rn<this>

^定义式编程(ADT)

