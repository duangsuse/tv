# 绝句-形式语法

>一个语境语序优先、编译期计算、跨语言/文化/范式 的隐类型名动词OOP

写法和API定于遗忘和单纯化。脚本/老教、函数和Rust式、工程或学院派；编程范式，不是绝句对标或“抄越”的叙事

编程不是学描述步骤。编程是重建万物的视角，是让解法类聚、相联的 __创意环境。__

没有摆脱语言的思考。热点术语绝非软件所蕴，技术实质是“变中守恒”的领域模型

编程如同日记。代码即是文档、文档如同示例，直观化其读改的 __数据模型__

代码即文档、文档亦示例，标准lib是为理解与拆分思路而存在的工具，而非技巧

认同绝句的价值观，也仍能拥抱复杂算法和冷门领域；绝句对编译器的模块化会让“冗长含糊”的错误门槛消失。语言lib是为理解解法而存在的工具，而非技巧

暂请放下智力和特立独行，忘记知识的堆砌，用简练的美感审视思想吧；穷其变、知不穷。

## 特点

文件由3层级组成：值、言句、词

假设AST构造于递归下降组合函 parse(右吃字符流)，跳白注释/高亮靠过滤流记录。流也传入缩进深度与配对括号(:语句列表/算符链何处结束)，简化报错

span记录是一种浮标链表。如 `书 :增量(段) ; 段 "[\w ]+"+ '\n'` 得到csv式[[]] 结构后，在1行内修改只导致1个[]重解析

记法(+-*/名记平权, !isEmpty 自动生成) keyword都靠Trie分词，记法为名时如 `1+a令为，{到2 到3}。` (ju_en无需此步骤)

言 `1+2*3` 以逆波兰算符重排 求值中缀。`a [0] ()` 等后缀叫言小，前缀的3种优先级为 `(:f)("调试")、(!a为男)是假、交a()+2`

## Val值

JSON单值、可嵌套 `‘’ “”` 注释。`[] {}` 以 `造行<字>('c')、造表(1到"")` 定义

```js
_值 JSON|"内插"|'跨行内插'|0xCA_FE|0b11|真$Y|假$N|空NO

名 :tok(:止于记法(utfLd+)|『.+』)
词名 名|:tok(「记法」"[大中小]右?")|记法
点名 :tok((utfLd|'.')+)
NL "[\n\r]"
// ! /\p{Nd}/u.test(名[0]). utfL类=L{lutmo}, 转义 \nrtfb'"$\
ws ("[ \t\f]+"|注释|文档)+
注释 :略(注释,'“”', "[“”]")
文档 :略(文档,'‘’', "[‘’]")

//~可能是配对的” 或新嵌套注释
:略 :tok(:包围($1, ($0| ~$2*)* ))
//三种构词：软可为名、常(事,量,.)不可为名、苛(+,!,等记法) 切分名字
```

`"$a ${1+1}"` 也可换 `'$a' = 受内插「仨项({""}、{a}、"")」 “..+""+a+末项”`

数字文真假空， 数值类型(数浮计 1 2 4 8)有宽化隐转、`对何<数 我>`-上我super 则像C++有自动填充，数字 `100L+1f+10u` 靠记法 `量 数.「L」：数8` 

`组<数1> 组JVM<数8> = byte[] Long[]` 可互换(泛型该用恒事:对 `JVM&组<“非”读T>` 传参不能靠自动装箱)。Kt是函数化了JVM `T[]` 的创建，必要拿到reified T

## Expr言

```js
言小 :链条(_值|指代|条件,

  |的 名 |去 名  |引函 | [传参]|后缀
  |(<类型+>)调用?|调用 |…参 )

指代 你|我([^数])? |名 |'('言')'|引函
引函 「(名|记法| 言)」
条件 若(言)…(否则…)? | 判
//ju_en 里引函换如 {k v}`get`, fun Int.{+}(:Str), frac{good}{TeX}
判 '判'(你? 言 记法?)? :块(否则… | 言(、细分匹配 |…))
细分匹配 (言 、)… | 判

调用 '('传参(名=值 、) ')'
类型 名(<((读|写)? 类型)+>)? | '*'|_值

传参 (值 、)
…参 :块(句 ；, ([名+|是 言+])? )
… :块(句 ；)
:块 '，'$1 :新缩进($0, '。')

言 :算符小先(言小, '* / % 空则 $小; + -; < > ~ 存于 $中; 是; 且; 或; = $大', '非 - +')
```

块参数 `f，。 或 o去f()，。` 是靠函数值或OOP，`kv「取」 是 map::get`

按类型或[存于]等test()函数 `判1，数、判""存于， 。` 对 `例物：位旗` 可用 `shOpts令，若有..` 执行

略Omit、略余Omits(x)、可变 用于匹配解构，[判]内值位置支持未知量和 `函试<T> (及T,同 函0T=T)`，如 `判{"K" 空}，造行("K"、a或1)`

事(无我)是函 `(「它+1」令(说))去串(说)(0)` 。闭包捕获外部量，捕为引用如 `x=x`

1|2
:--|:--
令滤序带叠|行表集组列
let only sort zip fold|Ln KV Set Ary Seq

(其)令/(其)令为是forEach/map ，`列.令` 叫做『看』。`函新<R>` 被用于重载 `函1<R R>`

`f：函我0<数 文> = 函{0+1}<数 文>` 、`1去f = f(1)` 。有 `“物A”事B.f=双主语<“你”A B>.f`

```js
{1 2}去叠算「+」必 {1 2}去叠(0)，首+次 “末=i”。
"ba b"去拆 去叠算「+」的逆值必"bba"
{假 真}去叠算「且」的逐步是{假 假}

(1~20)去序(先大 “例物无需全名”)
去叠算(「它/10」、叠算去行+叠算(0、「右」)) “group+count”

‘存皆 存一 存(1)； 可看/可添(长 为空 略=末针 满针) 乘,阶乘Xuniq’
“列”展(1、{2 3}、4)
展(123、「它%10 到它/10」、止=0)去凑(""、"^"到"$"、2到空) 必"^32…$"

事 双主语<文 文件>.find="$你/$名" 令，
  你去列()?去展(至={我})，它去find。空则{我}

({"a"1 "b"2}带2)去表，[是{k v}]k到v。
带切

(1~10)去序二分「>5」去真假
(1~6)去首「它>5」的i

组(3)「i」 组去空<数>(1)；空白“适于只读数据”
“行是可添的组。也有 类 有序、有复制、有闭、封送化”
```

## Stmt句

```rb
句 言
  |量 (名值|名 是 言) | (变|量) :块(名 值)
  |回([^数])? 值? |抛回 值

  |尝试… :或有((接迎 类型…)+, 必保…)
  |变(类型)名(初 值)?
  |重复((再?)若… |调用) | (停下|停次) ([^数])?

值 言
名值 名(：类型)?(=值)?
:或有 $1|$0 $1?
```

`量俩是a到b` 和 `事是`、 `量，k v。` 友好

言位置皆可为 `断止`。`值? (事 文、摘要码、「是」)` 可为所有算式，而储物copy: `人("王羲之"、"小王"、50)(名="羲羲")`

`a“可变<T>”=b` 是言，但类型是“生效”-如同若判内有句/不穷举时。也是有 `i移右 u的age=「它*2」`

`重复(区间=a~b)`，在 `事=“回[^]位置”判` 支持尾递归：跳到开头再来次

同Kt `回[^0]` 不同于 `回`，`恒事` 的参函会添加跳转层(cross inlined)，回是break破最外层；其中可用 `组内` API

`事 T?.「?」(：函续<T>)：T`，只有非空时继续算，并赋值。`待<R>.「!」=await`

协程是闭包的延伸：栈调用->“堆调用”。事对 `函续` 传入自身断点状态(回调)便返回，yield(x) 就可视为返回给next() -此时事尚冻在“yield返回值=?”，仍可循环。

因此能调协程的事，自己也必须有函续参数，`待完，。` 是传个卡线程回调。因 `o?.f()?.v` 和可暂停化都需要外提语句，`T?.「?」` 的函续是言(调用链)范围的，其返回值是可空量


1|2
:--|:--
值言句词|同名例 恒&标物 停次
Any E Stmt Fun/Val/Type|-insta eval breakit

注解按 `量：标<文 JVM('volatile')>；事 f(n=0、：JVM('native'))` 是为鼓励研发DSL&编译期宏，并废止kt的 `@file:JvmName()` 注解过度设计

恒事/量： `恒量n=x；(1到n)其令，[是a到b]a+b必是3。` 等于 `1+x必是3` 。恒事/量读写 参数被常量折叠，没有 `component1()` ..

解构时，`行<可变<T>> 表<K 可变<V>>` 模式被逐位遍历，生成测试或(非空)赋值，`a作<组<可变>>带号 “恒事”令` 里T:可变 让let里get 等调用自动转换，如 `kv的值令「值=0」或 a带b令(交换)`

`文本变量，说(你好 世界)。` 用到 `事 受未知量` 和 `事 文.「_」(：文)`。即能连写 `若，。若，。`

```js
a令，
  “回[^2] 是到这里”
  a令，停下[^1] “==回[^3]”。
  “回[^1] 只是到这里”

不断，
  不断，
    若真，“在此处:” 回[^2]。

_2:while($Y)
while($Y) if($Y)continue _2
```

## Word词

1|2
:--|:--
事量物例类|公私族组内
fun val thing insta class|same{,0,type,pkg}
储标例判造|既可未终定
data eval enum when made|!,impl{?,??,!}


```js
事 :有('事', 形参?(：类型)? , :为(句 ；) |是 言)
  (其中，:新缩进(词+) )?
形参 '('(名值 、)')'
物 '物' 名 主造 :为(物词)?

词 型参? 修饰 (
事|:有(量|变,：类型, 读写)
  |:有(物事,主造, :为(脚本) )
  |物|例 名 继承 :为(词)
  |类 名 :为(物词) |量纲
) |
型参? 可见? 的? (
  (储|标)物|:例判(例,调用?) //默认继承自 例项Enum
  |:例判(判,形参)//可含impl??
)

物词 词|同名例 名? 继承 :为(词) | 造于 形参=言 //made=made()
:例判 $0 物 名 主造 :为((名 $1)+| 物词)

主造 (形参?|修饰 造于 形参) 继承
继承 (：类型 调用 (、(类型 、))? )?
读写 :或有(读 …,写 …) //[它]， =可新/可晚/可懒「」 即 by lazy{}
量纲 (名=类型 …?)
型参 对何<名*> ('('约束')')?
约束 (名+：读|写|类型 、)

:为 为 :新缩进($0, ~.) // 可扩充,可=
:有 恒? $0 (类型 '.')? 词名 $1? (=言 | $2)?
修饰 可见? 可定? 的?
可见 公开|私下|族内|组内
可定 '!' | "[可未终]定"
```

[变]不同于 `物 A(变i：数)`？ 绝句里，句级语法是过程式“流水帐”，只因自举才支持

如有，`(1<2)去路「1」「0」；1取否「它<2」空则(0)；0~3其令，“for”。文件去试`

主构造器的参数=属性，只用于赋值。造于是事的简写特例，末尾调 `受初()`，其他super要 `作<上我>去xx`

物事 的签名/构造值继承自同名参数-如同 `类型<>`，默认继承“我”(而非值)；没有主语时 `物事 主：活动->物 主活动..`

造于也=`事 T.同名“Named”.受调用`，物事内语句集至 `事 受初用` ，`T::class=T作<类型>`

类同名例的继承受继承。

```rb
起点 ('#!' ~NL*) 书首 脚本* | 书首 词*
# 可以 use1 某例; use1 java lang util; 后 use1 util regex Date:Week

引 点名
引单 点名 (名(:名)?)*
书首 (书 点名)? (引|引单)*
脚本 词|(句 ；)
```

vararg 写为 `事 造行(：组参<T>)` 和 `：组参名<"abc" “皆”数>` ，切分规则类似 `对何<KV>`

kwarg 有 `组参名(「dict」、{:"k" v}、a作<组参>、k1={;set})` ，当然 `{:;}` 应只在脚本-它由 `例 “文本变量.”『:』` 常量折叠!

`fun(a)=(fun(b)="")` 则被 `事 f(a、b、：参颗粒化<1 1>)、物：可继承(by v)` 取代

.nb.md 是juedit绝谛的笔记本模式，以此支持数据图表/可视化、输入框

源码上，词级有 SourceMap，dot语言形式

文/数/枚举-界面/真假-动异，橙绿蓝红

## More

- Kt 域步/数 `1~10. 步+1；1~2步降；行[0~<略 “略-1”]`
  - `要求/现在，'弘扬'；1必2；假必真。`、`TODO"懒" +略("折叠")，。`
  - `as?是作否<T>、量「!!」；值的内存，a是“===”b。+1是+(1)=1`
- 中文低歧义 `首尾 始末 左右 名号 添泡 抓裁 凑拆 待得` 。使用 子类型/隐转、同名多义 等多态写法缩减术语量
  - C `储物 A()；听(A()、fmt=生成)() ；听去数；听("名字")去Enter`、`1的位(-1“shr”)+1且0b11`
  - GLSL `俩量(r=90deg、l=1)：分量同算<数>` 是数。Mat上也有乘法
  - `可同Eqv<数 文>` 如 `(抓cat=parse,裁cut=toStr) oncat("42"){it+1}; flip.cat(0)` 和 `可为Either<值 错>`
- Bash `(文件/"a.txt")“名左=a” 读：Blob<文>(MIME,泡;隐转文,字节-裸组AryP<数1>) /写(新开头=0,添)`
  - `夹(冲突=「它?令(假)」)；文件的std[0~2]/HOME/sh`
  - DOM `到"text/*"：文件族<文>` 自动加.txt 。`转到"*" 字节`
  - `(文件/"init"到"text/juscript")去“恒?”做(主语)的报错`

```js
“链式计算-IO”
Eqv.lets {pipe(txt("nums.json"), JSON<Ln<Int>>) }
   .oncat("add1_"):it.lets{it inc}

“组合式 数据-impl 用于跨平台”
类 CmdExec； 物事 安卓.作：CmdExec
事 启动=os去sh('平台特定')
可重入，“被N个线程调用后,1次跑1个”。

引 绝句.言“词”
恒事 “Eqv”pipe(:Args<Eqv<* *>>)：类型递归<args>

私下恒事 类型递归(串：组<类型>) = 串[0]的参[0] 令为，[A]
  类型.参(可同、A、串去叠(A)，[a b] b的参[0]可为a；b的参[1]。)
恒事 管(串：组<类型>) = 串去叠，
  次的参 令为，[是{A B}] 首的参[1]存于A；B。
令为「类型.参(函1、串[0]的参[0]、它)」

‘强类型绑定’
物事 某：UI 为
  变*，A；B。 “赋值时类型”
  !量布局=竖，
    横，钮()为A；钮()为B 。
  A被点，说("你好")。B被长按，说("世界")。
```

不采用 AST.walk&check=>IR.Nodes 模式。juec很像py解释器执行的kt编译器，其实现Core.ju的数集API，编译器则靠把API翻译

`若 尝试` 语法实被函数化，其 `作=repr:算式<R>` 输出，[恒]内不可常量的调用才原样换语言

Kt,Java 等代码等价为JSON状嵌套式，恒事参/恒量(可常量值)被化简并内联；物/事类型声明有 `恒事 可受` 检查

恒事参/量读写 `恒量n=x；(1到n)其令，[是a到b] a+b必是3。` 等于 `1+x必是3`


`物 类型Type<T>“叫 T.同名”` 与 `T可为1；值可为数4` 等实现了类型隐转推导。`可受(同名事[0]、组<类型>)：错?` 会为 `for<TR> fun ap(:Fn1<T R>, :T):R`

参数T检查2次，像解 `unify(b=a&a=1).b`。判物『数』`数4.+ 数1` 和 `数1.+ 数4` 基于 `事 数1.作=toInt` 会宽化
