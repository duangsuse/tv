# 绝句-形式语言

>隐类型强检查的名动词OOP(DtOOP+3Eqv, kt+yaml+py+go)：跨语言/范式、跨语种、编译期计算新语言

语境语序至上，帮助产品经理拆分规划软件的民谚：

编程无关步骤。编程是重建事物的视角，是让数据相遇、互调的 __创意环境。__

思考不离语言。术语化技巧非软件刚需，终究只通识“变中守恒”的领域功能

脚本/老教、纯函数 Rust式、工程派学院派；排版级的范式，不是绝句对标或“抄越”的叙事

<img alt=Urbird src="Oriole.png" align=right width=150 style="filter:grayscale(1) invert(1)">

「分解问题，胜过分销问题」 Problems to seal, not to sale

「通识」的敌人并非智慧，亦非人，而是挟技以奇,孤芳自怜的封建博弈

## 文法

3层级：值、言句、词，编词为书。实现建议：

AST如 = scan(`[{左,右},/吃[a-z]+/, {流,or:串}]`) (右吃char流)

parser递归下降+过滤流，以提供span高亮(#rw=''时跳空格)、缩进级/配对'('的传参，简化报错。'|'内每“行”._=每词右ws

span锚点链表能增量解析 `""` 等位置修改-如csv[[]] 内1单行 ，`函/事.受尖调` 编辑时类型检查

`1+2*3` 以逆波兰算符重排求值。`a [0] ()` 等后缀则叫言小，记法(+-*/,自动有 `!isEmpty`)

和keyword以Trie分词，名记平权如 `1+a令其，{到2 到3}。` (ju_en无需分词)

- 高亮编辑器有“语序厨房”，显示时匹配行正则+容许高亮词条对应编辑 如 `俩项(A：A、B：B)储。'AB'物`
- 高亮绘制以json diff 复用行贴图
- 文数、储调、判 性质物&语法的颜色是 橙绿、蓝 红 ，在 ju_dot 节点化笔记本(算式名->变量图)里也一样。事量物为同心圆/方/棱形
- 解析&寻址 层面遇'⸮' 则报错其可选补齐

## Val值

```js
_值 JSON|"内插"|'跨行内插\u{}'|0xCA_FE|0#rgb|0b11| 真$Y|假$N|空NO
//可嵌套“”注释。`[] {}` 靠 `造行ofLn<字>('c')、造表(1到"")` 
//  `组(3)「i」 组去空<数>(1)； 改，造行(66)。` 用于添加式的情况
//转义 \nrtfb'"$\。 '' 或结尾于空行+', '\ '开头的单行rawstr不视为Regex

名 #(:止于记法(utfLd+)|『.+』)
词名 (# 「记法」"([大中小]右?)?")|记名 //use! ju {!==}:NO //值的地址，a!=b。
//高亮：软可为名、常(事,量,.)不可为名、苛(+,!,记法名) 切分名字。 Syntax.ju 定义了是否苛构词(量,val,.)
点名 # "[utfLd.]+?utfLd"
记名 名|记法
//"$a ${1+1}"； '$a' = 受内插({""}、{a}、"") = ""+a+末项;  受数字(:文,类型)
NL "[\n\r]"
ws "[ \t\f]+"|注A|注B|文档 //a b间,多
注A :略(注A,'“”', "[“”]")
注B ‘’ ~NL*
句B ((‘句’)|(‘点名 ~’ ’)) ~NL*
:@ ('@'$0 (‘词句’)*)|$1|$0 //弃用<替换>‘DFS-order传参’, 必<>, 恒 类型.令 里亦可初始 受未知
文档 注A (注B|句B)+ // /,py 1+1 ,/ was2  恒 受内码wasQuotee(词,算式,文) 受继承

//~处可能是配对的” 或新嵌套注释
:略 # :包围($1, ($0| ~$2*)* )
```

『数字文真假空』 数字类型(数浮计 1 2 4 8)有C++式自动填充 `'浮 我'`(值T.同名：类型T)，`100L+1f+10u` 靠记法 `量 数「L」：数8`

## Expr言

1|2
:--|:--
令滤序按叠|行表观队列
let only Sort byZip Sum|Ln KV Saw Pipe Seq

`T 去令`/令其 即单项版forEach/map ，`a令行，才是集合自身。` 也有 ?调试, a否takeIf，5次“亦作(T)->列”。只有令,(单字)滤 叠 有主语

可写的行，如 `物 组() 行<T> 集`，`改行() 可添 组`，`列 按号，[是x按i]。 a? +b, b?按a`。行作(注册 隐式构造=)列=iterator, 又如 `物例(进制)可同<数 文>,n.Str(10)`

JVM
- int非Object，Int箱才可交给 `List<T>, T[]` 里。故装箱 `组<数“int”>作 JVM组<读数>`
- T[] 的反射不存在擦除，但泛型接口里容不下T=int。故优化 `组“+改行”<T>清零 @JVM<"重载"写 参组<数4 字 真假..>>`, 亦如 `行“+组读+文”皆(0)`
- 序列化/buf文件化 `Rw.Eqv` 视类型参造。其字典器 `'T'(T“.单例==”可送)事` T?可无同包实例而取 `可送.typed[T]`
  - 如 `Ln<N>:可送`.T[0]=N可送 由调尖创建; 此为 static typeof树
  - 其他静态类型很难「绑定值位置和名字」：无法简洁地遍历数据积木

```js
言小 :链求(特前(_值|指代|条件), 后缀 //事 T“Any?” 「?」(Fun1、“回”：函续<R?>) 或，停下 //+ 试，抛回。?或!或必"不空"
  |的 名 |去 名  |[(值 、)] //- 读(:K)V
  |:或有(<子集+>, 调用)) //- 令 尾随(名=值 、),及逗句(OOP函数值)和待，。所需的函续+含许(try和调度所需)。

指代 简集|你|我([^数])? |名|'('值')'|它函 //函我1<>默认首参[我],函N[它]。可省略 `{0}，[x “按的”i]` ,HasYou<我 多捕获外层Ctx>
它函 「(记名|句)」 //ju_en: {Fn1,推导it}, `#nam e`, `+`

//`[1 2] 基于 `文本变量(例.『=和,』)，量[=a 1 b 2] 是[,a b]。 `
// [1 2]去改/重
简集 '['言']'
//  例上 `恒- 受未知getVars=IntRef..`/ `值._(:值)` 展开-又如 `若，。 若，。` 3宽+2高 A2~B3 ，且：可高亮
//  为方便bash和UI 调用， T.受逗调(事,参组<UI“/观”>) 会捕获块内(UI值,不递归)

条件 判| 若(值)…(或…)? //判- 复选旗ChkBox； sh选项，若有..

//判{"K" 空 4}，造行("K"按k、a或1、「它>3」)
//判1，数、判""属于，{"甲"}.. 。函问<-数:集值 `例 文本解构` 转化
//  变量<> 获取顺序：`恒检查读写的事/er, getVar(k), 生成Var-继承kOf(o,key),Seq,fnCell`
判 '判'(你? 值 记名?)? :逗((言|或) (、或且细判 |…))
或且细判 (言 、)… | 判
//行<可变>.受解构(:行<值>)，a[i]==函问/受未知/_ Args({})

言 :算符小先(前缀* 言小, '* / % $小; _; + -; < > ~ 令其 有 属于 到 按 $中; 是; &; 或; = $大',
  '非 - +', '我',…参|'')//i={+1}
//前缀的3种优先级为 `(??f)("帮调试")、(!a为男)是假、添(a+2)，。`

调用 :或有(:顿号(值), :或有(它函+ ,…参) )
//例.受尖调 创建 `类型.参` 例，子类兼容(值有数,数有1)看 数.同名：集<值>
//如 造表<数字 文?>(1到""、0.到空)。再看 {it+1}.ap(0)   'TR'- Fn1<“写”T R>.ap(:T)R

子集 '*'|我|上我|尖调'?'? |_值 //冲突fun=as<某上我>.同名事 ，物(v) 可继承ByAPtr(v) 
尖调 :链求(点名, <(访? 子集)+>)
类型 :@(尖调+,子集)
访 读|写
//同名事.受尖调(:组<类型>)错?，`某事<>` 或:T 只初值TypeVar(当前交集=*, 形变=读“不固”)，组<T> 行<读T “推导后启用”>
// 集值可为集数，改集则报错。读T实会禁用 首(T)
//写T: 函1<数> 可为 函1<值> ，故要禁用返回T=数 的事量，而对<读T?> T仅写空

…参:逗(句, ([名+|是 言+ '^'?])? )?
…  :逗(句)
:逗 '，'$1 :新缩进($0, '。'?)
:或有 $1|$0 $1?
:顿号 '(' ($1 、)、* ')'
```

```js
类 列 { if「右posR」 「移右goesR」.. } “围Rn<数>(左、右)按“行islice”, 表(K、V) 行左：队 添”
‘有皆 有一 有(1) 仅令letIf/滤不(空) 乘(2次:组合),阶乘Xuniq； 改.集(长 为空 略=末i 满i)’

必{1}，{1 2 1}，滤首(1)； 滤尾(1、转换={})。
(1~6)，首「它>5」的i；尾(3)；我[1~3 按1]；我[_-0]; 我[_*.5]； 我?[2]。

({"a"1 "b"2}带2 “步=2 补=「空」 叠=行”)去KV“_K”，[是{k v}]k到v。[uid]去改否(无?)
{1 2}带"甲乙" “补=空/错 交=俩项”  “可变去换”
lrc,kv去隔，带右去滤“间隙过长的i” 去除白。

- 含你<文 文件>  find=改{"$你/$名"}，
  你去列?去平「它去 “文件”find」 或 我
- `-`(:N)=0-n //优先级>this
类 有序 有闭 两侧两面,. 可抛、可新(复制)、“0参=”可送
+ - & !& 并补交 对(1的位)有效

必，
  {1 2} (叠「+」 “Sum{+}”)是
  {1 2}去叠(0)，首+次。
  "ba b"去分() (叠「+」的逆步)是"bba"
  {假 真}  (叠「&」的逐步)是{假 假}
  试<错>，报错()。 真!
("ba b"去分)(叠「+」按「长」)
“分组计数”
(1~20) (先大)(叠，行+界和rnsum+初(0、「右」)。按「它/10」 “/真假”)
nums(有序按，{先小「它/10」 先大「它」 平齐()}。)

(1~10)去序两路「它>5」
{1 2 3}去叠，首*10+次。
必"^3…$"，列(「它%10 按它/10」、止=0)「序逆」(123)
  去文(""、"^"到"$"、1到"…")
```

## Stmt句

```js
局部 :或有(名,：类型) 言? //=值 |既有量 是 言
值 言
句((言
  |量 :逗(名 值)
  |回([^数])? 值? |抛回 值 //`回` 跳到^标的 - 事或lambda ，以此为界。恒事间随便 `回[^N]值`(&函续,a令<可变>) 但 事(var_fn) 才可作fn,getVar 为参数
  |!?量 局部  |(变 类型? :逗(名 值?))+ //变“赋值定类型*”，钮；框。

  |试做… :或有((去接应 点名…)+, 去皆应…)
  |重复(调用| &?若 值…) //伪递归:改参跳开头重来, 重复&若假  会用在内联回^0里
  |(停下|停次) ([^数])?
  |句B //弱语法: 恒事 重复 (若真，。)等流控链 `作值=算式.`
) ；)
```

juec自言及句地把kt级语法低级至java，如同py解释器执行的kt编译器；它以 `可同<判事语法树 源码>` 的分段求值(如树模板)实现数集CoreAPI

恒事参/物量/`[言]` 被折叠，储物(可repr,或宏,如AST流控内联)参组被化简如 `恒量n=x；(1到n)，[是a到b] a+b是3。` 等于 `1+x是3`。真泛型在JVM前置T::class传参，例量必须froze

恒值则可含undef等Var -禁止项,如 `int a[10]-> ? by 10` 仅检查长度

```js
// 停次=回2N默0 停下=2N+1
不断，
  不断，
    若真，“停次[^1]=” 回[^2]。
    “回[^0] 只是到这里”

_2:while($Y)
while($Y) if($Y)continue _2
//想打断最外可外包: 令，回^5
```

```js
(File.Eqv<Ln<Int>>/"nums.json" ) “链式编解-复制IO”
   .oncat(File/"add1_"):it.lets{it+1.}
Eqv: File/"a.gz":
  at s=pipe(_7z("gz"),XSON()) cat “流TypedAry,像改.列: "".文件<某送>() 改.可同”
  _7z("bz")cut s

-data Eq(:Arg<"ab"Int> =0) Solve
  问("ab=", {a b})
  must 3:a+b
ask<Eq>.wasInit

- 文 凯撒(k=1)是 字的编号 去谈吐下「它+k」 “可同<字 数>:谈cat 吐cut”

恒- “Eqv”pipe(:Args<Eqv<* *>>)管<args>
“类型体操版compose()。 函数体无法构造 管<> 类型(来形式证明)，故仅调用处受检 ”
恒- 管(串：组<类型>) = 串[0]的参[0] 令其，[A]
  串去叠(A)，[a b] b的参[0]有a；b的参[1]。令其，[B] 类型.参(可同、A、B)。

- Q_rsqrt(:N) N
  at:
    i 0x5f3759df - n.bits(1)
    y i.bits.N
  return y* (1.5 - (n*0.5 *y*y)) //2nd iter

“其实，恒事能靠组储.. 内的[真子类型]做TS/C++的检查，不必靠手写 管<args>”

//   - f(a、b)@参颗粒化<1 1>
'TA'(A 行) 函新<T> 作=函1<A *>，[a] a令其「你(它)」。
```

## Def词

1|2
:--|:--
事量物例类|公私族组内
\- var data named type|our{api,,type,pkg}
储判务同造|既可未终定
as when- data- -named made|^,impl{?,??,}

1|2
:--|:--
值言句词|恒 试 停次
Any E Stmt Fun/Val/Type|! Try breakit

`物- 有序行 作` 扩充成员，`物- 点 矩形； 安卓 作 有Bash` 扩充子类，也用于减嵌套 `^量页=UI..`/匿名例创建

- `- 行3'abcd'(:数、d：参组<T>)`, `Args(dict by{="kv" 1}、k1=2)`
- `os：平台“安卓”` 会检查它被“作”过的接口。量纲对原物像“待验证”标记
- 字面报错 `'' 几=行，我 不为空 按"$长.."。`，`- 行 作=断言；我行.必<几> :必<读T>`
  - 一般 `函新=函1<R R>`， “新类型”''T=数，假
  - a去作<量纲> IAE；‘a+b是1’ ISE(默认替换a=1, 或 按"") ; 必2，1 assert

```js
事 :添('-', 形参? 类型?, :为(句)|是 值|=言) //量 类型.空 非值, .断止 无值
  (其中 格局 :逗(词) )? //事量算在头部；事物强制内联；例只在物 (隐式=私下); 事是f: f参加在前面,函我首参:含你
形参 :顿号(局部) | 聚名:顿号(局部) //事物 A(变i, 右都可变,量x右,)。句级语法是过程式“流水帐”，只因自举才支持
型参 聚名:顿号(访 名?|名 类型+|同名例 名)? //事'' 有参:* 则隐式恒。默认名同类型,匹配_ 只按前缀
聚名 "'[\w ]*'"

事量 型参? (
事|:物('物-',词句, 主语) //隐式：继承自“我”，无我是 `物- 主“页” 页`, 非私下即公开物。内句(含变*，)被收集到 `受初调`
  |:添(量,：类型, =言)
  |:添(变,：类型, 言 :或有(读 …, 可见? 写 …?)?) //by lazy{}=可晚，。/可晚/观「新按旧」/=NO 会(扩充var强制)内联
)
词 初量|格局 (事量| 型参?(:物(物)
  //v 不可定.  when- as/*() Data(可选StrTag,eqvLn so 终定) */ =只外移内部 dataclass
  |:物('判-',(名(形参|调用?) :为(词))*)//造未定,多余型参'*' ,在同文件加子类
  |例|(类 名:@(尖调*) :为(事量|同名 例) )|名=类型 …?
  //全调用=例物=新类型：值例Enum(v=0或++, 自动name=) 不引即用。以此优化[真假空]
  //否则为enum Type:byTags。单例如Add("+")加在allVal; 全无即是类
  |造于 形参=言 //作<上我>去made嘛 值隐式自同名参，如同 `类型<参>` 和 ^事的签名&默认式(含私量)
))
初量 造于 可见? :逗(名 值)

继承 :@(尖调 调用? 尖调* )? // 造于=事(参数=^变/量 的集中性依据)，末尾调 `受初,deinit()`
例 '例' 名? 继承? :为(词)
:物 $0 ($2 名
  :前有(造于? 可见? 形参, 继承)  //(造于:) 即私下. += 公开终定量 _覆盖
  :为(词|$1|可见?同名 例) )
:添 !? $0  主语 $1? $2? //成员
主语 :尾有(尖调,'.'? 词名)? //T.内T. fn 链尾是名
```

`类：集<值?> { (同名)例词=>我.TYPE.“比文件例严格” ; 词 {名{全称} 新量 新事[名={参类型返,标,.}] 旧物}  } }`，dynamic(*)靠[受未知] 生成事量, `(类=行)<数>：类型`
- `.T=我.T`, `盒<A>的俩<B>, 'AB'物- 俩` 隐式传递 你=我[^1]
- 空白作<行<数>> 寻找了 `同名例 行 可造 可送.同名“<我=行数>”` 内 ^量 。同名<我>限恒事调
- 注解只能按 `量：@文 JVM<'volatile'>；- f(n=0)@JVM<'native' 'v'写2>` 和 `物 JVM(doc：文、v=1)标于词`

```rb
起点 ('#!' ~NL*) 引文 词句 | # ink{.ju,.lock.ju} 默认特殊配置 pkgs.test
  (书 点名 :@(尖调+,''))? 引文 词*
词句 (词|句)*
# 可以 use! 某例; use! java.lang util; 后 use! util.regex Date:Week ;use ''.Wtf 为包名/内物
引文  (引 点名|引单 点名 (名(:名)?)* )* #跨平台ju. lists,nums Rn,Sort,text,cont

格局 可见? 可定? 的?
可见 公开|私下|族内|组内
可定 ^|"[可未终]定" #明确写出终定=^
:为 :新缩进($0) #P.Lay换行{后, 视词右空格(s.ws)决定'}'或继续: ws 仅忽略行首更深或有'的 去 或'新行
```

```js
(0~5)令其，[N]
  量t=Nsec；待命，t的延时；说("$t后")。
  可重入，“被N个线程调用后,1次跑1个”。

- 起点=“卡调栈 全局 +”待做Waits，
  待“(函续启=无懒单调)”，“Promise.自动调then (即函续Cont,它+含许)”。
  含许ContinueCtx() (名=s,当抛=,)“的域”去待做，launch=待命Job「续管CoPipe 添1」。

  观，5s的延时；添1。的首
  列穷SLine({1 1})「它[0]+它[1]」  “列靠添,被回调,不会栈溢”

俩量(角90deg、力1f)
必.12，俩量(.123)去锯齿(0“round”、2)的x “N2,Vec2是数”
N量=Nd 词判Trie 数判({0 .1 .3 1}、V) 队环RingBuf 频域FFT
```

## 附录

[Lua5.3](https://www.lua.org/manual/5.3/manual.html) 是词法域小语言的典范

```js
句(;|调用| (var,)=(言,) |
  if 言 then 句 (elseif 言 then 句)*(else 句)? end | 
  break  | (while 言)? do | repeat 句 until 言 | 
  goto 名| ('::'名'::') |

  for  名=言,言(,言)? do | 
  for (名,) in (言,) do  | 
  local((名,) (= (言,) )?|
    fun 名 域)
    fun 名(.名)*(:名)? 域
)* 返?
域 '('(名,) ','? '...'?')' 句 end
do 'do' 句 end
返 return (言,);?

val :链('('言')' |名) //左递归本质
var :val([言]|.名,名)
调用:val( (':'名)? ('('(言,)')' |文|KV) )
KV {:隔("[,;]", 名=言 | [言]=言 | 言)?}

:隔 $1 ($0 $1)* $0?
fun "function"

言 :算符小先(JSON|nil|... |KV|val|fun 域,
 '^^; * / // %; + -; ^..; << >>;&;~;|; == < > <= >= ~=; and; or', '# - ~ not')
```

### 合法性

绝句的封装必须为解决kt/py里的「高门槛or低复用」而存在

ju|kt|py
:--|:--|:--
[1 2]|listOf|JSON子集+tuple,set
obj:, 1.lets:+1|apply,run|无this
lets(to=Rw.ofLn)|mapTo(mutListOf)|[*iter]
缩进,{}{}:|{},=|:或pass (仅流控)
Try!?|first/OrNull|调用外NPE:AttrErr
i移右,list右添|i++,Stack|+=iadd,`deque`
判你,去路,若或|when(val=), if-else|仅(A if q else B)
mayAs,may?{} or|as? T,takeIf?let ?:|or或match
data made(),val=get|private constructor(val),val get()=|@dataclass
判-作 储物|sealed class: data object/enum{WTF{}}|仅dicts
事物 量纲 作|value class+init+继承|几次T.fnval=\self:
量纲/‘’字面报错/必|require,check,TODO|raise;无嵌套注释
'跨行',复选|'''.trimMargin,EnumSet|C式"" \\ "NL"
val:量表,(val表达式)=1|val语句|a,b=b,a
函我2,含你|(context)A. (B) -> R|无this
letsIf{it<0}:abs|filterMap|[for x in if]
nums.KV_K:it-1|associateWith
firsts|take/DropWhile|`itertools`
事@文 弃用<替换>‘新’|@Dep_(@Rep_(""))fun|''' :tag: doc
`- (:Decorate<Fn>)`||@wrap
重复(i=i-1),重复&若|tailrec fun,do{}|仅while
回[^N]和你我,as上我|let@标签{this@TYPE}|皆无
?(函函续),or:break|编译器?:链,跳转句作算式|不能 `cfg[k]or return`
!事(var_fn)|inline fun(noinline fn)|无宏/跳转级
`File/"",''.File<判事>`|Json.fromFile/Str|dump/s
(其中，)物-|紧凑object{}+inner class|@print def
(T Send)类定同名例|T.serializer(Targ)&typeof|仅dicts
可送,其中 可定|noarg,all-open|^^
T: Any.TYPE,*,x in T|::class 反射, js `dynamic`,is T|type(x): dict原型链
Set(含数组,Str)和Seq|仅std Collection,原型数组,无Rw.Str|`typing`
val=by,A 可继承<类>(v)|val=Var, A:类 by v|hook getattr
wasX+get+set,let\`*\`|operator和::,infix|`__dunder__`
N2(x,y)|裸WebGL|`np.ndarray`
事'abc'(:数/N)是宏|不支持,也没有'N'模板或函宏|^^
Int,Cnt1~8,_N4 _N8|JVM类型,UInt,.|默认bigint
RwEqv|javaIO(链式)流|open().buf
(类事互通),物- .作|external/expect|cffi

分清动静态(编译)没意义。弱类型即动态类型，而C是强类型弱检查。参数的“成员”是反射常量，或是编译期“未定”的字典链，都不应给元编程造成区别
