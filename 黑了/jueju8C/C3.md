# 绝句-形式语言

>隐类型强检查的名动词OOP(dtOOP+PREq, kt+py+yaml+go)：跨语言/范式、跨语种、编译期计算新语言

以语境语序叙事，帮助产品经理拆分规划软件的民谚：

- 编程无关步骤。编程是重建事物的视角，是让数据相遇、互调的 __创意环境。__
- 思考不离语言。术语化技巧非软件刚需，终究只通识“变中守恒”的领域功能

脚本/老教、纯函数和Rust；工程或学院，对排版的范式，不是绝句在对标或“抄越”的技术

游戏红极一时，操控方式却往往很简单。绝句愿成为你畅游软硬平台和算法的手柄。

<img alt=Urbird src="Oriole.png" align=right width=150 style="filter:grayscale(1) invert(1)">

「分解问题，而不分销问题」 Problems to seal, not to sale

## 文法

3层级：值、言句、词，编词为书。实现建议：

AST如 = scan(`[{左,右},/吃[a-z]+/, {流,or:串}]`) (右吃char流)

parser递归下降+过滤流，以提供span高亮(#rw=''时跳空格)、缩进级/配对'('的传参，简化报错。'|'内每“行”._=每词右ws

span锚点链表能增量解析 `""` 等位置修改-如csv[[]] 内1单行 ，`函/事.受尖调` 编辑时类型检查

`1+2*3` 以逆波兰算符重排求值: `(>=当前缀 前缀* 值)+` 尾添当前。 言小含 `a [0] ()` 等后缀，记法(+-*/,自动有 `!isEmpty`)

- 行行👀 LIT(语言内建翻译ju_"zh,zhtw,moji"), 报错转GPT; Hoogle 用类型签名搜索libs, JoYo RFC
- 文数、储调、判 性质物&语法的颜色是 橙绿、蓝 红 ，在 .ju.dot/md 节点化笔记本(算式名->变量图)里也一样。事量物为同心圆/方/棱形
- 高亮编辑器有“语序厨房”，显示时匹配行正则+容许高亮词条对应编辑 如 `俩项(A：A、B：B)。'AB'物`
- 高亮绘制以json diff 复用行贴图
- 解析&寻址 层面遇E.xx 则报错其可选补齐;git diff下编译

## Val值

```js
_值 JSON|"内插"|'跨行内插\u{}'|0xCA_FE|0#rgb|0b11| 真$Y|假$N|空NO
//可嵌套“”注释。`[] {}` 靠 `改的行Ln<文.字>('c')、改的表(1到"")` 
//  `组(3)「i」 组去空<数>(1)； 改，行(66)。` 用于添加式的情况
//转义 \nrtfb'"$\。 '' 或结尾于空行+', \开头的单行rawstr不视为Regex

名 #(:止于记法(utfLd+)|『.+』)
词名 (# `记法`(by :或有(右,记法) )?)|记名 //use! ju {!==}:NO //值.地址，a!=b。
//高亮：软可为名、常(事,量,.)不可为名、苛(+,!,记法名) 切分名字。 Syntax.ju 定义了是否苛构词(量,val,.)
点名 # "[utfLd.]+?utfLd"
记名 名|记法
//"$a ${1+1}"； '$a' = 受内码wasQuote({""}、{a}、"") = ""+a+末项;  受数字(:文,类型)
NL "[\n\r]"
ws "[ \t\f]+"|注A|注B|文档 //[项 ]尾
注A ‘’ ~NL*
问A ((‘句’)|(‘点名 ~’ ’)) ~NL*
注B :略(注A,'“”', "[“”]")
文档 注B (注A|问A)+ // /,py 1+1 ,/(折叠或:) -! (文,跨语算式)/TYPE.受内码|(词,文,算式?)

//~处可能是配对的” 或新嵌套注释
:略 # :包围($1, ($0| ~$2*)* )
:@ ('@'格局 $0 (‘词句’)*)|$1|$0 //弃用<替换>‘DFS-order传参’, 必<>, -! 类型.令 里亦可初始 受未知
```

『数文字真假空』 数字类型(数N计 1 2 4 8)有C++式自动填充 `'N 我'`(值T.同名：类型.于T)，`100L+1f+10u` 靠记法 量 数`L`：数8

## Expr言

1|2
:--|:--
令滤序按叠|行表观队列
lets only Sort byZip Sum|Ln KV Saw Pipe Seq

T令/`T，(令算)` 即单项版map/forEach ，`a去令行，才是集合自身。` 也有 ?调试, a否{takeIf}{ret}。只有(单字)令滤叠 有主语

可写的行，如 `物 组() 行<T> 集`，`改行() 可添“的切片”组`，`列 按号，[x按i]。 a? +b, b?按a`。行作(注册 隐式构造=)列=iterator,

又如 `物例(进制)可同<数 文>,n.Str(10)`、改同(基于 改同于.字,.) 外包物

JVM
- int非Object，Int箱才可交给 `List<T>, T[]` 里。故装箱 `组<数“int”>作 JVM组<读数>`
- T[] 的反射不存在擦除，但泛型接口里容不下T=int。故优化 `组“+改行”<T>清零 @JVM<"重载"写 参组<数N 字 真假..>>`, 亦如 `行“+组读+文”皆(0)`
- 序列化/buf文件化 `rw.Eq` 视类型参造。其字典器 `'T'(T“.单例==”可送)事` T取 `可送.typed[T]`:可无同包实例
  - `Ln<N>:可送`.tArg[0]=N可送 创建自调尖(送.typedArg[Ln]); 此为 static调用(typeof)
  - Type(x)才是真子类型。静态类型很难「绑定值位置和名字」：无法简洁地遍历数据树

```js
言小 :链求(_值|指代|条件, 后缀 //事 T“Any?” `?`(Fun1、“回”：函续<R?>) 空或，停下 - 你<T?>.或 T
  |的 名 |去 名  |[(值 、)] //- 读(:K)V  试，抛回;可空.aa.b。?或! 或必“"不空"”
  |:或有(<尖调+>, 调用)) //- 令算 尾随(名=值 、),及逗句(OOP函数值)我 和待，。所需的函续+函许(try和调度所需)

指代 简集|名|'('值')' |你([^数])?|我|它函 //函我1<>默认尾参[我],函N<>[它]。可省略 `{0}，[x “按”i]`
它函 「(记名|句)」 //ju_en: {Fn1,推导it};  :E=Fn0自动闭包,:CT统一词树

//[1 2] 基于 `例 文本变量(覆盖「:和, ()」)，量[:a 1 b 2 ] 是[,a b]。 `
//[1 2]去重; [:dec(0 9) x('a' 'f')].let<KV<Str Pair<**>> >:[(k (x y))]
简集 '['言']'
//  例上 `-! 受未知wasVar=IntRef..`/ `值._(:值)` 展开-又如 `若，。 若，。` 3宽+2高 A2~B3 
//  为方便bash和UI 调用， T.受逗调(事,参组<UI“/观”>) 会捕获块内(UI值,不递归)含 作(:函续)@AsInStmts, 且可高亮<>

条件 判| 若(值)…(或…)? //判- 复选Chk； sh选项，若有..

//判1，数、判""，“属于”{"甲"}.. 。函问<-数=集值 `例 文本解构` 转化
//判{"K" 空 4}，改的行("K"按k、a或1、「它>3」)
//  可变<> 获取顺序：`恒检查读写的事/er, getVar(k), 生成Var-如K(o,key),fnCell,Seq`
判 '判'(你?值)? :逗( (言|或)(、第二次判 |…))
第二次判 判| (言 、)…
//行<可变>.受解构(:行<值>)，a[i]==函问/受未知/_ Args(a)

// 在求值序上,结合越紧越早,越深 。`*`by`+` 靠 bisect+KV<"" 1 1>缓存
言 :算符小先(言小, '? * / %;$小 _; + -; < > ~ 令 到 按;$中 有 属于; 是; &; 或;$大 = ;',
  '非 - +', '我', …参)//i={+1} 含keyword以Trie分词，名记平权如 `1+a令，“我”到2 到3。` (\w+无需分词,全局高于this, `f(到=x)` 有效)
//3种级(即by _,in,=)为 `(f??)("帮调试")、(!a为男)是假、添 (a+2)，逗调添。`

调用 :或有(:顿号(值), :或有(它函+ ,…参) )
//例.受尖调 创建 `类型.参` 例，子类兼容(值有数,数有1)看 数.同名：集<值>
//如 改的表<数字 文?>(1到""、0.到空)。再看 {it+1}.ap(0)   'TR'- Fn1<“写”T R>.ap(:T)R

类型 :@(子集+,尖调)
子集 点名(<(访? 尖调)+>)?
尖调 '*'|我|上我|子集'?'? |_值 //冲突fun=as<某上我>.同名事 ，物(v) 可继承ByAPtr(v)
访 读|写
//同名事.受尖调(:组<类型>)错?，`某事<>` 或:T 只初值TypeVar(成员交集=*, 形变=读“不固”)，组<T> 行<读T “推导后启用”>
// 集值有(.impls.has)集数，改集则报错。读T实会禁用 首(T)
//写T: 函1<数> 有 函1<值> ，故要禁用返回T=数 的事量，而对<读T?> T仅写空

…参:逗(句, ([名+|言+ '^'?])? )?
…  :逗(句)
:逗 '，'$1 :新缩进($0, '。'?)
:或有 $1|$0 $1?
:顿号 '(' ($1 、)、* ')'
```

```js
类 列 { if「右posR」 「移右goesR」.. } “围Rn<数>(左、右)按“行islice”, 表(K、V) 行左：队 添”
‘有皆 有一 有(1) 仅令letIf/滤不(空、到=[]) 乘(2次:组合),阶乘Xuniq

改.集(长 为空 略=末i 满i) 令(可改)，。去造= ’不可改’
改的表令，泡。 + 行去观，[旧到新]。绑为变量

必{1}，{1 2 1}，滤首(1)； 滤尾(1、转换=[])。
(1~6)，首「它>5」的i；尾(3)；我[1~3 “.隔=”按1]；我[_-0]; 我[_*.5]； 我?[2]。

({"a"1 "b"2}带2 “隔=2 补=「空」 叠=行”)去KV“_K”，[(k v)]k到v。[uid]去改否(无?)
[1 2]带"甲乙" “补=空/错 交=俩项”  “可变去换”
lrc去隔，带右去滤“间隙过长的i” 去除白。

- 你<文 文件>find=["$你/$名" ]()令算，
  你去列?去平(到=我)「它去find」 或 我
- `-`(:N)=0-n
类 有序 有闭 两侧两面,可抛,. “0参=”可送(去令算copy,重置)
+ - & !& 并补交 对(1的位)有效

必，
  [1 2](叠「+」 “Sum{+}”)是
  [1 2]去叠(0)，首+次。
  "ba b"去分() (叠「+」的逆步)是"bba"
  {假 真}  (叠「&」的逐步)是{假 假}
  试<错>，报错()。 真!
("ba b"去pad(行首、"\t"*1)去隔)(叠「+」按「长」)
“分组计数”
(1~20) (先大)(叠，行+界和rnsum+初(0、「右」)。按「它/10」 “/真假”)
nums(有序按，{先小「它/10」 先大「它」 平齐()}。)

(1~10)去序两路「它>5」
{1 2 3}去叠，首*10+次。
必"^3…$"，列(「它%10 按它/10」、止=0)「序逆」(123)
  去文(""、"^"到"$"、1到"…")
```

## Stmt句

```js
局部 :或有(名,：类型) 言? //=值 |既有量 是 言
值 言
句((言
  |量 (:逗(名 值) | 此刻 类型? :逗(名 值?))//此刻“赋值定类型*”，钮；框。
  |回([^数])? 值? |抛回 值 //`回` 跳到^标的 - 事或lambda ，以此为界。恒事间随便 `回[^N]值`(&函续,a令<可变>) 但 事(now_fn) 才可作fn为值参数

  |试做… :或有((去接应 点名…)+, 去皆应…)
  |重复(调用| &?若 值…) //伪递归:改参跳开头重来, 重复&若假  会用在内联回^0里
  |(停下|停次) ([^数])?
  |问A|量!? 局部 //^弱语法: -! 重复 (若真，。)等流控链 `作值=算式.`; 读取 队跳/队你
) ；)
```

juec自言及句地把kt级语法低级至java，如同py解释器执行的kt编译器；它以 `可同<判事语法树 源码>` 的分段求值(如树模板)实现数集CoreAPI, vararg/const KV 支持真子类型

物量/`[言]` 必折叠，-! 储物参组(可repr,或流控内联)被化简如 `恒量n=x；(1到n)，[a到b] a+b是3。` 等于 `1+x是3`, 文件/"" 也可访问

`T可包含Var<T>`。 `(a==undef)+1*2 仅化简=> a+2` 而 `at! a=Int[10], ? by 10` 仅检查长度 ，等同 `链(T,链表<T n>)链表‘n=Eq.num(+1)’ `

除了内联“位置变量”, dynamic(*)型变量靠[受未知] 生成事量。真泛型在JVM前置T::class传参，例量应当froze

```js
add: 内联
$f=NO; do{f[ret=break] } while(0); add($f)

// 停次=回2N默0 停下=2N+1
不断，
  不断，
    若真，“停次[^1]=” 回[^2]。
    “回[^0] 只是到这里”

_2:while($Y)
while($Y) if($Y)continue _2
//想打断最外可外包: 令，回^5
```

```js
(File.Eq<Ln<Int>>/"nums.json" ) “链式编解-复制IO”
   .oncat(File/"add1_"):it.lets{it+1.}
File/"a.gz": Eq:
  at s=pipe(_7z("gz"),XSON()) cat “流TypedAry,像改.列: "".文件<某送>()”
  _7z("bz")cut s

data- Eq'ab'(:Int=0) Solve
  问("ab=", {a b"\n"})
  must 3:a+b
ask<Eq>.wasInit

'T'(T 有序)-! 行 二分(：T、围=满针)=令，
  量i=围 令，(A+B)/2。 “AB是局部”
  判 读(i)去比较(它)，
    先同，i。
    先小，重复(围(A=i+1))。先大，重复(围(B=i-1))。

'T'(T 📶)- 👀 🔍(:T, 🤏=🤏N) = 👉:
  @i=🤏 👉:(A+B)/2
  🧐 📤(i).📶 (🤌):
    🟰:i
    📶: 🔁(🤏(A=i+1)) ;; `#!📶`: 🔁(🤏(B=i-1))

- 文 凯撒(k=1)是 字的编号 去谈吐下「它+k」 “可同<文.字 数>:谈cat 吐cut”
- Pic(l:N2<Cnt>) = Ary(l.y):[y] Ary(l.x):[x] x%2+1
//XY.eachI:[y] (0~l.x-1):[x]

-! “Eq”pipe(:Args<Eq<* *>>)管<args>
“类型体操版compose()。 函数体无法构造 管<> 类型(来形式证明)，故仅调用处受检 ”
-! 管(串：组<类型>) = 串[0]的参[0] 令，[A]
  串去叠(A)，[a b] b的参[0]有a；b的参[1]。令，[B] 类型.参(可同、A、B)。

-! pipe(:Args<Fn1<* *>>)=fns.Sum: A then B
^now
  -!'ABR' Fn1<A B>then(g:Fn1<B>)=Fn1<A>: g(this(it))

-'R' FAny `??`=FAny: say(it); this(it)
'R' FAny=Fn1<Args<Any>>

- Q_rsqrt(:N) N
  at:
    i 0x5f3759df - n.Bit(+1)
    y i.Bit.N
  return y* (1.5 - (n*0.5 *y*y)) //2nd iter

“其实，恒事能靠组储.. 内的[真子类型]做TS/C++的检查，不必靠手写 管<args>”

//   - f(a、b)@参颗粒化<1 1>
'TA'(A 行) 函新<T> 作=函1<A *>，[a] a令「你(它)」。
```

## Def词

1|2
:--|:--
事量物例类|公私族组内
\- at data named type|our{api,,type,pkg}
储判受同造|既可未终定
data- when- was ^named made|^,impl{?,??,!}

1|2
:--|:--
值言句词|恒 试 停次
Any E Stmt Fun/Val/Type|! Try breakit

`物- 有序行 作` 扩充成员，`物- 点 矩形； 安卓 作 有Bash` 扩充子类，也用于减嵌套 `^量页=UI..`/匿名例创建

- `- 行3'abc xd'(:数、_d：参组<T>)`, `Args(kwarg by{="kv" 1}、k1=2)`,  - Fn2<Args<> You<多捕获外层Ctx 真我>>`??`=包装器:带var inspect异常?
- `os：平台“安卓”` 会检查它被“作”过的接口。量纲对原物像“待验证”标记
- 字面报错 `'' 几=行，我 不为空 按"$长.."。`，`- 行 作=断言；我行.必<几> :必<读T>`
  - 基于“新类型” ''T=数，假。 或别名 `函新=函1<R R>`
  - a去作<量纲> IAE；‘a+b是1’: ISE(默认替换a=1, 或 按"") ; 必2，1 assert

```js
事 '-'!? :型() 主语 参? 类型? (=言|:为(句)|是 值)? //'AB'-swap是 函1<“你?”俩项>:[A到B]B到A; 事是f: f参加在前面
  (^此刻 格局 :为(词) )? //事量算在头部；事物强制内联；例只在物 (隐式=私下); 事其中->转物类
参 :顿号(局部) | 聚名:顿号(局部) //事物 A(此刻i, 右皆变量)。句级语法是过程式“流水帐”，只因自举才支持
:型 聚名:顿号(访 名?|名 类型+|同名例 名)? $0 //事'' 有参属* 则隐式恒。默认名同类型,按前缀 匹配_; 'N'(N 默认_N8) N2
聚名 "'[\w ]*'"

事量 事//at id now Var.our(0“非扩充var”){读}{v=it}
  |量!? :型() 主语(：类型)? (=言 | 此刻 言 )
  :物('物-',词句, 主语) //隐式：继承自“我”，无我是 `物- 主“页” 页`, 非私下即公开物。内句被收集到 `受初调`
  //by lazy{}=😴可晚，。/观「新按旧」强制内联
)
词(事量| :型(名=类型 …?) (:物(物, 造于 小@ 参=言) 
  //作<上我>去made嘛 值隐式自同名参，如同 `类型<参>` 和 ^事的签名&默认式(含私量)

  //v 不可定.  when- as/*() Data(可选StrTag,eqLn so 终定) */ =只外移内部 dataclass
  |:物('判-',(名(参|调用?) :为(词))*)//造未定,多余型参'*' ,在同文件加子类
  |例|(类 名:@(子集*) :为(事量|同名 例) )
  //全调用=例物=新类型：值例Enum(v=0或++, 自动name=) 不引即用。以此优化[真假空]
  //否则为enum Type:byTags。单例如Add("+")加在allVal; 全无即是类
))
 | 造于 可见? 此刻? :逗(名 值)

继承 :@(子集 调用? 子集* )? // 主造=事,参数=^变/量 的集中性依据，末尾调 `受初,deinit()`
主语 :尾有(子集,'.'? 词名)? //T.内T. fn 链尾是名
例 '例' 名? 继承? :为(词)
:物 $0 ($2 名
  :前有(造于? 可见? 参, 继承)  //(造于:) 即私下,量 已造:@可定  ; 未定事量 不必标明
  :为(词|$1|同名 例) )
```

`类：集<值?> { (同名)例词=>我.TYPE.“比文件物严格” ; 词 {名{全称} 新量 新事[名={参类型返,标,.}] 旧物}  } }`, `(类=行) <数>：类型`
- 量 类型.空 非值, .断止 无值
- `.T=我.T`, `盒<A>的俩<B>, 'AB'物- 俩` 隐式传递 你=我[^1] 。T 同名“<我=行数>”限恒事调
- 注解只能按 `量：@文 JVM<'volatile'>；- f(n=0)@JVM<'native' 'v'写2>` 和 `物 JVM(doc：文、v=1)标于词`

```rb
起点 ('#!' ~NL*) 引文 词句 | # ink{.ju,.lock.ju} 默认特殊配置 pkgs.test
  (书 点名 小@ 引文 词*
词句 (词|句)*
#use! PKG 例:`量`/PKG
#use! java.lang util; 后 use! util.regex Date:Week XEnum; ''.Wtf 为内物/包名 , use! py PIL =引子包 PIL.Draw
引文  (引 点名|引! 点名 (名(:名)?)* )* #跨平台ju. lists,nums Rn,Sort,text,cont

格局 可见? 可定? 的?
可见 公开|私下|族内|组内
可定 ^|"[可未终]定"
小@ :@(子集+,NO))? #^的验证: 可见性>, 可定性!>上我; 可定性<此物; 上非0(私下/终定)
:为 :新缩进($0) #P.Lay换行{后, 视词右空格(s.ws)决定'}'或继续: ws 仅忽略行首更深或有'的 去 或'新行
```

```js
(0~5)令，[N]
  量t=Nsec；待命，t的延时；说("$t后")。
  可重入，“被N个线程调用后,1次跑1个”。

- 起点=“卡调栈 全局 +”待做Waits，
  待“(函续启=无懒单调)”，“Promise.自动调then (即函续Cont,它+函许)”。
  函许CoPU.XX(名=s,线程池,当抛=,) ”去待做，launch=待命Job(coj)「观队Co 添1」。
  CoPU: withCtx, 由当前待做新job ; 去关闭  有一(Has1{})，co，[x]

  观“改列”<数 数>，“asyncIter 例如3次(非1次3个)延时对话框。 yield的可以是await,再自动then 直到next()； ”
    重复若真，添  添()
    1s延时 “作() 的异常栈 由调度器catch和转发”
  去略首 令，[s]
    说(s添1)

  观，5s的延时；添1。的首
  列化行SeqLn([1 1])「它[0]+它[1]」  “列靠添,被回调,不会栈溢”

俩量(角90deg、力1f)
必.12，俩量(.123)去锯齿(0“round”、2)的x “N2,Vec2是数 CalcEachN”
🌿可为树ETree<V K=Str>{桶,它; 读缩进} 📖词判Trie.AC.马科夫, 数判({0 .1 .3 1}、V) 环队RingBuf
N量=Nd 🎼频域FFT((1~500)dy“Nd.dXY=N2”) ((A~B) dx).Sum:f(x)dx

named 二狗 项目
  made:
    tags "cli net os".Sep
    to "A good boy to fetch"
    by "you@CRUD.org"
  - wasInit
    `#our task` by[]: say(NO)

量 读 写 物 例  类 判 受 同名例 我 造于 书 引 回 的 去 、 你 它 上我 此刻 可定 未定 终定 公开 私下 族内 组内 SymCmt
@ 📤 📥 ✨ ❤️ 🚩 🤔 🔮 -❤️  😶 🤌 📖 🔗 ✅ . . ,   🥺 🤌 🙄   👀  🙋  👶  🧑‍🎓    🔓  🔒   🔐  🔏 Eng

行  围 表 俩  可为 可同 改同 谈 吐 队 观  列 集 问 改 
👀 🤏 👁 🆎👈 🧐 🔀 😋  📥 📤 📭 📪 📬 📫 💬 🙏
令算 令 滤 序 带 叠  长  添 泡 有 存于 不重 复选 Math 正则
🤏 👉 🔍 📶 🖖 📈 🍡 📥 📤 🔜 🔚  🦶  ☑️  🤓   ∞文

待 若 或  路 否 重复 停下 停次 函续 函许 待做 试做 接应 皆应 错 错误 抛回
😓 😊 😒 😊 🧐 🔁  ⏹  ⏭   ⏸  ⚙️   📝 🧐❌ 🧐  😠   ❌ 😰 🗣
⏪⏩⏮⏭🚪☕️📅⏰🎲📂📦🏁

数 N 计  针 文 字 且 真假 作 必 函 可变 组 参组 值 断止 类型 TYPE
🔢 N 🔟 👆 文 A & ❓ 👍 👍😠 🙏  💾 🍡 👀N 📩 🚫 📩🧐 ❤️❤️
```

## 附录

[Lua5.3](https://www.lua.org/manual/5.3/manual.html) 是词法域小语言的典范

```js
句(;|调用| (var,)=(言,) |
  if 言 then 句 (elseif 言 then 句)*(else 句)? end | 
  break  | (while 言)? do | repeat 句 until 言 | 
  goto 名| ('::'名'::') |

  for  名=言,言(,言)? do | 
  for (名,) in (言,) do  | 
  local((名,) (= (言,) )?|
    fun 名 域)
    fun 名(.名)*(:名)? 域
)* 返?
域 '('(名,) ','? '...'?')' 句 end
do 'do' 句 end
返 return (言,);?

val :链('('言')' |名) //左递归本质
var :val([言]|.名,名)
调用:val( (':'名)? ('('(言,)')' |文|KV) )
KV {:隔("[,;]", 名=言 | [言]=言 | 言)?}

:隔 $1 ($0 $1)* $0?
fun "function"

言 :算符小先(JSON|nil|... |KV|val|fun 域,
 '^^; * / // %; + -; ^..; << >>;&;~;|; == < > <= >= ~=; and; or', '# - ~ not')
```

### 合法性

绝句的封装必须为解决kt/py里的「高门槛or低复用」而存在

ju|kt|py
:--|:--|:--
[1 2]|listOf|JSON子集+tuple,set
obj:, 1.let:+1|apply,run|无this
let(to=rw.Ln)|mapTo(mutListOf)|[*iter]
缩进,{}{}:|{},=|:或pass (仅流控)
Try!?|first/OrNull|调用外NPE:AttrErr
i移右,list右添|i++,Stack|+=iadd,`deque`
判你,去路,若或|when(val=), if-else|仅(A if q else B)
mayAs,may?{} or|as? T,takeIf?let ?:|or或match
data made(),val=get|private constructor(val),val get()=|@dataclass
判-作 储物 (_ADT_)|sealed class: data object/enum{WTF{}}|仅dicts
事物 量纲 作|value class+init+继承|几次T.fnval=\self:
量纲/‘’字面报错/必|require,check,TODO|raise;无嵌套注释
'跨行',复选|'''.trimMargin,EnumSet|C式"" \\ "NL"
val:量表,(val表达式)=1|val语句|a,b=b,a
函我2,你|(context)A. (B) -> R|无this
letIf{it<0}:abs (_LDT_)|filterMap|[for x in if]
nums.KV_K:it-1|associateWith
firsts|take/DropWhile|`itertools`
事@文 弃用<替换>‘新’|@Dep_(@Rep_(""))fun|''' :tag: doc
`- (:Decorate<Fn>)`||@wrap
重复(i=i-1),重复&若|tailrec fun,do{}|仅while
回[^N]和你我,as上我|let@标签{this@TYPE}|皆无
?(函函续),or:break|编译器?:链,跳转句作算式|不能 `cfg[k]or return`
!事(now_fn)|inline fun(noinline fn)|无宏/跳转级
`File/"",''.File<判事>`|Json.fromFile/Str|dump/s
(^此刻)物-|紧凑object{}+inner class|@print def
(T Send)类定同名例|T.serializer(Targ)&typeof|仅dicts
可送,var可定|noarg,all-open|^^
T: Any.TYPE,*,x in T|::class 反射, js `dynamic`,is T|type(x): dict原型链
Set(含数组,Str)和Seq|仅std Collection,原型数组,无rw.Str|`typing`
val=by,A 可继承<类>(v)|val=Var, A:类 by v|hook getattr
wasX+get+set,lets\`*\`|operator和::,infix|`__dunder__`
N2(x,y)|裸WebGL|`np.ndarray`
事'abc'(:数/N)是宏|不支持,也没有'N'模板或函宏|^^
Int,Cnt1~8,_N4 _N8|JVM类型,UInt,.|默认bigint
rw.Eq|javaIO(链式)流|open().buf
(类事互通),物- .作|external/expect|cffi
`x:Pair=(1 2)`,`data- as` 跨接口|_仅为兼容 Rust,Go_|弱类型

分清动静态(编译)没意义。弱类型即动态类型，而C是强类型弱检查。参数的“成员”是反射常量，或是编译期“未定”的字典链，都不应给元编程造成区别

参照|主旨|好处|坏处|范式
:-:|:--|:--|:--|--:
kt|事物模型,集合/异步|?.run, when is, DSL代理,await协程流,KN跨平台|XXArray,列表,Mutable事杂乱割裂; @元数据,check,XXer链 样板八股|OO
rs|解构/可改性,组合与解耦合|var语法隔离, enum ADT, 报错可读,rustup, class事量与扩充平权(物量由made-init),源码宏|if let, &mut和take检查, 宏模板,type复杂(局部alias,)|FP
go|用词与UNIX|var指针,{}字面,`data- T1 as T` 和 type 接口,[并发队列](https://gobyexample.com/range-over-channels),广义Encode|err和OOP退化,C化 弱检查,[]不擅算法, RAII的nil,defer|PP
js,py,lua|API风格|上手快,利于照抄|弱类型,难复用:不适于多页级软件, 慢|eDSL
yaml|变量表风格|易于内嵌 for/空或,TeX,bash DSL|编译期计算
rb|元编程|取代reflect和kdoc,KSP, 支撑序列化等动态结解构|沙箱安全
