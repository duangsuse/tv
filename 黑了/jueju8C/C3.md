# 绝句-形式语言

>隐类型名动词OOP：跨语言/范式、跨语种、编译期计算新语言

语境语序至上，帮助产品经理拆分定型软件的民谚：

编程无关步骤。编程是重建事物的视角，是让解法类聚、相联的 __创意环境。__

思考不离语言。术语化技巧非软件刚需，终究是靠理解“变中守恒”的领域功能

脚本/老教、函数式 Rust式、工程派学院派；排版级的范式，不是绝句对标或“抄越”的叙事

<img alt=Urbird src="Oriole.png" align=right width=150 style="filter:grayscale(1) invert(1)">

## 文法

3层级：值、言句、词，编词为书。实现建议：

AST如 = scan(`[{左,右},/吃[a-z]+/, {流,or:串}]`) (右吃char流)

parser递归下降+过滤流，以提供span高亮(st=0时跳空格)、缩进级/配对'('的传参，简化报错

span锚点链表能增量解析 `""` 等位置修改-如csv[[]] 内1单行 ，`函/事.受调尖` 编辑时类型检查

`1+2*3` 以逆波兰算符重排求值。`a [0] ()` 等后缀则叫言小，记法(+-*/,自动有 `!isEmpty`)

和keyword以Trie分词，名记平权如 `1+a令为，{到2 到3}。` (ju_en无需分词)

- 高亮编辑器有“语序厨房”，显示时匹配行正则，容许高亮词条直接编辑 如 `俩项(A：A、B：B)。对何<AB>储物`
- 高亮绘制以json diff 复用行贴图
- 文数、储调、判 性质物&语法的颜色是 橙绿、蓝 红 ，在 ju_dot 节点化笔记本(算式名->变量图)里也一样。事量物为同心圆/方/棱形
- 解析&寻址 层面遇'⸮' 则报错其可选补齐

## Val值

```js
_值 JSON|"内插"|'跨行内插'|0xCA_FE|0b11| 真$Y|假$N|空NO
//可嵌套“”注释。`[] {}` 靠 `造行<字>('c')、造表(1到"")` 
//  `组(3)「i」 组去空<数>(1)； 改，造行(66)。` 用于不简写的情况
//转义 \nrtfb'"$\。 '' 或结尾于空行+'

名 :tok(:止于记法(utfLd+)|『.+』)
词名 :tok(「记法」"[大中小]右?")|记名
点名 :tok((utfLd|'.')+)
//"$a ${1+1}"； '$a' = 受内插({""}、{a}、"") = ""+a+末项
记名 名|记法
//高亮：软可为名、常(事,量,.)不可为名、苛(+,!,记法名) 切分名字。 Syntax.ju 定义了是否苛构词(量,val,.)
NL "[\n\r]"
ws ("[ \t\f]+"|注释|文档)+
注释 :略(注释,'“”', "[“”]")
文档 :略(文档,'‘’', "[‘’]")

//~处可能是配对的” 或新嵌套注释
:略 :tok(:包围($1, ($0| ~$2*)* ))
```

『数字文真假空』 数字类型(数浮计 1 2 4 8)有C++式自动填充 `对何<数 我>`(如值.同名：类型<我>)，`100L+1f+10u` 靠记法 `量 数.「L」：数8`

## Expr言

1|2
:--|:--
令滤序带叠|行表集组列
let only sort zip fold|Ln KV Set Ary Seq

`事 T.令`/令为 即forEach/map ，取否takeIf，`5次“亦作T->列”，。`

可写的行，如 `物 组：行<T> 集`，`改行：可添 组`，`列 带号 令，[是x到i]。`，令let 改叫『看』。行作列=iterator

JVM
- int非Object，Int箱才可交给 `List<T>, T[]` 里。故装箱 `组<数“int”>.作：JVM组<读数>`
- T[] 的反射不存在擦除，但泛型接口里容不下T=int。故优化 `组“+改行”<T>.清零：标<JVM "重载"写 组参<数4 字 真假..>>`, 亦如 `行“+组”.皆(0)`

```js
言小 :链求(_值|指代|条件, 后缀 // 事 T?.「?」(函1、“回”：函续<R?>)：T
  |的 名 |去 名  |[(值 、)]
  |:或有(<类型+>, 调用))

指代 你|我([^数])? |名|'('值')'|它函 |简集
它函 「(记名|言)」 //ju_en: Fn1{}

简集 '{'言'}'
//`{1 2} 或 文本变量，{:a 1 b 2}。` 由 `例 文本变量.『,和:』`
//  之上 `恒事 受未知=IntRef..`/ `值._(:值)` 展开-如 `若，。 若，。` 3宽+2高
//  为方便bash和UI 调用， T.受逗句(组参<UI“/观”>) 会捕获T上的逗句参(内UI值,不含非恒内逗句)，且：可高亮

条件 判| 若(值)…(否则…)? //例物：位旗； sh选项令，若有..

判 '判'(你? 值 记名?)? :逗((言|否则) (、细分匹配 |…))
细分匹配 (言 、)… | 判
//行<可变>.受解构(:行<值>)，位置上支持 受未知/函试/Args(x)/略，TODO。
//判{"K" 空 4}，造行("K"、a或1、「它>3」)
//判1，数“类型<数4>”、判""存于，{"甲"}.. 。可变<-函试<-“数.同名：集<值>”在 `例 文本解构` 转化

言 :算符小先(言小, '* / % 空则 $小; _; + -; < > ~ 令 令为 有 存于 $中; 是; 且; 或; = $大', '非 - +', …参|'')//特殊右项
//前缀的3种优先级为 `(?f)("帮调试")、(!a为男)是假、添(a+2)，。`

调用 :或有(:顿号(值), :或有(它函+ ,…参) )
//例.受调尖 创建 `类型.参` 例，子类兼容(值有数,数有1) 由 数.同名 检查
//如 造表<数字 文?>(1到""、0.到空)。再看 {it+1}.ap(0)   for<TR> fun Fn1<“写”T R>.ap(:T):R

类型 上我|'*'|_值|:链求(点名, <(访? 类型)+>)'?'?
访 读|写
//同名事.受调尖(:组<类型>)：错?，`某事<>` 只给TypeVar(推测=*, 形变=读) 赋默认，组<T>：行<读T “调尖里启用”>
// 集值 可为 集数，改集不可并报错。读写T只关于类型灵活性
//写T: 函1<数> 可为 函1<值> ，故要禁用返回T=数 的事量，而对<读T?> T仅写空

…参:逗(句, ([名+|是 言+])? )? //函我N<>首参默认[我]。可省略 `{0}令，[x “按序号”i]。`
…  :逗(句)
:逗 '，'$1 :新缩进($0, '。')
//受调用()  接受逗句(OOP函数值)和 待，所需的函续+函蓄(try和调度所需)。
//调用尾(名=值 、)。作<上我>的调用 值隐式自同名参，如同 `类型<参>` 和 !事 “既事”的签名
//T作R: R隐式构造 ，
:或有 $1|$0 $1?
:顿号 '(' ($1 、)、* ')'
```

```js
事 “函我<” 双主语<文 文件>() .find=改{"$你/$名"}，
  你去列?去平「它去 “文件”find」 空则我

类 列 { 「右incy」 「移右inc」：T.. } “域Rn<数>(A、B) 表(K、V)”
类 有序、有闭、有复、有封送
‘存皆 存一 存(1) 令滤 滤不(空) 乘(2次:组合),阶乘Xuniq； 可添(长 为空 略=末i 满i)’

{1 2 1}令，滤首(1)必{1}； 滤尾(1、转换={})。
(1~6)令，首「它>5」的i；尾(3)；我[1~3 按1]；我[略-1]； 我?[2]。

({"a"1 "b"2}带2 “步=2 补=「空」 叠=行”)去表，[是{k v}]k到v。去改若(无)
{1 2}带"甲乙" “补=空 交=俩项” 令为「次到首」 去隔 “+令滤 适合做前端导论”
lrc去隔，带右去滤“间隙过长的i”。

{1 2} (叠「+」 “Sum{+}”)必
{1 2}去叠(0)，首+次。
"ba b"去分() (叠「+」的逆步)必"bba"
{假 真}  (叠「且」的逐步)是{假 假}
("ba b"去分)(叠「+」按「长」)
“分组计数”
(1~20) (先大)(叠，行+叠合(0、「右」) 按「它/10」。)
nums(有序按，{先小「它/10」 先大「它」}。)

(1~10)去序两路「它>5」
{1 2 3}去叠，首*10+次。
列去平(123、「它%10 到它/10」、止=0)
  去文(""、"^"到"$"、1到"…") 必"^3…$"
```

## Stmt句

```js
名值 名(：类型)?(=值)?
值 言
句((言
  |量 (名值|名 是 言)
  |回([^数])? 值? |抛回 值
  |量 :逗(名 值)  |(变 类型? :逗(名 值?))+
  //变，钮；框。“赋值时类型 或” 变 行<数>，a“=空白”。

  |试做… :或有((去接应 类型…)+, 去皆应…)
  |重复(且?若 值… |调用) //伪递归:改参跳开头重来
  |(停下|停次) ([^数])?
  //事作= 靠隐转让 重复 (若真，。)等流控链变为 `作值=算式.?` 的弱语法
  //P.Lay 视句右空格(s.ws)决定'}'或继续，ws 仅忽略行首更深或'的 去 否则'的新行。'|'里s.st= -1 (不跳空格)
) ；)
```

juec自言及句地把kt级语法低级至java，如同py解释器执行的kt编译器；它以解释或 `可同<源码 判物语法树>` 翻译实现数集CoreAPI

```js
不断，
  不断，
    若真，“停次[^1]=” 回[^2]。
    “回[^0] 只是到这里,不同于回”

_2:while($Y)
while($Y) if($Y)continue _2
```

恒事参/量读写 `恒量n=x；(1到n)令，[是a到b] a+b必是3。` 等于 `1+x必是3` ，储物组参(可repr)被化简 ，否则做流控内联(可抛/回) 。真泛型也为JVM前置T::class参数

```js
Eqv.lets {pipe(txt("nums.json"), JSON<Ln<Int>>) } “链式计算-IO”
   .oncat("add1_"):it.lets{it incy}

恒事 “Eqv”pipe(:Args<Eqv<* *>>)：管<args>
“类型体操版compose()。 函数体无法构造 管<> 类型(来形式证明)，故仅调用处受检 ”
恒事 管(串：组<类型>) = 串[0]的参[0] 令为，[A]
  串去叠(A)，[a b] b的参[0]有a；b的参[1]。令为，[B] 类型.参(可同、A、B)。

“其实，恒事能靠组储.. 内的[真子类型]做TS/C++的检查，不必靠手写 管<args>”

事 文.凯撒(k=1)是 字的编号 去做谈吐「它+k」 “可同<字 数>:谈cat 吐cut”
//   事 f(a、b)：标<参颗粒化 1 1> ：类仅恒Typeclass
对何<TA>(A：行) 函新<T>.作=函1<“行<字>”A *>，[a]a令「你(我)」。
//空白作<行<数>> 寻找了 同名例 行“：可复“我=行<数>”.同名” 内 !量
//盒<A>.俩<B> 匹配 `对何<AB>事物 俩` ，仅此参非static
```

## Def词

`物 A(变i：数)`。绝句里，句级语法是过程式“流水帐”，只因自举才支持

1|2
:--|:--
事量物例类|公私族组内
fun val thing insta class|same{,0,type,pkg}
储例判同造|既可未终定
data enum when -insta made|!,impl{?,??,!}

1|2
:--|:--
值言句词|恒 停次
Any E Stmt Fun/Val/Type|eval breakit

- `事 造行(：Args组参名<"abc" “皆”数>、：组参<T>“.试做”)`
- `Kwargs组参名(dict、{:"k0" 1}、a作<组参>、k1=2)`
- 注解只能按 `量：标<文><JVM 'volatile'>；事 f(n=0)：标<JVM 'native' 'v'写2>` 和 `物 JVM(doc：文、v=1)：标于词`

`类型：集<值?> { 名{全称} 词 {新量 新事[名={类型,标,.}] 旧物}  } }`， dynamic(*)靠[受未知]生成事量, 量 类型.断止 无值

```js
事 :有('事', 形参?(：类型)? , :为(句) |是 值)
  (其中 格局?，:新缩进(词+) )? //变量 算在头部；事 事物强制内联；否则算物(私下). 对何<我T>例 也可导出扩充
形参 :顿号(名值)
型参 对何<名*> :顿号((访|名) 类型+)?

词 型参? 格局 (
事|:物() |例 名 继承 :为(词)
  |:物(事,句, 主语) //隐式：继承自“我” 而非值，否则是 `事物 主“页”：页`。内句被收集到 `受初用`
  |:有(量|变,：类型, :或有(读 …,写 …)) //by lazy{}=可懒/可晚/观「」
  |类 名 :为(物词) | (名=类型 …?)

  |储:物()//v 不可定
  |:物(例,(名 调用)*)//隐式：值例Enum 例物不引即用。真假空 以此优化
  |:物(判,(名 形参)+)//可含impl??,在同一书加子类
)

物词 词 |同名例 名? 继承 :为(词) |造于 形参=言 //made=made()
继承 (：类型 调用 类型* )? // 造参的参数=量，只负责赋值。造于是事，末尾调 `受初()` ，物 也：可继承(by v) 

:物 $0 '物' ($2 名) (形参?|格局 造于 形参)继承 :为(物词|$1)?
:有 恒? $0  (主语 词名) $1? (=言 | $2)? //成员
主语 (类型 '.')?
```

`事物 点.矩形； 安卓.作：有Bash` 是子类扩充，而无我 `事物 主：页` 用于提供 `!量页=UI..`/匿名例兼容

- `os：平台“安卓”` 会检查它被“作”过的接口
- `对何<> “新类型”几=行「不为空」`，`事 行.作=检查条件；行.必<几>`，又如 `函新=函1<R R>`
- ^类似 `行 令<可变>`，量纲对原物就是“待转换”标记，`变，x 0。{x “T推导为数”}`

```rb
起点 ('#!' ~NL*) 书首 (词|句)* | 书首 词*
# 可以 use1 某例; use1 java lang util; 后 use1 util regex Date:Week

引 点名
引单 点名 (名(:名)?)*
书首 (书 点名)? (引|引单)*

格局 可见? 可定? 的?
可见 公开|私下|族内|组内
可定 '!' | "[可未终]定"
:为 为 :新缩进($0, ~.)
```

```js
(0~5)令为，
  量t=它sec；待命，t的延时；说("$t后")。
  可重入，“被N个线程调用后,1次跑1个”。
  要求，1必1。断言，q必真 按''。
  

事 起点=“卡调栈 全局 +”待做waitAll，
  待“(函续启=无懒单调)”，“Promise.自动调then (即函续,它很函蓄)”。
  函蓄CoroutineCtx去新() (名=s)“的域”去待做，job=待命launch「续列Channel 添1」。

  观Saw，5s的延时；添1。的首
  列穷SLine({1 1})「它[0]+它[1]」

俩量(角90deg、力1f)
俩量(.123)去锯齿(0“round”、2)的x 必.12 “Vec2是数”
表树Trie 队环RingBuf 频域FFT 阵Nd
```

## 附录

[Lua5.3](https://www.lua.org/manual/5.3/manual.html) 是词法域小语言的典范

```js
句(;|调用| (var,)=(言,) |
  if 言 then 句 (elseif 言 then 句)*(else 句)? end | 
  break  | (while 言)? do | repeat 句 until 言 | 
  goto 名| ('::'名'::') |

  for  名=言,言(,言)? do | 
  for (名,) in (言,) do  | 
  local((名,) (= (言,) )?|
    fun 名 域)
    fun 名(.名)*(:名)? 域
)* 返?
域 '('(名,) ','? '...'?')' 句 end
do 'do' 句 end
返 return (言,);?

val :链('('言')' |名) //左递归本质
var :val([言]|.名,名)
调用:val( (':'名)? ('('(言,)')' |文|KV) )
KV {:隔("[,;]", 名=言 | [言]=言 | 言)?}

:隔 $1 ($0 $1)* $0?
fun "function"

言 :算符小先(JSON|nil|... |KV|val|fun 域,
 '^^; * / // %; + -; ^..; << >>;&;~;|; == < > <= >= ~=; and; or', '# - ~ not')
```
