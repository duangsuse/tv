- 融化在界面树里的JS 用易组合的 `wOSK(),as,when` 取代 `<v-for if>` 和模板指令，亦能复现JQ的爬虫功能，且<abbr title="带变量合一,使键变量1:1绑定input,div的内容,且递归下降">不以 vDOM diff</abbr> 推测JS赋值或push后弄丢的变更点
- 0模块ES6 倘若只是想在[成百上千行的组件]上继续做项目，告别碎片化import吧！EQ三界与定义式编程，使H5的语义更明确，顺便让行数至少减半。
- SFP单文件路由 `eqjs ssr xx.htm` 里的 ee.组件函数=，不只为方便UI-UX-样式打包发布。简明带来的远不止“快”！ 人生苦短，快点完工，睡眠是最好的维生素。
- 不是玩具 统一的关键字风格，一句话描述自己的diff,SSR理论，保证不为“三行碎代码”够酷而重造DOM已有的功能，不把联邦裂为孤岛！

EqvJS: <abbr title="你利用JS，不是JS使用你">克制</abbr>的框架联邦，只会“选中”段落和变量 (Modest framework federation selecting pages & vars)

- 融化在界面树里的JS。`ee.UI=({dataVars})=>HTMLvar`, `as([1,2], x=>li(x))`, `when(x=>[$Y,$N],[A,B])` 将擦除掉前端的一生之敌： 事件异步+视图树(连接到数据) 的写法和模板算法差异
- 0模块ES6 告别成百上千行的组件和碎片化import吧！EQ三界的100%定义式编程，使H5的语义更明确、略过UI-UX-样式打包，顺便，让行数至少减半
- SFP单文件路由 `eqjs ssr xx.htm` 和HI(class)等工具，减少五花八门的实体和配置。把你的“雕塑”从多样的API里取出来吧！人生苦短，快点完工，睡眠是最好的维生素。

无印痕流控 React,Vuer会熟悉的 `{/*v-*/if:$Y}` 可以自由加在  `div$topics(as([],模板)); html(when({type}, {User,Blog}))` 标签里，`__id$样式,when(class{数据(A,B){} })` 无需学习css,js即是最佳实践

EQ希望成为网页应用的『基础』。基础有两种含义：技巧匮乏 vs 用于设计的知识

请勇敢地踏出每一步，把新的高度踩回脚下。被迫改变的应该是技术，不是人。

>EQ哲学是对功能“消毒”。在代码生虫前，就删掉那些易“变质”的美味。事不过三。一切概念，一定服务于更大的概念。
留住统一而简明的关键字风格。不为“三行碎代码”够酷而重造DOM所负责的轮子，不把联邦裂为孤岛

- 选中「按键变量」来赋值或复制-即 `age.as(Eq.num(+1))`
- 合一「反正挂载」到新增或(完整)既存的子节点，wOSK后深至文本级爬取-替换，稍后让被 {age}=app.it 选出的键量: age(新值) 带变量合一，不操心 `$(onvar,x=>upd)`。不向代码里[注水](https://svelte.dev/blog/virtual-dom-is-pure-overhead)，不求靠大佬[复苏](https://www.builder.io/blog/hydration-is-pure-overhead#a-note-on-memory-usage)
- 联络。一个JS世界，一种调用语言，跨越会话和SSR的界限，对同名的功能说HI。把文件读写/音频SVG滤镜图反映在配置字典里，把每格的变量放进Dtable row。编程乐在创造，而非当翻译、造轮子！

键量能选中
页面能联络
瞌睡有枕头


UI怎么写？或许我们要看看“原生开发”：从数据创建View，用什么设计模式(甚至分页)在事件后“重新赋值”，或是把事件转发给子级，再用那些没有单位、混在代码里的数值做“样式表”…… 最后觉得软件的流畅度H5无法超越，却最终在生态上被H5淘汰

框架引擎的发展像用递归写的循环，都以为这次更深一层，实际却是不断迴圈。

关系式稍晚于“纯函数”和渐进式，但现在，该去“审判”那些积极进取的烂代码了。看看它们除了把同样一个变量，复制到一个又一个函数和“模型”，还剩下几行异于机械的，有设计性的巧思。

语言或者什么的框架，其职责就是拒绝严谨却无序的“面条代码”，其次是提供教程、跟随潮流。 设计的哲学亦能将工程难点防于未然，对经验的复用——而非算完就鼓掌，是计科领域永恒的目标。

# 对比其他框架的编程观

## 是否将支持模板或JSX

请靠代码转换。 EQ无法连接JSX/TSX编译器，也不愿用 `<template slot=>` 把JS函数移植到XML

它和 [Van<b>illaJS</b>](https://vanjs.org/tutorial) 一样，支持 `div(wSty(inJS),p(),'text' )` 风格的XML(`ee.大写=()=>要求换行0缩进`)，ee.as() 也支持克隆缓存优化——但不会让“语义级”的框架用户 去关心“显示级”的树算法。

树不是魔法，只是接受“变量”，返回“挂载(变量集到e0)”的函数，就像wOp，只是在对箭头变量推挤或赋值(顺便支持双事件+冒泡)

坦白说，我一直用XML文本+id模板或wOSK简写create实现H5动态页面。在了解Vue前我并不知道 `script[setup]+template` 或者 class `props/emit` 这些东西，也很奇怪 `render() {}` 为何要按“组件化”分离，只知道有for,if这些指令，直到后来EQ函数化组件逐步成熟，大致兼容Vue

## 会跟进Vue等框架的设计吗

在向消费者和Geek提供更多元、更及时的漂亮界面时，多个好手 强过多个对手。

EqvJS 欢迎[Vue](https://cn.vuejs.org/guide/essentials/computed.html#computed-caching-vs-methods),[Van](https://vanjs.org/tutorial#api-state)专家贡献文档、案例和(新技术需求)，也包括Svelte等[操作DOM的框架](https://component-party.dev/)、TS的爱好者，但React不(因为hooks太难看了)

对于“种田”这样的基础领域（没有在应用编程），竞争其实是要避免的。 大家都应该有性格，是适者生存，不是强者生存

为了让前端回归根源和必然，逃离XML和“diff的复用”，Eq拥抱了“又旧又难”的关系式编程-其实它比函数式诞生晚15年。以往，它像TypeScript类型推导一样是魔法，但在Eq里，请和列表字典一样平凡吧。

流行框架会标配 `[x,setX]=signal,ref` 和 `effect(_=>x())` 这样的监听模式(_get value 也是种调用_)，好像React怎么写，它们就得跟进

但尽管在简单示例表现力胜过Eq.$(多选)，ref的可组合性其实欠佳 (与它碎片化的“组合优于继承”不大匹配)，而靠memo缓存则斩断了变量间箭头使然的”关系“

嘛，就像createXXX这种极不FRP(纯函数式)的“new运算”在“定义式的”React系里到处写的都是。

与高度优化 [h()](https://github.com/hyperhype/hyperscript) 的Van又不同的是：
- __瘦结构 瘦算法 胖心智模型__，尽量不用编程领域专有的概念做功能
- __模式匹配-in-HTML__：三要素化 HTML UI 为 `wOp{tap} wSty{fg,bg} KV{if,.}` 来减小 监听on/class/style 等差异
- __选择器-in-JS__： EQ 靠 `div$css_cls__id` 支持了(bodys.live)选择器，利用 `as(a,(x,i)=>a.pop(i))` 而非靠add(派生变量)来绑定列表，甚至能 `div(it,'')(insertNode)`
- 去模块化： `export let ee=ee.fork` 以基于组件库写UI, `HI(class{'/path'(r) { r(div()) } })` 不分文件
- 统一的风格(甚至像独立于ES6的语言了)，避免 `function,const,return div()` 的无味之争，也没有 `n=ref/van.state(1)` , 变量随便加
- 让事件选中(`Eq.sel`)变量，看起来更纯，低魔法。`when(var,Y,N)(), str=html([],num)` 在纯JS里都能用

以及一些愉快的“副作用”
- EQ就是对函数式UI框架的 “定期轮询转 Server Side Push”。`obj.it` 就是EQ的“虚拟树”-但无关HTML ，因为本来就无关
- 浏览器[本就会](https://stackoverflow.com/questions/37039667/executing-multiple-dom-updates-with-javascript-efficiently)“批量修改DOM” 再reflow ，EQ不会对数组以外重新检查 [“vDOM变更”](https://www.reddit.com/r/reactjs/comments/mo4g0t/why_virtual_dom_is_considered_faster_that/)，再用setTimeout去哆嗦着赋值(甚至整队遍历)那些“State变量”-如果单script的“批量”性差,rAF不就更慢？ 为什么总有JSer觉得自己比V8,WebKit懂回调队列和重绘--甚至更懂编译呢？ 换个名字就觉得“前端框架的尽头是渲染”了？承认术业专攻就那么难吗？自己不开辟，非得移植别人剩下的？
- JSer 的优势就是即写即用和弱依赖，所以EQ不会像Svelte那样只有建项目、编译后才能用，因为编程编译本就无关 (尤其与编译性能之类的“配置”无关)，而且，易写和易维护和性能 EQ我全都要
- 外编程舞台：Dform强类型+SSR表单、PWA文件/多选/封装、SVG与声音滤镜图 use.NS(efx以此做特效渐变)
- 选择浏览器,H5，“不折腾”，本身就是对 `android.view.*` 等框架和语言的淘汰，“首当其删”的就是那些设计模式的烂代码、怕电脑太慢的无跑分编程观，和显得专业或聪明的 易问难答的算法技巧--就像 [Dijkstra说的](https://en.wikiquote.org/wiki/Edsger_W._Dijkstra#:~:text=It%20is%20practically%20impossible)。 比如EQ支持SSR-wOp或HI前后端。但没关系的，做不做都一样，就像EQ的首屏SSR0也无“hydrate算法”

对比|Van🍦|Eqv🐬🥽
:-:|:--|:--
标语|0.9K开箱即用，无React/JSX的响应式UI框架|克制的框架联邦，针对页面段和变量
设计|响应式state,绑定到节点,分批更新DOM|JS的可变量-解构模型推而广之到HTML，实现语法共用和框架一致性
对界面的理解|`div({on,attr,}, ()=>li或null)` 里每项1次,新旧state比对,{attr}绑定函 返回原节点,否则update时做替换/删|--
-|`div(),wOp,wSty,wKV` 这些 __挂载函数__，与(完整)既存或新建子节点 __带变量合一__ 降至文本层。__选中或as派生__ 一些按键量来做UX (靠 `app.it.to` 来合一新旧状态树/组)|合一 unification
新增节点|`van.add` 可手动增加组件|只允许 `as([], x=>), when(u.type, {admin:})` 做GC和Node复用,而 `wKV{if:!hidden}`
响应式更新|`van.derive(()=>myState.val)`,与bind(逻辑,节点)对应,元素删除时被GC|`my.as(x=>+1)` 和 `Eq.$({my},_=>)` 是it.变量，onvar监听,数组ondiff独立于DOM，__无全局diff队列 无需bind 不GC__
也就是|新建"全局"变量,bind"可变函数"给(text,KV?)节点, .val赋值(derive更新)后,updateDom里批量比对,替换节点|wKV或div(html/when替换) 皆是把变量合一到节点，`app.it.to(st1)` 把变更合一到变量树
SSR|支持文本模板,JSDOM 两种模式|降低迁移难度，主流支持wOp上传-JSDOM-HTML下载，SSG支持递归 wget

__作者不计划自己编写与React等框架的完整对照，而是写了这篇文章议论EQ的基石和未来，因为我确实不擅长DOM和元编程之外的太多技巧，比如，配置开发环境和手写配置样板。__

## 关系式是纯函数吗

是。 `ee.T=({可变解构})=>` 是EQ区别于大部分DOM框架的基石(_与Svelte殊途同归,也南辕北辙_)，它并非强化的面向对象或事件，而是古已有之。

请考虑 TypeScript 泛型：可以从程序体和赋值构造出签名，再靠签名验证push等调用/查同名重载。那么“类型变量”有副作用泄漏吗？ 如同 `Builder.setXX` 吧。向参数写入的自限性(C#,Go,GLSL都支持in参数)，不比到处copy+Memo差

同为响应式，`UI=f(state)` vs `ee.UI=({dataVars})=>HTMLvar`，EQ比其他框架都特别：特别傻瓜、特别不“脏”

计算机是不纯的。纯所带来的检查、拷贝和反模式，会引入难以优化的运行和编辑期开销。 数理是纯的：无法结构化复用、难以“传染出”社会价值的。 `python` 启动比 `bash` 慢30倍，语法也业余不少，但这时谁会在乎快慢和“你的纯度太低”呢？

一些人眼里异步编程(就像副作用)是反直觉的，但他们真正反的只是回调地狱等“独特的”设计，而不含自动传入回调的await。

简洁不是指能读敢改的符号少。EQ试图将ita(`obj.it to as`)作为ES6模式匹配的子语言，而不与 ee-wOSK 配套。 我们不是想依附GraphQL等(新)关系式语言，以谋求“进步”，而是为设计师们，完善JS的技术栈

不能为了“字面上”够纯，就学习样板代码。关系式 `a=1|a=2, f(a)` 并未“赋值”、算式 `N2(0,1)*2` 并无“循环”。任何流行语言的 __定义式declarative__ 框架，一如需求本身，皆无副作用

## 会很学院派吗

EQ式的理论更重视开源、自由的生产力。EQ排斥以照本宣科为发展的理论。

框架和AI是让你调整一切的工具（即一种文档）。要框架“保持愚蠢”，反而是对软件工艺的终极检验。初学的人做不到，之后却易忘掉。

XML有着“自己的XSLT模板”,DTD校验,XPath 的各种JS接口，Live的Node迭代器和集合，1999年XHTML“大行其道”，但今天没人关心它们。 而技术史上同样大但已叫不出名字的，比月亮上的陨坑还多。

>EQ想做的，也正是让开发者不再手写繁琐、无结构的XML式代码。

一位好的厨师不会为食材的优质而沾沾自喜，一位优秀的程序员不会为“过度管理”的繁茂而踌躇志满。 不要考验智商，因为过去70年IT的爆炸，比之300年的物理学史，已经证明单靠天才经不起考验。

定义式编程，不是说边写边添加会惹麻烦的抽象概念，而是 __预先知晓软件的一切，再用严谨却自然的语言写出来__：

在问题和“聪明药”出现之前，缺陷已被根治。_EQ不是为聚光灯下几段最佳实践的爆酷而设计的_

带变量合一并不是“连证伪都不能”或“连错误都照抄”的灌输的理论。相关API，都受「使用情景实例化」的“计票”和监督

工程的前沿发展到 diff“双绑”,memo,parser 花了50年，最后却只是给Prolog添加了“赋值和箭头函数”……

简明与美是智慧的赞歌，无序和繁琐是机械的伴奏。 真正的热爱，是不拘泥于标签与形式的，是克制的。

如果说，Svelte 是前端界的 Lex-YaCC(解析器生成器)，EQ就是[PEG,ohm](https://ohmjs.org/editor/)或[pyparsing](https://github.com/pyparsing/pyparsing/blob/master/examples/indented_block_example.py#L26)，源码简单，刚好够用。

>EQ有使用一些10年前(2011)存在的“{}的响应式”, Kotlin 域语法糖、50,60,70年前就有的 Tk-Prolog-箭头变量,Lisp-组合函树,Fortran-Nd矩阵。但无需刻意对照。EQ糅合了它们所有的优点：为可读而取舍 ，也添加了Eq关系来绑定JS对象/数组、减少死板的IO+解析操作

## 我喜欢-但怕比别人没竞争力

国内外都很有人重视“鄙视链”，但考虑他们的朋友，比他高的-他帮不到，平等的-他真的是与之“互利共赢”吗？

鄙视链对应的叫“工具人”，因为相信人间、乃至专业间只有竞争而无进步，只有能耐而无快乐，他们没有职业以外的、天赋的自信。 但你爱怎么看，和我有什么交集呢？

我对知识的执着，不是为了全面地否定其他框架和技术，玩娱乐圈的欲扬先抑；而是无论成功或报错，无论流行或冷门，我都真诚地热爱编程所能办到的一切，并信仰这种事业带来的普世价值，而不去看圈子所定义的高低。

因为，我追求的不是对或错，而是已知和未知，是工程文学美术的黄金比例。 我学的不是老师口中的编程

几百行价值数万的代码，是在十万行但不值钱的、三千行但要花一个月的代码…所有这些之后产生。 四年里，我与之日夜相伴，一视同仁。我不会以可能出错、“分数”太低为借口，放弃一种种可能性，因为迄今为止所有技术，都会有正说反说，但立场间并没有真理。

如果你看到的优雅失去了标签和特色，如果努力的最后证明了过程的愚蠢，那就随它蠢吧！计算机科学是对设计的工程和基建，没有被文字游戏唱衰和神化的，假设性的价值。我们仍要发展能握在手里的工具，要学习，也敢忘记

## 前端已死--EQ会让你的工资减少

自有计算机以来，编程一直在被取代着。 今天每个常见的文本框，要支持的复制粘贴和各种手势，可能比一些前端人一生的作品更复杂 (又比如 [64k-intro](https://www.shadertoy.com/results?query=boid), js1k.com)。框架与开源demo的发展可谓是“不问自答”的AI补齐，但从 DOS到Win32,到 Form.XML, 到CMS到React时代平台们所减少的复杂度，却从没让生产力超过经济的上限，甚至没能阻止框架和术语的碎片化、无法挡住绝大部分人对“黑魔法”的迷恋。

如果你将 `(简单直接的代码==易取代的初级代码)`，认为低代码必以低创为代价，你可能该听听EQ作者的看法：

回想天圆地方的年代，多少精英口中的真理已成现代脱口而出废话，而数理公式的简化和补丁也足以见证一个世纪的潮起潮落；比如，受到威胁论的误解和攻击。

技术的门槛和价值是不对等的，这取决于消费者和同质化。 乔布斯所推广的GUI并不是专利、现代的网红所做的无非是积累和造势，有人觉得“高等”的知识必须复杂，但往往是更简单的语言模型在支撑更复杂的文字。

Python 的革命远比 C++ 初级，7年深入JS厂商和算法的CoreJS却[穷困受辱](https://github.com/zloirock/core-js/blob/master/docs/zh_CN/2023-02-14-so-whats-next.md#筹钱)，随文艺复兴萌芽的现代物理却藉藉无名。 精英主义者，可能不太在乎史前幕后有哪些人是真正的精英，更不懂社会对跨领域工具的迫切追求--复用与巧思正是编程的特征。

__EQ能帮开发者逃脱同质化，让自己有市场，但改变权在你。__ 假如你有策略地挤进了编程界，却发现前端知识并非需“三年修行”的保值品，那大可改学AI,后端,移动原生，因为它们也本不比“被框架拉低”的前端高级，很快也要“被衰落”

与其说开源工具在抢你饭碗，不如说，你的公司 也是靠上一波框架的简化，才能跟上时代竞争的。

更高的技术，不意味着“挤占更多资源”，相反，它能让所有人更好更廉价地完成目标。问题在那些不重视公用设计、演进和新产品的公司，或者大环境

还有件有趣的事情：智能输入法普及前，联网通信要找打字员；但语音识别成熟十年后，仍然有种“会议纪要员”。
Web领域竞争很强，但真正帮到办公和设计的却很少；与其深入潮流的符号，广阔的世界更值得我们思考

## 前端已死--AI会取代程序员

这正是你要立刻切到EqvJS的理由！ 未来所有“高难度代码”、易用难解的技术领域、复制粘贴样板码的的性价比会急剧下降，__就像搜索引擎出现后“知识付费”会大受打击一样。__ 你用不好AI，就会被AI用走本属于你的钱，反之亦然！

React的代码可以用Vue生成，Rust甚至纯函数语言与算法可以从Python迁移，它们的专业用法和术语就会相对失去价值--因为概念的意义，本就只是其提供的“设计体系”与选择的热情。

__“人和动物的根本区别在于会制造工具。”__ 近百年来，所有人的脑容量没啥变化，技术却不断爆炸，是因为事情变简单了，而非精英或术语增多了。

倘若一个程序员能为用户设计工具，却无法反思自己的工作流程，又或者觉得自己的框架处在异于用户的“世界”里，他等于是住在动物园里写东西--因为他制造的不叫“工具”。

技术的迭代就像武器的发展，往往更有利于普罗大众，让弱者也能完成曾耗时数月的工程。因此许多曾“被技术选中”的人，觉得自己要被机器取代。但是，需求不会因为门槛变低就消失了，新平台更会考验你对技术和产品的取舍观念

和为“复现”而技术的画匠不同，前端人不懈追求「时尚而独特的」界面交互与产品切面，所以成了开发者

“画匠”终究是职位，「面向运气/查错编程」也只是自嘲，想当某种画家 才是创作的本质和投资价值！ 我们与不会自己挑选知识成长、世界观统一的机器助手不同。即便给AI数天，也画不出你心里最优的故事

即便可以用HTML堆出一切，即便靠RIFF随机作曲——“什么都能生成”，也还是有人在分享自己喜欢的设计：因为比常识多，所以便有了职业。

至于认为Geek的门槛在于高低代码的人(很像在觉得Markdown不如 <kbd>Ctrl+K</kbd> 创建链接“更易写”，或者 true/false,yesno,01 编程“更自然”)，大可拿他们在 wix.com (CMS的继任者)上的网站，或者 Builder.io,[Tango,Axure-EQ的图形编程对等物](https://tango-demo.musicfe.com/designer/)，与流行社媒平台对比，说明为何专业设计者的任职是无必要的--只因我们“太细节”

~~低代码那种UI连线满天飞没大纲的平台，你要超过三个人一起改包？~~

程序员的本职不是苦管项目结构，而是为客户提供「便利全面的、与时俱进的」App的设计。__EqvJS，就是只注重成品，抛弃了专业和历史包袱的框架，是最适合搭配AI编程的全栈框架__

## EQ语法糖很慢吗

开发者的自由时间远比CPU的珍贵。我不会为无[数据支持](https://thecodebarbarian.com/thoughts-on-es6-proxies-performance)的 _性能损失_ 而牺牲易读和功能性

或许你认为难懂而重复的代码就是快的，但作为lib的开发者，最好别给你的下游制造“无默认值”之类的麻烦，来显示文档的“用武之地”。不过，EQ是怎么解决JS语言级的'with语句' 问题的呢？

as/to(Eq.at), ee,svgg,Nd 都使用了 `as=it.evalFun((_,f)=>f文本替换, (_,f)=>'_as(f)')` 这样的动&静态变量解析

对 __执行过的代码__，to()利用RefError交换新变量到全局表，并最终提示完整替换。在 `eqjs x.htm` 优化后就变成不使用eval的普通“手写”JS

EQ也可以换用静态分析(很像“处理所有 EvalFun 类型的调用”)，但我们不是元编程库，不会执着于多写Test就能规避的问题，还有很多更有用户价值的API等着移植呢。

## 定义的元素都能被爬取

EQ确实可以默认配置为“代码保护”，禁止组件被F12 `ee.$=({x})=> app__id(x)` 反向匹配(scrape<=>render)，但.min.js 已经能保护很多了

爬取者，只需要在另一个EQ(比如能操作“干净DOM”的WebExt)里把你的组件大致描述一遍，也能拿到数据。__如果你害怕被解构，请努力不去看到EQ框架__，因为这就是 how EqvJS works。

你可以再读一遍标题，~~这不是废话吗？~~

既然识图AI,Selemium,辅助功能,DevTools和油猴替换,. 都能够自动化Web甚至原生的App，你不应该假设任何客户端代码是“可信”的 

所谓反破解是指工程难度，从理论上防拷DRM反而才是不可实现的。图文语验证码都被大模型卷爆了，而且，开放才是 how Internet works

## 会从PHP,JavaEE汲取路线图吗

历史上，Ruby,PHP,Lua 乃至Pwsh,Bash这些语言都有过自己的亮点，可惜不像JS-ES6这样，有人贡献出颠覆性的改良。 他们大体上是式微的，但后来者也未必完全令人满意。

- PHP CGI 单文件路由，可以非常直观地调用HTML模板；但EQ鼓励前端主导Web全栈，以及用 `HI({路由})` 的模块化，减少“纯CRUD脚本”


