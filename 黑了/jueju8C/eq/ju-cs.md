我们程序员对一段功能的「设计力」，不是按「能读懂的术语表」来计算的，小心搜索引擎那样的伪理解。 能用和懂之间的差别，不是在是否 syntax error 上，清晰和繁琐也不是换个术语乃至字体的事。 

你要建立的关联和灵感，是： __变量|此问题的领域，而非 变量|仅有名字相同的常识__

先站在作者的视角， 去推测他的选型和「私货」， 然后慢慢把我的猜测与实际合一 ；这时短的魔法是不影响理

编程界确实存在一种频谱，能无视术语和范式，绕过一切的烧脑的刻板印象，只量化每个函数本初的比重，一统工程和学院派。

视频有60fps vs 关键帧+弹性动画，音乐有441k vs .midi+乐器采样，图片有500px vs SVG+滤镜，代码也有「5万行 vs 100行」的'定义式'keypoints： 在写到纸上/内存上之前，我们对代码已心如明镜。 这种极简主义不演不算的未卜先知，叫做「编程能力」，因为它让文字等同思考，让描述成为解答。

这些哲学与三字经就像元素周期表，它们提醒我该把新发现的设计归在哪里，正因如此 我记下的灵感才不是堆砌
它们是在漆黑的夜里，让繁星般乱眼的符号黯然失色的月亮。 简洁明亮的月光，抚慰了山穷水尽的思绪，
让我明白优雅并不高深或独特，它只是问题领域的组合，是编程语言的进化史；正因看过丑陋，才该决定代码的焦点去向何方，这几年，该我告诉计算机何为对错。

没有比代码本身更好的类型签名，没有比含有各种边界情况的示例 更好的测试和文档。 代码的正确性，是它和你设计诉求的重合度，否则，就像无论拍摄多少像素的夜景多少遍，也只含黑的情况。

即便编程的外行，也可能见过像 for;return 这样的类-C语法。 学写代码，就像通过阅读「文字」和猜测语意，get到了你和计算机、和流行框架交流时的「语言模型」与习惯；编程就像为了拓展自己的疆域去学外语，并不特别

有些算法就像这个简单的“循环式”[老鼠陷阱](https://m.youtube.com/watch?v=EKyIcX6I_AQ)一样，写起来缺少力量，却杀bug不扎眼。

工程界里，有许多问题就像这个陷阱；原本简单，却随着功能需求和概念的堆砌，慢慢让人高攀不起，而设计派的理论，不仅像龟派气功那样，酷得让你编程时的打字声拳拳到肉，编译出App也一气呵成！

无论什么层次，编程都是一种充满乐趣的创造力与共同体。除了你家的CPU和内存，大家也不必全力以赴。 我..其实没什么想教的，只希望你不会因眼前的“屎山代码基”，忽视你所做功能本身的惊喜和活力。

在这里，我只会说明为何“编程领域”是必要且利于学习的。编程语言有四种：

0.无类型/asm,bytes二进制
1.按类型/C,VB,PHP
2.子类型/Java,C#,JSPy
3.类型期编程/TS泛型,模式匹配,SQL-Prolog

类型签名的多少，与实质上的强弱，与编译/解释型其实都无关。 

一般，弱类型=调用时转换；强类型=(编译器转换, 1+"1"等“不强的转换”被改为重载)。 在你靠解释和编译来区分语言的强弱前，看看 C,Py,Flash(ActionScript3) 这些怪胎，

C乃强类型弱检查(比JS还弱,C“对象”皆无类型. `int[]->int*` 越界了,被骇了还能跑)，Py则把弱类型强检查(“渐强类型”gradient typed 也是静态检查)

Kotlin等新语言是带推导的强类型，Flash和JS+V8是编译型“脚本语言”，性能++。 坊间传闻雷军大学时写过一个x86解释器。各种“语言之父”能遥遥落后吗？

被戏称为C++框架的CPython,开发了GH的Ruby,游戏常用的Lua,跨平台Flutter 都配套一种种类似JVM的虚拟机。甚至luaV的局部寄存器，还更像安卓的Dalvik字节码,或 x86,arm等常见CPU指令集

所谓结构化就是指按类型，但汇编语境下，类型只在mov,add,.单个指令里存在：

- `FA(16), 0xFA, #FAh` 这些写法哪个更像“整数字面”？
- FAh 是单位写法，如Java的 1.5f,1L 的数值+类型。汇编里类型是'ax,eax,rax'等寄存器或内存读写运算的专利
- 0xFA 则对应了命名不能以数字开头。它更像JSON5,HTML,.文档树语言里，基本值的写法

而随着类型的清晰，我们对问题和职业领域的把握，也会逐渐形成跨语言、跨算法的心智模型。

如果执行Java,js线程的循环叫JVM,Node，C线程的“Node”就是Linux内核；如果序列化,分配Py对象的叫Pickle,GC；Linux文件树和长休眠的靠就是Ext4和页面Swap；如果主机,OS间的调用靠“收发线”socket-fd和协议，进程级,数据库间的调用就靠RPC和Bus。USB的'B'，就能传输文件读写等调用

如果调度线程的叫CPU，完成协程任务的就是主循环(平行vs并发)；假如死等函数return的叫调用栈和局部，等待事件触发|回调的就叫协程栈和闭包；如果绘制安卓view的叫[Canvas](https://developer.android.com/reference/android/graphics/package-summary)，近70年最强大的单页/排版框架就叫DOM,SVG和GL(sdRect,.)。

OS和Compilers 的术语对应得像刀叉般紧密，以至于 Qt,MSYS2,r2和frida 等框架的作者，能无师自通各种OS的生态。谷歌甚至为JS,Dart创建了ChromeOS,Fuschia 乃至其硬件周边

但Python的尽头是C语言吗？ 编程无关电子计算机，就像天文无关望远镜。 软件工程，是让每个领域的算式和方法相遇、相连，形成专属于你的领域。

编程范式，就是指「语法能够辅助思考」的侧重点，不包含numpy,WebMedia等社区库，也不含++--,指针引用 这些语法糖

语法和类型能够辅助思考。Java,JS实际上都支持默认参数，但JS在2015版(ES6) 才有定义式写法； `json.loads("1")` 很方便，但你不能为内置的number添加新函数，也没法像YAML Schema 那样自带补齐

在写后端时，按User,.类型拆分代码，分模块时不只能把对象当成字典

有趣的是，在1.和2. (FP vs OOP)之间有 React/Vue,Rust,Go 等现代语言和框架，Rust和TS则同时支持3.

如何选择函数式和面向对象？

先怀旧下，C里没有匿名函数，假如你想在段错误时(“内存不能be READ”)手动退出，`signal()` 接受函数指针和一个“回调参数”，也就是this

编程是把小领域组合

种地是经济的基本功
在现实的使用更多
基本上是隔离的，这种学习很像金融里的自融行为，你向他投资的回报，只含它自己，那你就被它套牢了，入坑的学习成本也无法回收

启蒙老师
Ruby元编程 算法图解
ES6移植Java Kt 纯ES6 自己做语言 Prolog numpy/GLfrag 摸清协程和RPC

Lisp.rkt,Haskell最多教我把方法理解为函数,局部变量是图, 以及提供递归DSL的还不如js字典的丑陋写法

语言后文字

解析是什么？

a=1
def main(a: List[Str]):
  a #?

动态作用域就是parser嵌套的表（键值原型链）。在吃到def时，要吐出 `reflect.Method` 那样的树节点，来被class之类“列表块”组装

不过，树主要是计算器级别的语意。在吃def时，参数-引用 被查找到局部Var(v) 默认保存了$0这样的编号。在调用时，从栈上取，放回运算结果就能实现调用链乃至递归

而外部的this变量，就是匿名函数的另一个全局表，叫“闭包”。 它和调用栈、全局导入 构成了函数的运行时。
- 闭包 `栈转堆`。把外层局部 `(a,b)=> ()=>` ，创建私下对象。如查找 b=第i个this的编号变量j, b=i0.j1
- 协程 `栈转堆`。把外层return `()=>delay(1)`，弄成回调时函续。对浏览器栈呢，返回键就是回调-回去赋值
- 对象 `共同读写构造期局部的多函数`，支持private可见性,open final等函定性, 函数就是有 invoke() 的对象

接口对于算法，就像USB对于数码设备。 换个算法，就像文件换个网盘，程序员刷操作系统，并不会造成麻烦，但设计得狭隘或难插拔的接口，除了妨碍新功能 新用户，更会让框架有代沟，产生node_modules等众多碎片化和依赖地狱

API和语法、语意学的重要性一直被低估了，以至于一个"Pythonic"就能让数理库大爆发，虽然py对函数与组合式DSL的支持，被框在filter,map,@wrap def 和numpy模式里 而难以扩展

- 前后端 通过HTTP路径/?参数/Header环境变量 `实现RPC调用`，和模板表单或两边校验。这个传参模式 很像命令行CLI
- 数据库 按行列过滤的 `提速版Excel`。特性支持比照术语:{数组 文档型  能循链接 图QL Vec2(2量同算) 向量}
- CRUD 对列表a: `a.push({age}), a.find(x=>x.age<10), a.find().age++, a.pop`, 后3项共用ORM
- Cookie 会话"句柄",会话号。酷卡是在登录页 被后端设置的限期token，指向其{用户名数据,.}对象；用集群的私钥签发此对象-防纂改，就叫JWT。QR登录也靠`共享对象号`
- 注入 依上文字典`(向参数)赋值`，以提供代码没写明的配置

新特性、[老砷尝“谭”](https://code.golf/)
- 指针 int32(4byte)等`变数的地址`。函数局部/数组/struct 里的名都是不打*(x)的指针和加法乘法，所以读 `*(void*)0` 会触发内核，CtrlC掉你的线程
  - 引用 含变数的值，因为不可变引用叫值，编译期值叫类型或const。想栈上分配省GC？先内联函数,即宏
  - 高性能 别和JIT编译器内卷谁聪明，多用numpy等定义式框架，做>3ms 的PGO跑分优化
  - GC,Rc 复用 `malloc(sizeof struct{x,y})` 的被引数跟踪，为0时才可free。对象图越小越块
- 强类型 用编译期能“运行”的语法，写函数/类签名，不能有if: class: 等元编程，序列化和调试很难
  - 装箱 int补上Class标签。ListT不是 `template<>` 代码复制式实现，不能赋原始类型给调参：Integer可为null
  - 序列化 递归读写变数(组)或多情况类型，只是`给字典补上标签`
  - 解释器 见到一种结构=做一种转换。 `printf`, 深拷贝就是这类算法，用 `['Sum',1,2]` 能模拟子类型
- 模式匹配 `unify([1,x],[1,2])` 遍历检查以让“变数”.v=值
- 关系式 组合变数间'等且或=,|'成立的解集，做DFS、类型推导(即重载查找)
- 栈 调用层叠.“非常容易做GC”的堆 引用:可变数(不取值) 闭包捕获:x(栈变量转堆对象),内联:return转赋值


FP
- 纯函数 能支持memo KV缓存,懒求值(is&&print),并行化的算式及Effect
- 协程 Promise.then就是 `async()=>` 的“函续”Continuation，调用者负责设为回调。`yield x` 保留函续后，才能“多次返回”、next(发送) 和过深递归
- 状态机 就是 `A: if()goto A` 等流控,DFA
- 伪递归 :改参再循环 纯数据:把堆里的变量放栈上来重赋值,就像y=f(),=>1+1=2 
- 编译 浅先遍历,解析TWRP结构,检查类型,以把变数-引用查成节点图IR 再深先, -或者直接解释
- 解析 用正则分词,递归吃流前缀,吐TWRP树: Tuple When Repeat Paren/逆波兰排序 是AST和“序列化器”的类型。下一条，正波兰
- lambda演算 S-Expr(括(号) 树) 的纸笔计算, 传单参“颗粒化”curry的好处如 `o.key` 语法可解读为 `(ijVar,key, locals)=>`, 在编译期求值了2参
- 词法域 `C函数为何仅全局`。对比 Lua-Upval, [Py-cellvar](https://juejin.cn/post/7286670786563244090#:~:text=co_cellvars), Rb-capture
- 逻辑式 Prolog等,据变数关系的DFS搜索语言。 ts类型推导,apt版本管理-SAT,数模求解-SMT
- Monad 用函续(自动回调)来规避赋值，实现[堆上流控和异常](https://magic.huohuo.moe/html/Continuation.html)并美名"代数+工程"
- Y组合子 YCombinator.com , 致敬匿名递归: `Y=c=>(f=>c(f(f))) (f=>c(f(f)))`, 需包一层懒x=>`f(f)`(x)
- 停机问题 证明NP完全--比多项式'大O(复杂度)'还慢的代码，是否是死循环。

Trie(Radix=Hash),kD,quad,Seg

大道至简和"大道智减"的理论，之间差距，在于是否实事求是。 是既动手又思考又比较，还是思而不学；以过度设计把一堆合起来看很简单的功能，弄成逻辑自恰、词不达意的鸡肋

不是告诉我怎么做，为什么领域大家
别人教，瞎子摸象
好学生一定是好老师。 的教育，让理论成为招牌和孤例的刻板印象，无意于工程和进步
理论不是造轮子、造同义词 乃至换字体。只有样板与特例齐飞，函数共领域一色的文字才配称为科学规律；这种形式化的扩展性正是数学思维所缺乏的，因此，不能让GPT替你学编程语言，因为程序员也是能穷举细节玩法的用户
不过，算术和方程还是可以代做的！

如果你把一整本数学书扔进IDE，可能会找出一堆「未用的定义」 「重复的算式」，这些怪异性就像不会被解释的奇点，暗示你它的深奥且美丽..即便这个“且”是伪命题

初中水平都能写软件，那多
世界上再多几个Linux和GNU，同等价位的服务质量还能往上翻两倍
要是我被内卷淘汰了
英国工业革命那会内卷还严重些，为何你今天更滋润了？

比人肉 ，框架调用侧
