# 又是恐NaN的一天

我们来谈谈计算机数值的实现，大家都打过的计算器，拆开里面有树脂"COB"封装芯片(硅逻辑门)；简单算术如 1+2=3 ，也要在2进制寄存器上合并与进位。寄存器的位数固定为8,32,64位。数的四则运算和比较(CPU之ALU)是数码的根本，仅仅把一组数据填0，也需对计数指针做加法，

>可这和浮点小数有什么关系呢？

和负数(补码)的优雅不同，IEEE754 浮点符号分出了 +0 和 -0，也有特殊值 NaN Infinity 。+1e+2==100, -1e-2=-1/100=0.01

>这不就是科学计数法？

对，相当于整数和小数二进制化后接在一起，用次数=2 表示小数点位置如 100.0 ，变为 1100100 删首1 



排序后 -+Inf 一定在行的头尾，NaN!=NaN 但也将其放在行尾

>浮点由符号(1为负)、次数、整数 构成。下期会提到字节序

在2进制单双浮点是 (1+8+23) 和 (1+11+52) 位，Inf和NaN 会以次数=最大 存储，不过有一点，浮点除了上下限(1e309)溢出也有 1e-324==0 的精度丢失

>对了，顶上 `1e309 1e-324` 这些魔数(magic)是怎么得来的？

309约是 `log10(2**1023)` 即10位e的最大值，而 324是 5e-324 `==2**-(1023+51)` 的次数。 1/1e309 含正溢就是0 ，(2-2**-52) 则是，显然，这比整数加不加符号位复杂多了；不过浮点没有位运算，它的值域比起精度问题就不太重要了

不丢失精度的整数极值 `Number.MAX_SAFE_INTEGER=2**53` ，这比52多1位 即首个1。

25.5=0b11001.1  单位化 0b1.10011* 2**4 即是 浮点(0 131 51)二进制化


## 引

- 计算器 [历史](http://www.vintagecalculators.com/html/integrated_circuits.html) [具体ALU](https://www.righto.com/2020/12/reverse-engineering-early-calculator.html)
- [黑点下面](https://qcwo.com/technicaldomain/how-chip-on-board-cob-circuits-are-assembled/)
- [IEE754](https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/) 1e0 的次数位是+ 2**(7或10)-1 而小数点右是0，"不规范" 即次数固定仅+- 时值域更宽