# 为什么不

绝句是门名动词对象+函数式 的多范式语言，参考了 Kotlin,JavaSE,Py/Ruby 甚至 ES6,C++,Haskell 等不同风格的前辈

在语法和标准库设计过程中，自然也产生过许多或有高低、或有优缺点的选择，绝句的信仰是简单与易复用，但它具体放弃了哪些“新潮”做法，这一系列会带着原因 将绝句的红黑榜说给你听。

## 创建对象

在Java `储物 俩项(首：A、次：B)` 需用 `new 俩项(1,2)` 堆上分配，而C++ `俩项 p(1,2)` 是局部生命 栈上分配

绝句里 `俩项()` 靠 `俩项.同名.受调用()` 重载，由编译器实现。分配内存&构造器初始化不必提及new，我们觉得名词、结构体就不要和细节步骤混在一起，人不该提示“生命周期”等编译知信息，即定义式编程

## OOP

绝句用物类与“公私族组”表继承、既“可未终”表多态，的/去 访问实例量“值”，虽不完全生活化，也相对容易记忆。 我不认为改后仍应叫OOP，毕竟绝句面向的是事与例 而非“对象接口”。

OOP即面向对象编程，许多情况不写class，比如VB,C 里也能完成脚本，但往往过于冗长和难复用，尤其是 `list_get(List,i=0)` 这样就很显眼 缺少“主语”即“行为目标”的概念；而在 Haskell 里运算符 `(!!): List t,Int ->t` 兼容各类List，但缺少命名空间

OOP有多态(同名多义)，新建无名子类 `new Listener(){}` 的SAM单(虚)方法被用来提供函数值。继承的实现大家也能在 Lua,JS 里靠原型链实验下(靠{}.都是虚方法)

OOP有调用链，当然是对“主语闭包” `用户()令，名=""。` 缺位的弥补 `用户.Builder()去名("")去建` ，`名(文)` 会返回this 以允许右侧调用。如果你把 `a.b(1).c` 换成 `a_c(a_b(a,1))` 就能发现调用链易写易执行，类似bash的管道，这也是为什么Kt和C#的“扩充成员”如此重要，以及Lisp家族如此难读-语序只有反的 没顺的

书绝句只有屈指可数的全局函数，`变量集去换(a到b)` 这些也是无主语有归类的计算，我们肯定希望代码有要点，这就是OOP成功的原因

但我们依然要限制“方法调用”的滥用。Qt 里o的属性x+=1 是 `o.setX(o.x()+1)` 的 get/set 形式，强如C++ 依然让“字段”作为二等公民，不可覆写地“高性能”暴露出来。它没有错，可Qt,JSP-Spring 要100%可扩展就不对吗？

此外，OOP也有“接收者receiver self this that  发送者sender 信号 消息” 等已过时且易混淆的术语-说的就是Smalltalk

最后提一嘴，我不觉得记流水账的C或Java代码就不算脚本，毕竟Py的ctypes与ffi 能调用dll库函数与读写struct，Jython能无缝互调，那些隐藏“功能”并非静态编译的专利。 决定用完即扔的不是语言，而是人。

## 胖std

标准库的强大在早期Rust彰显："hello world" 就有2M体积，但只用libc 就是2K

标准定义则最好说 ECMA-JS ES6 了，加号类型隐转有10行

标准的庞大并不总有负面影响，比如 Python 有 argparse,optparse,getopt,configparser,cmd,pp 5个命令行相关库，如果你要用JS式({a:1}).a 字典，有 argparse.Namespace 和 typings.SimpleXXX.. 两个标准实现

好吧，其实书绝句附带了终端彩字、REPL、反射等少量工具，但实用程序的依赖库是陶瓷、律ABC 的外围库会有命令行参数，文件格式 的读写支持

绝句支持翻译到GLSL,Bash ，因此核心库(不含 pkg jueju.data,.)+数据集这些概念=标准库。 如果什么都自带，那要 `juec -Sm lvA` 即 `sync manifest` 做什么。为什么 MSYS 安软件用的是pacman呢？因为它连libc都不装就能用。Less is more

## 函续

函续是被编译器自动传入的“调用方状态”。当你写 `for(i=0;i<5;i++)yield i` 时，yield 会暂停当前生成函数=g，等到 `g.next()` 才i++并在yield或return 时得 `{value:undef,done:true} ` ，预取1value就是Iterator next hasNext 了

只有 `待完「」，。` 1个函数不收函续却能调用接收函续的“断续函数”；因为对断续的调用导致自身“临时返回”，如事把自己交给yield，且它的结果也只能给自己的函续

这个描述很复杂。尽管实现了 await/async (fetch!=挂起回调度,响应再恢复) 与懒计算列，绝句不建议大家在参数尾写 `：函续<R>` ，因为 `事=待，` 性能上基本一样，只是1参待填而已；`列` 上更是如此。非懒算列和带号 都是有优化的

## 读写形变

Kotlin 的 `Array<out T>` 变 `Ary<get T>` 且sort等改写方法被禁用，reified T 对恒事自动可见。getset 都译为读写而非取置；文件IO译为添泡，这是按耗时尽量统一分类

## 管道

讲点抽象话。之前说调用链很好用，那为此做 "pipe operator" `1 |> atMost(%,10)+1` 可以吗？试想在Py你可以 `[1,2] |> map(|>%+1, %)` 替换 `map(lambda x:x+1, [1,2])` 、`Apple()|>setFruit`。

这个在F#,PHP Hack 里是真有的，但只能 `"1"|>Number` 或 `"1"|> $=>Number($)` 显式参数

要删掉$ 可以用 `1 |> add~(1, ?)` 的半参调用-绝句里确实有像的 `1令为「+1」` ，「+1」可理解为add(? 1) 虽然它指「我+1」

着鸟说的对，那叫 `[x+1 for x in [1,2] if True]` 或 `[1 2]去滤看为「真」，+1。`。我们不该对码块有太多写法，步Groovy和Ruby的后尘，为少写俩参数弄“半参调用”前也要三思

绝句是支持 `[1 2]「添」；1「+」` 的主语引用，也支持 `1令(说)；数「+」` 的函数值(::引用)；还有 `js值 其令为，[是造表(name、age)]。` 的ES6解构

我们选择默认参1为"它"且禁用 setFruit 等根源问题，只要有可能，绝句不靠新语法引入任何特性，尽管拥有最强大的解析库"律"。

对一门语言的最高评价，就是淡忘它的名字。肯定没人在评论区强调“我爱讲中文独有的段子”

## 多主语

再来一个传参的问题。绝句支持双主语(我和你~) 你=我[^1]，如 `物 页面 为 事 数.像素=我*你的像素比`

我们知道Kotlin 1.6 已支持 context receviers ，即 `context(App,Db) fun log(info:String)` 里会混入两个this，把fun换成class或()->Unit都行

若App,Db都有name 该怎样？ `name@App` 照样。这给了类继承外用this组合来编程的新模式。为什么绝句和它过不去

如果App和Db 重名项过多，就不得不弄 `interface HasApp{val app:App}`，这也不是关键点。值得吗？为了不写参数名，就多写点 `with(App()){}`、并打散变量集

在绝句你可以 `对何<T>(T：带App、T：带Db) 事 T.` 来实现前者，并直接为外部“我”或T 扩充实现接口，但双主语只能定在物类

```
类 JSON易 为
  事 文.「:」(：函我1<JSON易、值?>)=写(我、+我 去函())
  事 文.「:」(：值?)=写(我、此值)
  事 写(：文、：值?)

物事 改表<文、值?>.作：JSON易

改，造表(""到2)。令，
  "name": "小明"；"age": 10
  "friend"，
    "n": 10
```

绝句主张用“扩充接口”进行组合，且不要(乱序)嵌套过多主语。3个主语比11个参数的函数更加离谱。

## 值改代理

Kotlin 有 `User(): Money by wallet` 和 `val key by map<Str,Any?>` 两种by，绝句有 `ByImpl值继承<Money,wallet>` 和很类似的 `val xx=ByLazy: 1`

`ByLazy().v get set` 会实现"xx"作为等号左/右值 的部分，恒物会内联生成 xx_isInit=$N 以省内存

相较于Kt的 `getValue(KProp,self)`，绝句也有 `Var.V.k: Prop` 被注入，总之值代理变为基于 `值变<T>` 类型声明，在局部能拿到Var.V子类、「其中」不能。

