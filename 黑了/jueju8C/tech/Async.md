让我们先从一段奇怪的抓网页流程开始，首先你要HTTP GET，但成功后为避免用户哄抢，等待3秒才输出网页文本

用 Thread.sleep 这很简单，但在绝句有 `待<T>、得<T>、待得<T>` 即 Wait,Res(Ok Err),Async 3个类型，除了Res 都直接相当于 Promise 与 async 函数，那先看怎么摸鱼

fun imGood = wait:
  val body=fetch("baidu.com")!.get.text
  say("Still loading!"); delay(vip.way(1s, 3s))!
  say(Py.bs4.HTML(body).text )
val /*穷B*/vip=$N

事 您没事=待，
  量body=抓("baidu.com")!去取 的文
  说("正在努力加载呦^_^")；延时(3s)!
  说(Py.bs4.HTML(body).text )

其中!是“去等待”的意思。
先从延时这个“简单事”说起，像安卓、VSCode 都是单线程应用，主线程sleep(1秒) 整个界面都假死了，那延时、定期之类一般用新的Timer线程去等待

引 绝句.进程

例 说1：线程() 为
  既事 入口 为
    线程去睡(1s)；说(1)

利用 `说1去起` 才不卡死主线程，再把“说1”任务化呢？

物 睡个(：秒、后：函0)：线程() 为
  既事 入口 为
    线程去睡(此秒)；后()

`睡个(1s、「说(1)」)去起` 也能实现延时。但假设有个大聪明，他想用晶体物理和组合代数证明1+1=2

事 睡(：函0)=睡个(1s、此函)去起
睡，
  睡，
    说(1)

或许他脑回路很浅，但花括号是极深的。好吧，这是JS ES6以前的回调地狱，在绝句的天堂，用 `：函续<R>` 类型的回调即可

物事 睡(：秒、后：函续)：线程() 为
  既事 入口 为
    线程去睡(此秒)；后()
  事 受初造 = 起()

事 入口 = 待完，
  睡(1s)
  睡(1s)
  说(1)

事 待完(：函0<函续<R>>)：R 为 “卡死主线程，直到被回调了才退出”
  变R? 值 初空
  此函()，值=它。 “设置回调”
  重复若值是空，。回值

让入口的函数可以在 睡() 时被打断，并由接受“函续”的睡恢复。这个技术叫协程Coroutine，本质上它是不靠调用栈return的调用种类。绝句以状态机保留执行位置，但相互调用的约定才最重要，也就是把返回值交给函续Continuation

休眠的并不是 睡() ，而是待完() 的函块，它将自身的函续传给2次睡()，即有2个状态。如果睡()在若假里面，待完里的 值=它 会直接被调用，而不由新线程通过 后() 唤醒协程，隐藏的返回值传递了是否需要休眠并退回调度循环，所以，优化的协程调用约定是

事 待完(：函0<函续<R>>)：R 为
  量 sm=SM(空、0)
  此函(sm) “给入状态机，若其睡 调用方睡”
  重复若sm的r是空，。回sm的r
其中，
  物 SM(变 “上个返回值”r：值?、“执行位置”i：针、“局部量”v1=此函..)：函续 为
    事 受调用() = 据i执行下一步

于是，`f=a(同a())+b()` 的调用从等待a返回，变为由a“催促”f整体的计算，最终结果交给函续，催促调用方，直到main执行完毕。对 onclick 任务里也是如此

这是绝句协程的全部底细。不过其实，很少事直接收函续，大部分事=1个 `待，。`

能直接调用那要 `待<T>` 干嘛？尽管上集说过，绝句的单参恒物会被内联，不需要靠直接写出来降低开销

一方面，直接加参数必须写明返回类型；另外这也是为了和 Promise 更好对应，从而用 all,any 对 `待<T>` 组合等待，再另外回顾刚才你就能发现，物SM加上 `事 待(函续)` 就成了待，为了便利这么做 性能也没差

那么协程和 JS 的 function* 和 Python 的 yield 有何联系？用最常见的 Iterator 看看吧

对何<T> 类 迭 为
  量「有右」：真假
  事 右：T

对何<T> 物 组(：组<T>、变i=0)迭 为
  既量 有右 读，i<此组的长。
  既事 右 = 此组[i] 令，i右移。

C++ 的迭代是指针相等，Python iter 则利用了异常，那么 `列，交(1)。` 如何实现

对何<T> 事 列(：函我1<列域>) = 列域()令，
  此函()，有右=假。
对何<T>
物 列域：迭 为
  既变 有右=真
  既事 右 = 上次 令，再来()。
  私下变T 上次=待设
  私下变函续<*> 再来

  事 交(：T、：函续<*>) = 令，上次=此T；再来=此函续。

此函可以自由地调用列域.交 并休眠，若交() 从未调用，有右自然=假；交1次 就能右1次，右() 时此函结束，仅1项

其实，你不能在不接受 ：函续 的事里调用断续函数。绝句为列和待完的死循环提供 `函续去捕(「此函()」、尾操作)“作函续”` 来优化，而协程通常会由 libuv、Dispatcher 等事件队列负责拉起，因此不会和常规代码有顺序关系

再其实，绝句的 try: 和 trys {} 不能用于 Async 即 `Wait<Res<T>>`。可以用 `(openCfg()&{ init(it) }).seenErr { throw it }` 来逐项组合错误处理

最后，我们就可以用以下风格实现绝句标准库的大部分“迭代器”：

对何<T> 事 组<T>.列 = 列，
  变针 i初0
  重复若i<长，交(我[i])；i右移。
