# 绝句-形式语言

>隐类型名动词OOP：跨文化/语言/范式、语境语序先导、编译期计算风格语言

编程不学描述步骤。编程是重建事物的视角，是让解法类聚、相联的 __创意环境。__

没有无语言的思考。热点术语绝非软件刚需，心智根源是“变中守恒”的领域功能

脚本/老教、函数和Rust式、工程或学院派；这些范式，不是绝句对标或“抄越”的叙事

「通识」的敌人并非智慧，亦非人，而是挟技以奇,孤芳自怜的封建博弈

## 文法

3层级：值、言句、词，编词为书。实现建议：

parser递归下降+过滤流，以提供span高亮(st=0时跳空白)、缩进级/配对'('的传参，简化报错。span锚点链表能增量定位解析 `""` 等修改-如csv[[]] 内1单行

AST如 = scan(`[{左,右},/吃[a-z]+/, {流,or:串}]`) (右吃char流)

`1+2*3` 以逆波兰算符重排求值。`a [0] ()` 等后缀则叫言小，前缀的3种优先级为 `(:f)("调试")、(!a为男)是假、添a()+2`

keyword记法(+-*/,自动有 !isEmpty) 以Trie分词，名记平权如 `1+a令为，{到2 到3}。` (ju_en无需分词)

## Val值

JSON单值、可嵌套“”注释。`[] {}` 靠 `造行<字>('c')、造表(1到"")`

```js
_值 JSON|"内插"|'跨行内插'|0xCA_FE|0b11| 真$Y|假$N|空NO
//转义 \nrtfb'"$\。 '' 或结尾于空行+'
//"$a ${1+1}"； '$a' = 受内插「仨项({""}、{a}、"")」 =""+a+末项
//`{1 2} 和 文本变量，{:a 1 b 2}。` 由 `例 文本变量.『,和:』`
//  之上 `恒事 受未知=IntRef..`/ `值._(:值)` 展开-`若，。 若，。`

名 :tok(:止于记法(utfLd+)|『.+』)
词名 :tok(「记法」"[大中小]右?")|记名
点名 :tok((utfLd|'.')+)
记名 名|记法
//高亮：软可为名、常(事,量,.)不可为名、苛(+,!,记法名) 切分名字。 Syntax.ju 定义了是否苛构词(量,val,.)
NL "[\n\r]"
ws ("[ \t\f]+"|注释|文档)+
注释 :略(注释,'“”', "[“”]")
文档 :略(文档,'‘’', "[‘’]")

//~处可能是配对的” 或新嵌套注释
:略 :tok(:包围($1, ($0| ~$2*)* ))
```

『数字文真假空』 数值类型(数浮计 1 2 4 8)有C++式自动填充 `对何<数 我>`，数字 `100L+1f+10u` 靠记法 `量 数.「L」：数8`

`组<数1> 组JVM<数8> = byte[] Long[]` 可互换(泛型该用恒事:对 `JVM&组<“非”读T>` 传参不能靠自动装箱)。`T[]` 的创建函数必要拿到reified T

`组(3)「i」 组去空<数>(1)； 改，造行(66)。` 用于不简写的情况

## Expr言

```js
言小 :链求(_值|指代|条件,
  |的 名 |去 名  |引函 | [传参]|后缀
  |(<类型+>)调用?|调用 |…参 )

指代 你|我([^数])? |名|'('言')'|引函
引函 「(记名|言)」 //ju_en: Fn1{}, apps{add}=软件「添」

条件 判| 若(值)…(否则…)?
//例物：位旗； sh选项令，若有..
判 '判'(你? 值 记名?)? :块(否则… | 言(、细分匹配 |…))
细分匹配 (言 、)… | 判
//行<可变>.受解构(:行<值>)，值位置支持 未知量/略/Args(x) /略，。
//判{"K" 空 4}，造行("K"、a或1、函试「它>3」)
//判1，数“类型<数4>”、判""存于，{"甲"}.. 。  `对何<> 正=数「它>0」` 用于判/校验/优化重载

调用 '('传参(名=值 、) ')'
//例.受调尖 创建 `类型.参` 例，子类兼容(值 `有` 数,数有1) 由 数.同名.作<类型> 检查。dynamic(*)能[受未知]
//同名事.受调尖(:组<类型>)：错?，`某事<>` 只给TypeVar(形变=读,推测=*) 赋默认
//  如同 `类型<参>`，!(读作既)事签名,作<上我>调用 继承自同名参

类型 上我|'*'|_值|:链求(点名, <(访? 类型)+>)
访 读|写
//如 造表<数字 文?>(1到""、0.到空);「它+1」去ap(0)   for<TR> fun Fn1<“写”T R>.ap(:T):R
//写T: 函1<数> 可为 函1<值> ，故要禁用返回T=数 的事量，反之<读T?> T仅可空

//空白作<行<数>> 寻找了 同名例 行“：可复“我=行<数>”.同名” 内 !量
//盒<A>.俩<B> 匹配 `对何<AB>物事 俩` ，仅此非static

传参 (值 、)
…参 :块(句 ；, ([名+|是 言+])? )
… :块(句 ；)
:块 '，'$1 :新缩进($0, '。')
//受调用(..、函、`函续<R>`)  即接受逗句(OOP函数值)和待字句

言 :算符小先(言小, '* / % 空则 $小; + -; < > ~ 存于 $中; 是; 且; 或; = $大', '非 - +') …参?
```

1|2
:--|:--
令滤序带叠|行表集组列
let only sort zip fold|Ln KV Set Ary Seq

令/令为 即forEach/map ，`物 组：“可写”行<T>`。`列.令 let` 改叫『看』，`函新<R>` 被用于重载 `函1<R R>`

也有 `(1<2)去路「真」「空」；1取否「它<2」空则0`

函我N的首参默认[我]，`{0}令，[x “序号”i]。` 可省略。iter有 `列 带号 令，[是x到i]。`

```js
事 “函我<” 双主语<文 文件>.find={"$你/$名"} 令为，“[新我]”
  你去列()?去平(写到=我)「它去 “文件”find」 空则我

类 有序、有闭、有复、有封送
‘存皆 存一 存(1) 滤令； 可添(长 为空 略=末i 满i) 乘(2次 组合),阶乘Xuniq’

(1~6)令，首「它>5」的i；尾(3)；我[1~3步1]；我[略-1]。
{1 2 1}令，滤首(1)必{1}； 滤尾(1、作={})。

({"a"1 "b"2}带2 “步=2 补=「空」 叠=行”)去表，[是{k v}]k到v。
{1 2}带"甲乙" “补=空 交=俩项” 令为「次到首」 去带离 “+滤令 适合做前端导论”
lrc去带离，带右去滤“间隙过长的i”。

{1 2}去叠(0)，首+次。必
{1 2}(叠算「+」)
"ba b"去拆() (叠算「+」的逆值)必"bba"
{假 真}  (叠算「且」的逐步)是{假 假}
“分组计数”
(1~20) (先大)(叠算，「它/10」到 行+叠算(0、「右」)。)
nums(有序按，{先小「它/10」 先大「它」}。)
“例物 不引即用：真假空 以此优化”
(1~10)去序两半「它>5」

{1 2 3}去叠，首*10+次。
列去平(123、「它%10 到它/10」、止=0)
去文(""、"^"到"$"、1到"…") 必"^3…$"
```

## Stmt句

```rb
句 言
  |量 (名值|名 是 言)
  |回([^数])? 值? |抛回 值
  |量 :块(名 值) |变 类型? :块(名 值?)
  #变，钮；框。“赋值时类型”  变行<数>，a“=空白”。

  |尝试… :或有((接应 类型…)+, 必保…)
  |重复((再?)若 值… |调用) #回-伪递归
  |(停下|停次) ([^数])?

#事作= 除了隐转，也让 `若 尝试` 流控链变为 `作值=算式.?` 的弱语法
值 言
名值 名(：类型)?(=值)?
:或有 $1|$0 $1?
```

juec自言及句地把kt级语法低级至java，如同py解释器执行的kt编译器；它以解释或 `可同<文本 判物语法树>` 翻译实现数集CoreAPI

恒事参/量读写 `恒量n=x；(1到n)令，[是a到b “受解构”] a+b必是3。` 等于 `1+x必是3` ，储物组参(可常量值)被化简 ，否则做流控内联

```js
不断，
  不断，
    若真，“停次[^1]=” 回[^2]。
    “回[^0] 只是到这里”

_2:while($Y)
while($Y) if($Y)continue _2
```

## Def词

1|2
:--|:--
值言句词|恒 停次
Any E Stmt Fun/Val/Type|eval breakit

注解只能按 `量：标<文><JVM 'volatile'>；事 f(n=0)：标<JVM 'native' 'v'写2> ；物 JVM(doc：文、v=1)：标于词`

`物 A(变i：数)`。绝句里，句级语法是过程式“流水帐”，只因自举才支持

1|2
:--|:--
事量物例类|公私族组内
fun val thing insta class|same{,0,type,pkg}
储例判同造|既可未终定
data enum when -insta made|!,impl{?,??,!}

```js
事 :有('事', 形参?(：类型)? , :为(句 ；) |是 值)  (其中，:新缩进(词+) )?
物 '物' 名 主造 :为(物词)?
形参 '('(名值 、)')'
型参 对何<名*> ('('约束')')?
//`其中，` 变量 算在头部；事 物事强制内联；否则算物私下

词 型参? 修饰 (
事|物|例 名 继承 :为(词)
  |:有(量|变,：类型, :或有(读 …,写 …)) //by lazy{}=可懒/可晚/可新「」
  |:有(物事,主造, :为(脚本) )
//物事默认 继承自“我” 而非值，否则是 `物事 主“页”：页`。内句被收集到 `受初用`
  |类 名 :为(物词) |量纲
//v 不可定
  (储)?物|:例判(例,调用?) //默认继承：值例Enum
  |:例判(判,形参)//可含impl??,在同一书加子类
)
:例判 $0 物 名 主造 :为((名 $1)+| 物词)

物词 词|同名例 名? 继承 :为(词) | 造于 形参=言 //made=made()
主造 (形参?|修饰 造于 形参) 继承
继承 (：类型 调用 类型* )?
// 主造的参数=量，只负责赋值。造于是事，末尾调 `受初()`
// 物：可继承(by v)  事 f(a、b、：参颗粒化<1 1>)

量纲 (名=类型 …?)
约束 (访|名：类型+ 、) //<形变T>跟随物/事

修饰 可见? 可定? 的?
可见 公开|私下|族内|组内
可定 '!' | "[可未终]定"
:有 恒? $0 (类型 '.')? 词名 $1? (=言 | $2)? //成员
:为 为 :新缩进($0, ~.)
```

vararg `事 造行(：组参名<"abc" “皆”数>、：组参<T>)`，abc切分类似 `对何<KV>`

kwarg `组参名(dict、{:"k0" 1}、a作<组参>、k1=2)`

```rb
起点 ('#!' ~NL*) 书首 脚本* | 书首 词*
# 可以 use1 某例; use1 java lang util; 后 use1 util regex Date:Week

引 点名
引单 点名 (名(:名)?)*
书首 (书 点名)? (引|引单)*
脚本 词|(句 ；)
```

```js
俩量(.123)去锯齿(0“round”、2)的x 必.12 “Vec2是数”
Eqv.lets {pipe(txt("nums.json"), JSON<Ln<Int>>) } “链式计算-IO”
   .oncat("add1_"):it.lets{it inc}

类 CmdExec； 物事 安卓.作：CmdExec “组合式跨平台”
事 启动=os“需实现” 去sh('特定命令')

(0~5)令为，
  量t=它sec；待命，睡(t)；说("$t后")。
可重入，“被N个线程调用后,1次跑1个”。

恒事 “Eqv”pipe(:Args<Eqv<* *>>)：类型递归<args>
恒事 类型递归(串：组<类型>) = 串[0]的参[0] 令为，[A]
  串去叠(A)，[a b] b的参[0]有a；b的参[1]。令为，[B] 类型.参(可同、A、B)。

“ts类型体操版compose()。 函数体无法构造 管<> 类型(来形式证明)，故仅调用处受检 ”
事 pipe(:Args<函1<* *>>)：管<args> = args去叠，「次(首(它))」。
恒事 管(串：组<类型>) = 判串，
  {}，断止。{F}，F。
  {类型.参(略、A、B) 组参(X)}、判管(X)的参，
    {B b}，类型.参(函1、A、b)。

俩PairOf 俩量Vec2 俩项Pair 仨项Pairs3 可同Either

可以考虑让GPT生成类型<>集的示例
```

看起来很厉害，但实际就是把叠「」 组装的函值，在类型上模拟一下(TS的 `createElement("div")` 和C++模板亦如此)

恒事的符号宏，据组参<>等常量求[真子类型]reified subtype

