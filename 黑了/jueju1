“绝句的Logo 是“绝句鸟” ，幼圆字体，光滑句号 ”
书 绝句.核

“令/为变量域函数 alsoIt also letIt let”
对何<A>事 A.「令」(做事：函我<A>)：A 为
  我去做事；回“返”(我)
对何<A>事 A.「其令」(做事：函<A>)：A 为“令，做事(我)。”
  做事(我)；回“返”(我)

对何<AB>事 A.「令为」(换：函我<A、B>)：B =我去换
对何<AB>事 A.「其令为」(换：函<A、B>)：B =换“个”(我)

for<AB> fun A.let(op:Fn<A,B>):B
for<AB> fun A.run(op:FnOn<A,B>):B
for<A> fun A.also(do:Fn<A>):A
for<A> fun A.apply(do:FnOn<A>):A


对何<A>恒事 可变量<A>.「令置」(换：函<A、A>)：A 为
  值=换(值)；回值

对何<AB>储物 俩项(首：A、次：B)
对何<ABC>储物 仨项(首：A、次：B、末：C)

对何<A>类型别名 俩项皆=俩项<A、A>
对何<A>类型别名 仨项皆=仨项<A、A、A>

对何<AB>事 A.「到」(另：B)=俩项(我、另)

‘[俩项]首余数 次商’
事 数.余除(内项：数)：俩项<数、数>=内定

恒 变函<仨项<行<文>、行<值>、文>、值?> 语义单引号 初，[提取 a、b、后缀]
  回 若b为空，后缀。否则，(a带序号去拼合，"$首${b[次]}"。 +后缀)。 去除首尾空白
“初-于所有 造于 ；同名例”

类 编程语言 为
  事 编译(：文)：码
  事 运行(：码、路径：文、：系统环境)
  量 版本：文

可定的物 绝句：编程语言 为
  既量 版本 读，""。
  既事 编译(：文)=待写""
  事 受造=无操作
  同名例
    事 受调用=无操作

量 下载=“获取你的”绝句()
例 你自己的 绝句 为
  终定的量 版本=""
  “仍可再定的”事 初造=说("")
  “可定物(内可定事量)允许继承-再定，若有未定事量则只适于未定物或类。类可被多继承”

既可未终 impl impl? impl?? impl!
公私族组 same same-0 same-type same-pkg

类 语树 为
  事 显示：文
对何<T>(其中T 语树)
事 编程语言<T>.解释

其中 内文件级定义都可包含。「量」视为在函数体头部，「事」强制内联，其他加在物的私下但不允许他事引用

类例 可序 用户

fun f()=object: T{}
物事f()：T 为

以前绝句解构赋值是用 函<俩项>，[提 a、b] 和 量提(a、b)=pair 的 ，后来为合并 量提pair是俩项(a、b) 的恒事解构，系统性与「事是」语法同立了

a带序号去看，[是a b]a*b。  a去带(a的序号)去看，量它是俩项(a、b)；回a*b。 “量名=值 ；量名是(恒量 模式:含 可变量)”

一般做法是 “ab”归一(建行(1、2)、两个可变量) ，但这么做的本质其实是两次，对ab迭代同1个序号 生成赋值语句。

类例 语义解构 俩项<*、*> 为
  既定恒量 所有变量：行<可变量<*>> = 建行(首、次)
  既定事 左部预=我“不预处理”

绝句会自己处理可变量行的类型推导和「俩项(x、y)或某俩项是A」默认值。 可变量在绝句由 局部变/物上变 的单项/访问链组成。

它把建行() 的所有位置变为赋值语句，行的可变量=「量是」引入变量 ，主语从右变数据行，换个方向赋值

语义试提取或

语义被继承

变x初晚算，。 变：T 初晚置

类型别名 针=数4，它不<0。
类型别名 针长=针

量 数.「左」 取，我-1。 “getset取置。而 var by 改为 量/变=可变量() 、class:T by o 改为 继承自<T>(o)”
量 数.「右」 取，我+1。
例 略
物 断止 私下的造于() “公开 私下 族内 组内”

事 伪递归(不定长 ：值?)=内定
“不会有 Unit(已生效) 返回充作void”

对何<N>(其中N：有序) “既定 可定 终定 待定”
可定的物 域(始：N、末：N) 为

物 域步(步：N)：域<N> 为

事 数.「~」(末：数)=域(我、末)
事 数.「~右」(n：数)=域(我、我+n)
事 数.「止」(没末：数)=域(我、没末-1)
事 域<数>.「步距」(n：数)=令为，域步(始、末、n)。 “尾=末右”
量 域<数>.降着 取，步距(-1)。

类型别名 次数=数
改行(5次、0)

5次，[i]说("i*i=${i*i}")。

事 数.「~」(末：略)：域略=函，我~它。
事 行.取(：域<针>)=
事 行.取(：域略)=取(此域略(最右))
事 域<数>.随挑()：数
对何<项>事 行<项>.随选(n：数=长)：行<项>

类型别名 域略=函<针长、域>
域略.带序号于(：带长)

(0~长/2)去看，[是x i] 交换(i、I令置「左」)。

对何<我、N>(其中N：有序) “对何别名使用处“我”，N必然属有序类型 ”
类型别名 升行=行<N>

“行表组集合”

<恒T>组
组值

分块  分块内 二分

量 有长.最右 取，长-1。
对何<项>类 队：有长 为
  事 添(：项)；事 泡()：项

‘若真有大量计算需先创副本，可私下定 `建行()再去映为，。` 里 `量「再」`’ 看为
事 「复制」算符小 (：行)
可改，建行(1、2、3)。 令为，
  判k，
    "顺"，队()。"定"，定长队(20、0)。否则，栈()。

‘视频像宽高相同的图片行高速左移。电影院放映需把每(A=B=图)放大为同一个比例，对任何项操作即[映为]’
对何<A、B>事 行<A>.映为(换：函<A、B>)：行<B>

Python 里的 a[:3] 和 [3:] 相当于 a[0~3] a[3~略]

a[略~1] 很特殊——代表 a[a的最右-1~a的最右] ，即 a去排反[0~1]

a去取有(0)?去令，说(名字)。

绿牌是袋龟 (滤排试带归) 是绝句行列出产的一种持有绿牌牌的袋状乌龟，袋里装的是数据单项，祝大家都能手拿绿牌！

排反 排 排降 排二分(0~数略)：“真=0~”针 排以序(小先中稳)，。

滤出 滤映
滤之间('['到']'、假)
滤首尾(「是' '」、假)
滤首(「是1」、真)

带(a的序号) 带右项 带块(5) 带块填(0、5) 带右项首 切内行

归 归自 归自首(「+1」、「*」)

看滤序组归

看 看为 看为合 看文
滤出 滤映 滤不空 映不空 找(反)：可变量号
取前 取前无 取前累加，[a b]a的值=a+b；a不>50。 的计
序 序以 序二分 序反 序乱
带 带号 带其右 拆开 拆内行 带块 带块填
归 归右 归自首
集 组以 表以/到
取(-1) [0~略] 填满 填移 泡添(0~1) 添 泡
存皆 存有 存(1)  首以 尾以

a[0~i]+a[i右~略]  复a令，泡添(0)。

复建行(1)去看为「+1」
事 阶乘(n：数)=算(1~n)的积

建列(1到3、6到10)去带右项首(0到0)去映为，[提a b] (b的首-a的次)到(b的次-b的首)。去切内行，[提dt _]dt<50。

(0止3)去表，[i]i到"abc"[i]。

对何<A>
物 列：无穷列<A>
  事 排序以


类例 隐等同<文> 数

对何<T>(其中 T 隐等同<文>)
类例 隐等同<文> 阵<T>

类例 有空值 行<*> 为
  事 空值
例 空集 “隐等同..”

类例 有同名例<A> T 为
  量 有同名例：A “如最大值.. 放同名例上。 比类例好”

对何<我>
类 读写 为
  事 写：文
  同名例：读
对何<我>类 读 为
  事 读(：文)：我

对何<T 读写“=有同名例<读>”> 恒物 显 为
  事 写(a：行<T>)=a去文(",")，它去写。
  事 读(：文)=此文去切以(",")去看为，取同名例<T>去读(它)。

  “因为像读写-格式 有很多扩充可能，同名例的类 尽管靠类型即可取，不总能实现需要的功能，类例 自动转化 就可以用于不严谨的扩展”
阵<数> “行<行<T>>”
反(1或2) T
阵针 上下左右
待 同一 其一
当然，持久("f.t")，。  运行期序列化是语言们都支持的，强类型同名例只是给这类(代码生成)一个标准形式，让这些特性更明确

绝句有统一方法，在编译和运行期能取类型确定的同名例

class ReadShow t where
  show::t->Str
  read::Str->t

shows ::(ReadShow t)=> (List t)->Str 只是数据和操作 1:N 的不严谨绑定
前者把「类例」视作自动转换还可以实现，但后者就没有类型限制能做到，因为得先拿到t的值，若 类例 读作<T> 文 ，对何<>(其中) 上又不好限制了。
于是，无名的同名例 所继承的类，会被视作同名例所属物的类型约束。 类例就能保持其简单性（类似 Scala implicit class 只是隐转规则 查找和扩展事量一样），也顺带了 min,max,zero 值的统一“语法”与算式，且能以文本缩写些常量数据-与储物 的流读写配对

事 位旗.「有」(名词：针)
事 位旗.设(名词：针、值：真假)

量fA=文件("a.txt"、"w+")去要增 “rw 代表打开用以读写， + 代表若无则新建。要增() 将读写头 置于文件长”
fA去写("一行") “支持二进制，当然也能写文本”

标准IO的说 去转移()“freopen / setOutputStream”
标准IO的说 的后端“dup/dup2”

绝句的 建行(1到2到3)去看，[提a b] 量提(x、y)=b 。 是因为技术难度不支持 [提a [x y]@b] 吗？其实支持很简单，[a[xy]]的嵌套行，遇内层[xy] 生变量b 提([ab]、参[0])再 提([xy]、b) 就成，这不难

实际上，绝句支持基于可变量的 量提 此行“作行<俩项<数、俩项皆<数>>>”是 建行(a到(x到y)) ，其中未定变量自动声明。

“物理向量。可修改的[俩项]等请用储物或组(与强制算作)”
俩量 仨量 四量 ：分量同算

‘0=无， 1=ms内只执行1次 2=冲突则再拖延’
时间去防抖(200ms到0)，。
‘执行时不重入’
时间去防抖(待，定时(500ms)。)

事是

断续
不定长

【重复于 "a b c" "0~9" 建行()】量$0$1
其中[^2] 【以下 2】【晚置】 标物可调用恒事

建行(1)去看，
  建行(2)去看，回[^1]。


‘async 是近几年(在“处理流”函数管道外)取代回调的语言特性，它的前身是协程。 异步说到底是复用同一个线程完成多任务，那么其调用栈就不能“卡”在某函数，可以用(回调也可视为)“事件监听”的方法拼凑一件事的顺序

协程仅仅使函数可暂从调用栈撤下。CPS(传递程续-编程风格) 的意思是所有函数都不返回，而把结果交给回调。相当于更自由的返回地址、数据化调用栈。在Lisp里，若函数发生“异常”停止后甚至可复原！这很像 C setjmp/longjmp+变量域包

断续的事 _123：列<数> 为
  (1~1)去看，交(它)。
  交(2)；交(3)

事 _123() 为
  变数st 初0 ；变迭<数>=晚置
  判st令置「其右」，
    1，
      迭=(1~1)去化迭
      重复若迭不为空，交(迭去右)。
    2，交(2)。
    3，交(3)。

每个断续事都有返回地址，_123自己、交() 都知道算出值后交给外层，这类似是给 交() 回调，_123会立刻返回且可恢复。之后一切由 交() 负责调度(不断恢复尾部调用->整体事)，至求出最外层断续事

新JS的调度是基于 awaiter 将回交的Promise.then 回给休眠事-直到这个事resolve 调用上级then，而未在调用“断续函数”即确定尾步骤
’

“路径(DFS)和可达(BFS)，二者皆可搜索符合点与路径，后者以队搜更自由”

事 李白（酒 花 店：数）：真假 为
  若你(酒是1)或酒<0或花<0或店<0，回你。
  回搜组合(酒-1、花左、店、 酒*2、花、店左) “列<仨项皆<数>>”
  搜组合序("A"、酒-1、花左、店、 "B"、酒*2、花、店左)“列<俩项<文、仨项皆<数> >>”

事 汽水（ac n a：数）=判，
  a<3，回重复(ac右、n右、a-3)。
  否则，回ac。

“广度去搜；  搜序；搜优序”
“广度记去搜序；搜优序=搜轻序 Dij就是回溯表BFS+轻优先”
可序皆 “可用「数属性」”  命题“可用其值”

【DP缓存 "i=0~4 j=0~3升-1"】 自动逆序算
事fib(n a=1 b=1：数)=若n是0，a。否则，回重复(n左、b、a+b)。
事fib(n：数)：数=fib(n-1)+fib(n-2)
【DP缓存"2~n"】事fac(n：数)=若n是1，1。否则，fac(n-1)*n。
“绝句列 无法引用自身(缓存如2项待引用)，但对fib用递推就等于引用自身”

1:2:3 作链行<数>
储物 链行<>(项、余)

统计
排列 带号组合

行去乘 阶乘
算建行(1)去 组合(2)

点 色 点3 色3 向量(5)：分量同算
 矩 求均

“绝句的(1~n)区间和列比(伪)递归更适合阶乘，因此不接受自动转化返回值累加 作伪递归。”

迭<T>=函0<T?>
对何<读T>类 空迭 为
  量「有右」
  事 右

类 集合 为
  事 看
  事 看删：真假

列靠“受调用”生成，每行1,2,3.. 的分块用迭<T> 写是 while True: i+=1;for i in range(i): nextN(i,xs) ，而用列写是 i整除n; 交(行去清空)；n++


书 点名
引 点名
引单 点名 (点名|记法名 ".*"|作名 )

以首项为前缀的带"." 物/书 的“复合名”内全部项，或者起个别名/禁用

引单 绝句「令」作无

试，。作 可为<值、错> 去并()

抛下 作断止
