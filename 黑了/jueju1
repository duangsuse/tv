“绝句的Logo 是“绝句鸟” ，幼圆字体，光滑句号 ”
书 绝句.核

“令/为变量域函数 alsoIt also letIt let”
对何<A>事 A.「令」(做事：函我<A>)：A 为
  我去做事；回“返”(我)
对何<A>事 A.「其令」(做事：函<A>)：A 为“令，做事(我)。”
  做事(我)；回“返”(我)

对何<AB>事 A.「令为」(换：函我<A、B>)：B =我去换
对何<AB>事 A.「其令为」(换：函<A、B>)：B =换“个”(我)

for<AB> fun A.let(op:Fn<A,B>):B
for<AB> fun A.run(op:FnOn<A,B>):B
for<A> fun A.also(do:Fn<A>):A
for<A> fun A.apply(do:FnOn<A>):A

let,lets; itLet,itLets

定义域函数

1. 能对应JVM的 checkcast 指令、C++ 的 reinterpret_cast 多转型
2. 能体现绝句类型检查器的恒API、T T? 处理的差异； obj去作否<T>?令，xx+1。空则1
3. 「属/存于」在语法的引用远比“作”强转要多。 Kotlin 上 (obj as T).xx, 1+1 as Int 语法必须括住，同C系((T)obj)未显算符优先级，而 obj去作<T> 的xx  很明确

(文)作同名例<文、值>

Kotlin 的引用 T::class.java 语法，如果想拿到同名例，可以直接加 ：同名例<A、T> 、 T：有同名例<> 限制

绝句默认内联 lazyInit 实现。懒盒才相当于 Lazy<T>::value

对何<A>恒事 可变量<A>.「令写」(换：函<A、A>)：A 为
  值=换(值)；回值

试「不是""」，a+它。
“九宫格 +1列 1行0-删除 输入+-盘”

恒物 值域<N>：集<N>

我、数值、数|浮
事 数.「~」(取至：数)=值域(我、取至)

((1~2)+(3~4) )去看


对何<我>物 数值：可序、数同宽化 为
  事「+-*/%」(另：我)；事 取负
  事 比大小(右：我)
  同名例：数常量
事「-」(：数值)=
类 数常量 为
  “极大小,0,1 乘法零点；十进值小；全01”

对何<我>
物 数项：数值
  事 余除：俩<我>
  量 bit：位运算
对何<>  【宽 8 -128 127】数1248 数=数4 针 计 “物同名例上的极大值等信息是由此填充的！”
物 浮项：数值
  事 整(-2~1)
对何<> 浮48 浮=浮8


CPU内部使用一串宽度固定的2进制表示数和浮点小数，无论数多大或多小所占位置是固定的。可为负的数 值域/2 如 (unsigned byte)-256~255 到 (byte)-128~127
如上例，Java,C,SQL 等编程语言使用 byte short int 等特殊“类型名”指代宽度不同的数值、整数或浮点数，是为 (1)生成带类型的算术指令 (2)确定能否隐式转化

但是，任何数值支持的算符都是相同的(C++ template 的功能之一)。绝句用含加减比较事的『数值』、【宽 "I" 32】数4 和『隐等同』 实现隐式宽化，并为代码生成标记了类型名。绝句仅大致区分数浮，却不像“脚本语言”那样完全无视宽度
在 对何<> 里含 数值|数|浮 代表接受任意『数项』 数4,数8,. 实际值-为之生成新重载或extfun，否则仅 Java 的常用宽度 数int,浮double 。对何<我> 也是一样的，这些特殊类型变量，都必在编译期确定为(值,数浮项的)子类！

绝句只需为对何<数值>的算式生成重载，储物等处的 Number 是兼容不同宽度的

Char 仅有 '2'-'0' 的+-操作，在 Java 它和 '\uFFFF' short 同宽。 1L, 1F, 1. 和 .9 分别宽8,(浮点)4,8,8 ；此外 1N, 1.0N (数N|浮N) 宽度不限。

其意义是， 对何<数>事 比例(n：数)=n/数的极大 对所有数宽/正负都有效，这不规范但不浪费。
顺带，事 pmix[abt]=t*b+(1.0-t)*a 里abt 3参是 对何<数值> 空=数值 默认的，别名可以包含约束。

算式以『数值』类型并不是绝句的首创。实际上，著名的函数式编程语言 Haskell 里就是(:: 是绝句里：的意思, :被链表占了)  (+) :: (Num n) => n->(n-> n) ，(1+)2==3 , max ::Int
(+) 在两参有 instance (Num Int) ，即(Num n) 的实现时可用，这就是绝句的「类例」 (隐式接口)，但绝句不会允许 max ::(Num n)=>n 这样松散的“仅全局”多态也不支持随处类型推导。 类例是面向对象(+1主语)的，而 max 这种常量以(数的极大) 同名例的量去访问
绝句在『数值』的类型特性，本质上和 Haskell 多态没有区别，只是比 Scala,Rust 更易懂的融合了原生 Java ，而且没有滥用这种松散的 class-instance （绝句连术语和 Hs 都碰巧一致） 而将 对何<我、数值> 作为“语法糖”增加OOP的扩展性、减少“基元”

对何<AB>储物 俩项(首：A、次：B)
对何<ABC>储物 仨项(首：A、次：B、末：C)

对何<A>类型别名 俩项皆=俩项<A、A>
对何<A>类型别名 仨项皆=仨项<A、A、A>

对何<AB>事 A.「到」(另：B)=俩项(我、另)

‘[俩项]首余数 次商’
事 数.余除(内项：数)：俩项<数、数>=内定

恒 变函<仨项<行<文>、行<值>、文>、值?> 语义单引号 初，[提取 a、b、后缀]
  回 若b为空，后缀。否则，(a带序号去拼合，"$首${b[次]}"。 +后缀)。 去除首尾空白
“初-于所有 造于 ；同名例”

类 编程语言 为
  事 编译(：文)：码
  事 运行(：码、路径：文、：系统环境)
  量 版本：文

可定的物 绝句：编程语言 为
  既量 版本 读，""。
  既事 编译(：文)=待写""
  事 受造=无操作
  同名例
    事 受调用=无操作

量 下载=“获取你的”绝句()
例 你自己的 绝句 为
  终定的量 版本=""
  “仍可再定的”事 初造=说("")
  “可定物(内可定事量)允许继承-再定，若有未定事量则只适于未定物或类。类可被多继承”

既可未终 impl impl? impl?? impl!
公私族组 same same-0 same-type same-pkg

类 语树 为
  事 显示：文
对何<T>(其中T 语树)
事 编程语言<T>.解释

判a属，
判a是，
  建行(x、y、z)，x+y-z。
  建行(x、y)，x+y。

类例 可序 用户

fun f()=object: T{}
物事f()：T 为

其中 内文件级定义都可包含。不独立作用域：「量」视为在函数体头部，「事」「物事」强制内联。其他加在物的私下但不允许他事引用

【重复于 "a b c" "0~9" 建行()】量$0$1
其中[^2] 【以下 2】【晚置】 标物可调用恒事

以前绝句解构赋值是用 函<俩项>，[提 a、b] 和 量提(a、b)=pair 的 ，后来为合并 量提pair是俩项(a、b) 的恒事解构，系统性与「事是」语法同立了

a带序号去看，[是a b]a*b。  a去带(a的序号)去看，量它是俩项(a、b)；回a*b。 “量名=值 ；量名是(恒量 模式:含 可变量)”

一般做法是 “ab”归一(建行(1、2)、两个可变量) ，但这么做的本质其实是两次，对ab迭代同1个序号 生成赋值语句。

类例 语义解构 俩项<*、*> 为
  既定恒量 所有变量：行<可变量<*>> = 建行(首、次)
  既定事 左部预=我“不预处理”

绝句会自己处理可变量行的类型推导和「俩项(x、y)或某俩项是A」默认值。 可变量在绝句由 局部变/物上变 的单项/访问链组成。

它把建行() 的所有位置变为赋值语句，行的可变量=「量是」引入变量 ，主语从右变数据行，换个方向赋值

语义试提取或

语义被继承

变x初晚算，。 变：T 初晚置

类型别名 针=数4，它不<0。
类型别名 针长=针

量 数.「左」 取，我-1。 “getset取置。而 var by 改为 量/变=可变量() 、class:T by o 改为 继承自<T>(o)”
量 数.「右」 取，我+1。
例 略
物 断止 私下的造于() “公开 私下 族内 组内”

事 伪递归(不定长 ：值?)=内定
“不会有 Unit(已生效) 返回充作void”

对何<N>(其中N：有序) “既定 可定 终定 待定”
可定的物 域(始：N、末：N) 为

物 域步(步：N)：域<N> 为

事 数.「~」(末：数)=域(我、末)
事 数.「~右」(n：数)=域(我、我+n)
事 数.「止」(没末：数)=域(我、没末-1)
事 域<数>.「步距」(n：数)=令为，域步(始、末、n)。 “重复若不是(尾=末右)”
量 域<数>.降着 取，步距(-1)。

类型别名 次数=数
改行(5次、0)

5次，[i]说("i*i=${i*i}")。

事 数.「~」(末：略)：域略=函，我~它。
事 行.取(：域<针>)=
事 行.取(：域略)=取(此域略(最右))
事 域<数>.随挑()：数
对何<项>事 行<项>.随选(n：数=长)：行<项>

类型别名 域略=函<针长、域>
域略.带序号于(：带长)

(0~长/2)去看，[是x i] 交换(i、I令置「左」)。

对何<我、N>(其中N：有序) “对何别名使用处“我”，N必然属有序类型 ”
类型别名 升行=行<N>

“行表组集合”

<恒T>组
组值

分块  分块内 二分

量 有长.最右 取，长-1。
对何<项>类 队：有长 为
  事 添(：项)；事 泡()：项

对何<项>类 双队：有长
  事 添(：项)；事 泡()：项
  事 添左(：项)；事 泡右()：项

‘若真有大量计算需先创副本，可私下定 `建行()再去映为，。` 里 `量「再」`’ 看为
事 「复制」算符小 (：行)
可改，建行(1、2、3)。 令为，
  判k，
    "顺"，队()。"定"，定长队(20、0)。否则，栈()。

‘视频像宽高相同的图片行高速左移。电影院放映需把每(A=B=图)放大为同一个比例，对任何项操作即[映为]’
对何<A、B>事 行<A>.映为(换：函<A、B>)：行<B>

Python 里的 a[:3] 和 [3:] 相当于 a[0~3] a[3~略]

a[略~1] 很特殊——代表 a[a的最右-1~a的最右] ，即 a去排反[0~1]

a去取有(0)?去令，说(名字)。

绿牌是袋龟 (滤排试带归) 是绝句行列出产的一种持有绿牌牌的袋状乌龟，袋里装的是数据单项，祝大家都能手拿绿牌！

排反 排 排降 排二分(0~数略)：“真=0~”针 排以序(小先中稳)，。

滤出 滤映
滤之间('['到']'、假)
滤首尾(「是' '」、假)
滤首(「是1」、真)

带(a的序号) 带右项 带块(5) 带块填(0、5) 带右项首 切内行

归 归自 归自首(「+1」、「*」)

看滤序组归

看 反看 看为 看为合 看文
滤出 滤映 滤不空 映不空 找(反)：可变量号
取前 取前无 取前累加，[a b]a的值=a+b；a不>50。 的计  (1~略)取前累加，[n] 值=值+3乘次n；回值<7。的末“值已不<7”
序 序以 序二分 序反 序乱
带 带号 带其右 拆开 拆内行 带块 带块填
归 归右 归自首
集 组以 表以/到
取(-1) [0~略] 填满 填移 泡添(0~1) 添 泡
存皆 存有 存(1)  首以 尾以

a[0~i]+a[i右~略]  复a令，泡添(0)。

复建行(1)去看为「+1」
事 阶乘(n：数)=算(1~n)的积

建列(1到3、6到10)去带右项首(0到0)去映为，[提a b] (b的首-a的次)到(b的次-b的首)。去切内行，[提dt _]dt<50。

(0止3)去表，[i]i到"abc"[i]。


绝句『改行』等可变性只存在于类型上。 (同类型的)看为 滤出 序 「+」 会在原集合即地操作(removeIf 这些就不必了)！ 复 建改行(1)去看为「+1」 先复制可避免修改，而对 建行(1)去看..“作改行<>”去看.. ，绝句只复制1次 左部不是【即地】事 的合<T>值。【即地或复制】物 改行：行 会生成『看为』等的复制版本

【即地】的事 看为(：函新<T>)
函0 函1<R> 函2<我、空> 函我1<AR>

有：

对何<> T1=T，它+1是2。 “T1 是『量纲类型』，T的新子类”
对何<N>(其中 N：可序) 俩序=俩<N> “俩序<没有参数> 是「带默认约束」的『类型别名』，比每事加 对何<> 方便”
“删掉。 对何<N>(其中N：可序) 物 是可以的”
对计算机来说，总在区分集合“不可变”能拉低性能。 只有“只读”的特质使内存能复用才算优化；从签名/类成员上区分 Mutable 与否，对性能无害无利，却使继承结构不合地的复杂；与其说成员上 改行：行 ，说约束上 行：改行 也是一种体现

对何<A>(其中 A：行<可序>)
例 排序 为
  事 A.冒泡 =待写

引单 排序

物 组：列

对何<T>类 合：有长、列<T> 为
  事 试存在(：T)：真假
  事 试存在(：合<T>)：真假
  事 算摘要：数；事 试等(另：值)：真假
对何<T>类 改合：合<T> 为
  事 添(：T)；事 泡(：T)
  事 添(：合<T>)；事 泡(：合<T>)
  事 清空

对何<读T>类 集：合<T>
对何<T>类 改集：集<T>、改合<T> “集=改集<读T> 「真」”

物 行：合

对何<写K读V>物 表：合<K>
  泡取(：K)
对何<KV>物 改表：表<K>、改合<写K>
  恒事 合(：函创<V>)：改合<K>

对何<T> 非空合=合<T>「不空」
对何<N>(其中N：可序) 序行=改行<N>

类 有长 为
  量 长：计；量 最右 读，长-1。
  量 针：值域<针>
  量「为空」 读，长是0。


对何<A>
物 列：无穷列<A>
  事 组 行 表 集 文
  事 迭子；事 并行
  事 排序以

“”

这会把所有红块移到左部，以下p=「项是红色」

“若遇非p ，一个从非p右侧找，一个从最右找p。 ”

变针，iA初0；i初1。
重复若i<长，
  若非p(我[iA])，
    重复若非p(我[i])，i=i右。“找到红i” 置换(iA、i)
  否则，iA=iA右；i=i右。
回iA

重复， “p(0止a) 且 非p(b右~最右)”
  重复若a不是b 且p(我[a])，a=a右。
  重复若a不是b 且非p(我[b])，b=b左。
  若a右是b，停下。 “b~最右 现全是非p”
  否则，置换(a、b)。
若真。
回b

类例 隐等同<文> 数

对何<T>(其中 T 隐等同<文>)
类例 隐等同<文> 阵<T>

类例 有空值 行<*> 为
  事 空值
例 空集 “隐等同..”

类例 有同名例<A> T 为
  量 有同名例：A “如最大值.. 放同名例上。 比类例好”

对何<我>
类 读写 为
  事 写：文
  同名例：读
对何<我>类 读 为
  事 读(：文)：我

对何<T 读写“=有同名例<读>”> 恒物 显 为
  事 写(a：行<T>)=a去文(",")，它去写。
  事 读(：文)=此文去切以(",")去看为，取同名例<T>去读(它)。

  “因为像读写-格式 有很多扩充可能，同名例的类 尽管靠类型即可取，不总能实现需要的功能，类例 自动转化 就可以用于不严谨的扩展”
阵<数> “行<行<T>>”
反(1或2) T
阵针 上下左右
待 同一(拆拼)编-反编/序列化dumpLoad 其一
当然，持久("f.t")，。  运行期序列化是语言们都支持的，强类型同名例只是给这类(代码生成)一个标准形式，让这些特性更明确

绝句有统一方法，在编译和运行期能取类型确定的同名例

class ReadShow t where
  show::t->Str
  read::Str->t

shows ::(ReadShow t)=> (List t)->Str 只是数据和操作 1:N 的不严谨绑定
前者把「类例」视作自动转换还可以实现，但后者就没有类型限制能做到，因为得先拿到t的值，若 类例 读作<T> 文 ，对何<>(其中) 上又不好限制了。
于是，无名的同名例 所继承的类，会被视作同名例所属物的类型约束。 类例就能保持其简单性（类似 Scala implicit class 只是隐转规则 查找和扩展事量一样），也顺带了 min,max,zero 值的统一“语法”与算式，且能以文本缩写些常量数据-与储物 的流读写配对

事 位旗.「有」(名词：针)
事 位旗.设(名词：针、值：真假)

量fA=文件("a.txt"、"w+")去要增 “rw 代表打开用以读写， + 代表若无则新建。要增() 将读写头 置于文件长”
fA去写("一行") “支持二进制，当然也能写文本”

标准IO的说 去转移()“freopen / setOutputStream”
标准IO的说 的后端“dup/dup2”

绝句的 建行(1到2到3)去看，[提a b] 量提(x、y)=b 。 是因为技术难度不支持 [提a [x y]@b] 吗？其实支持很简单，[a[xy]]的嵌套行，遇内层[xy] 生变量b 提([ab]、参[0])再 提([xy]、b) 就成，这不难

实际上，绝句支持基于可变量的 量提 此行“作行<俩项<数、俩项皆<数>>>”是 建行(a到(x到y)) ，其中未定变量自动声明。

“物理向量。可修改的[俩项]等请用储物或组(与强制算作)”
俩量 仨量 四量 ：分量同算
p份的xyz

2,3D运动追踪 obj分割 素材库
2副本左右旋转 、滑动 , 亮度擦拭
旗帜,多描边,缩放重复
3角网格、svg变换

时钟盘：4向/360度 画布变 /对称黏合

常动画/渐变

两个img元素，设定其显示起止t0~t1 ，就在同一个时间轴上。 把右侧项拽与左侧重叠，重叠部分会播放相同动画 除非属于半透合成
时轴可以录制，像放PPT一样 重新规划选几项换页时机，动画可以像 t0+1s,t1-.25*dur 设定关键帧位置，例如滑缩，可以显示动画曲线，点选调整左部补间；剪辑功能当然不缺
有声音和滤镜、特效、渐变 可用，收藏自己常用的集合。 也可以查看(共用)素材箱和混音器
可以用数阵生成棋盘动效 元素的组、队列动画、字幕-通轨动画；脚本参数动画 。片段头尾和两项间也可以有默认动画，像-1遍半透淡入 (交集于尾帧?) , i>?j+ 扫描线


‘0=无， 1=ms内只执行1次 2=冲突则再拖延’
时间去防抖(200ms到0)，。
‘执行时不重入’
时间去防抖(待，定时(500ms)。)

事是

断续
不定长

建行(1)去看，
  建行(2)去看，回[^1]。


‘async 是近几年(在“处理流”函数管道外)取代回调的语言特性，它的前身是协程。 异步说到底是复用同一个线程完成多任务，那么其调用栈就不能“卡”在某函数，可以用(回调也可视为)“事件监听”的方法拼凑一件事的顺序

协程仅仅使函数可暂从调用栈撤下。CPS(传递程续-编程风格) 的意思是所有函数都不返回，而把结果交给回调。相当于更自由的返回地址、数据化调用栈。在Lisp里，若函数发生“异常”停止后甚至可复原！这很像 C setjmp/longjmp+变量域包

断续的事 _123：列<数> 为
  (1~1)去看，交(它)。
  交(2)；交(3)

事 _123() 为
  变数st 初0 ；变迭<数>=晚置
  判st令置「其右」，
    1，
      迭=(1~1)去化迭
      重复若迭不为空，交(迭去右)。
    2，交(2)。
    3，交(3)。

每个断续事都有返回地址，_123自己、交() 都知道算出值后交给外层，这类似是给 交() 回调，_123会立刻返回且可恢复。之后一切由 交() 负责调度(不断恢复尾部调用->整体事)，至求出最外层断续事

新JS的调度是基于 awaiter 将回交的Promise.then 回给休眠事-直到这个事resolve 调用上级then，而未在调用“断续函数”即确定尾步骤
’

“路径(DFS)和可达(BFS)，二者皆可搜索符合点与路径，后者以队搜更自由”

事 李白（酒 花 店：数）：真假 为
  若你(酒是1)或酒<0或花<0或店<0，回你。
  回搜组合(酒-1、花左、店、 酒*2、花、店左) “列<仨项皆<数>>”
  搜组合序("A"、酒-1、花左、店、 "B"、酒*2、花、店左)“列<俩项<文、仨项皆<数> >>”

事 汽水（ac n a：数）=判，
  a<3，回重复(ac右、n右、a-3)。
  否则，回ac。

“广度去搜；  搜序；搜优序”
“广度记去搜序；搜优序=搜轻序 Dij就是回溯表BFS+轻优先”
可序皆 “可用「数属性」”  命题“可用其值”

【DP缓存 "i=0~4 j=0~3升-1"】 自动逆序算
事fib(n a=1 b=1：数)=若n是0，a。否则，回重复(n左、b、a+b)。
事fib(n：数)：数=fib(n-1)+fib(n-2)
【DP缓存"2~n"】事fac(n：数)=若n是1，1。否则，fac(n-1)*n。
“绝句列 无法引用自身(缓存如2项待引用)，但对fib用递推就等于引用自身”

1:2:3 作链行<数>
储物 链行<>(项、余)

阵去填首(2、「1」)，左[1]*i。
阵去填首(0到2、「1」)，左[1]+左[2]。 (1、20) [0][10]
行去填首(建行(1、1))，
  “改，此行+建行(1)。”此行[1~略]带号去看写，[是x i]上行[i-1]+x。 此行去添(1)

列去乘(1~2、1~2)去滤出，[是a b]a<b。

统计
排列 带号组合

行去乘 阶乘
算建行(1)去 组合(2)

点 色 点3 色3 向量(5)：分量同算
 矩 求均

“绝句的(1~n)区间和列比(伪)递归更适合阶乘，因此不接受自动转化返回值累加 作伪递归。”

迭<T>=函0<T?>
对何<读T>类 空迭 为
  量「有右」
  事 右

类 集合 为
  事 看
  事 看删：真假

列靠“受调用”生成，每行1,2,3.. 的分块用迭<T> 写是 while True: i+=1;for i in range(i): nextN(i,xs) ，而用列写是 i整除n; 交(行去清空)；n++


书 点名
引 点名
引单 点名 (点名|记法名 ".*"|作名 )
引单 点名

以首项为前缀的带"." 物/书 的“复合名”内全部项，或者起个别名/禁用

引单 绝句「令」作无

试，。作 可为<值、错> 去并()

抛下 作断止
