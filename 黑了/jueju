语言。直直的，不拐弯
数据。简单的，无特例
框架。可见的，不模糊
原理。尘封的，更未来
数据等效，程据对仗

物储例况标 内未定
句若判对回 重复停
行集合映滤 排组归
名数浮字文 真假空
言记大小是 不属存
语名言句段 词构书
象我亲若你 函式它
储组行表列 事内量

公开私下族内组内
既定未定可定终定
初造于 同名例
取置代者 事是=
内联 断续 恒 不定长 【内置】【重复于 "a b c" "0~9" [1 2 3]】量$0$1
对何皆有其中[^2] 【以下 2】【晚置】 可调用恒事和标物
inline fun 内 return 外部

事 T.fn() = 我[^1]去找(我[^0]) “与函我变形”
晚设变T ”函数式和小定义及序<T>默认内联，行为可在文件级修改“

刚刚也想了 suspend fun 实现的问题，现在是有状态机化和 call=inline-tail 两种方法可选

A: 我觉得在平直块里 yield() 类<3次就内联，否则状态机化。 列<> filter takeWhile forEach 这样 API只内联，用户可指定调用是否内联？
B: 啥叫平直？块都是嵌套的， if(q) a; else b; 的a 里yield 也是在语句块里，然而CPS 的话 If 后的代码也要复制一份，有 while 变 ifgoto 完也麻烦
A: 那就只允许fun{} 内<3的内联，这样翻译起来也简单。把 val a=1+f1()+2 改成 var a=1; f{a=a+it+2} 就行了(状态机化的pass)，然后末尾先收集，切分代码交给直到第[0]suspend
B: 就是 Haskell 的 do <- 那种咯，那状态机化呢
A: 闭包序列化基础上加 st:Int ，表达式切分后，入口=0 ，休眠一次+1 ，函数头部加 switch 跳转表，直到最后一块真 return
B: Promise.all 其实(半)已经能做了，主要还是没做过，解释器模式上不知有啥该改

相同API不同实现(如MySQL,PostgreSQL)怎么选择？Java 采用 -api,-impl 分包，运行时靠 Factory 拿已选平台的实例。
但绝句里这种融合非常常见，若分包会有大量重复「未定/既定」配对函数签名。绝句使用 `【以下 2】【平台标记】标物 Win；标物 Mac` 定义平台，标记于语句或成员上代表其后代码平台专属，在编译期剔除【平台使用"Win"】外的代码，类似 Rust 的 Cfg
但有些应用在运行时选择实现——兼容MySQL和其他SQL的服务app不少见。【平台运行时选择 "" ""】会给所有物加上SQL,Pg等前缀，而抽离出未定类。它标记之物伴生例则通过0参构造器提供 ["MySQL"] 操作，允许见机创建。利用 连接(用户名到密码) 等共同API和「若属于」来配置最终物。//有运行时选择标记的包在带 "-all" 后缀包名时，才自动执行接口实现切分，因此用户只要给跨平台包加-all 就能运行时选择支持。


<T>存储(变值)：代者<T>(值)extern表明声明仅仅是声明，而非定义。在程序中一定有一个地方存在一个非extern的对应的声明

量 有增 代者 值最新，x+1。
=值最新(x)，它+1。

值最新，说(滑条的值 作存储<数>)。

造于 初 同名例 取者 置者 代者
事为 事是 事= (其中 事=事=.. ) 可选/特称/隐式/不定长 参数
对何<真T>(其中) 类型别名，
性质推导，

恒事 符号执行，如a+1+2 ，已知量会被化简、未知参数则保留
类型<> 可以看作编译期的调用，创建出对象用于子集检查；恒事可以对标 Rust宏，也可以做循环展开等(视图树简写..)优化
恒 外 回重写 参组<数>
https://github.com/JetBrains/kotlin/blob/1b49105c78c566ec42b422cbd46782b47a0d9f40/libraries/stdlib/jvm/runtime/kotlin/jvm/JvmClassMapping.kt#L100
恒=内联+常量折叠 、外=Kotlin external(native)+expect

初，。init{} 可作为fun定义，infix 可让单参函数自带？但要 1.to 2 和 1 to 2 都可用，显然是支持 (f x) 并列即调用了吧

加=(a=>b=>a+b), 加(1)==(b=>.. ) 不易变的东西在前。就像洗盘子，会把抹布放在前面
事和值没有绝对的等价关系，局部函数 事(a)=事(b)=.. 只能在「其中」块出现，函<真假、数> 和 函自<数、真假> 最长16参

函数原义为盒子里的数，绝句解释为涵盖了几个变量的值，从算式得出或从计算流程指定
在C,VB等语言函数一般指子程序，只能含数目固定全局变量，没有闭包(匿名类型的对象:函数值)

对何<我>类 可序 为
  事 比大小(：我)：序
取伴生例(o作数4)“伴生例的类别在子物也可用”
“对何<T>(其中T：无型) 取伴生例<T>()作无型”

o作值 作行<值任>  “相当于或 util.List 即List<?>” 去皆，它作数。和List<*>一样是安全的

量a=晚置<路由器>()
量b=懒，算出。
回重()
1令做，[此]
  "a"令做，说(它[^此])。
尝试，抛下 错("")。接迎可为<错打开、错>，说(它)。皆有，下一项()。
变数a初1；a令置为「+1」

管道(文件("a.txt")顺便，夹/"a"；名；换前后缀(0)。)给(我：去滤) 至原地
听去行 再(面板：去处理)再(：去说)

组是长固定的行、列替代迭的API
对a带编号里的量(x、i)“俩项”
量我是 建行(a、b)；回a+b
判a量，
  建行(1、a、b)，“去提取(1 &a&b)是真”
"${变量}$文 本"
映为 滤出 排序(序=大先) 组合每两项/分块/分块补满 归纳  串联/交替/组合

纳文()顺便，"a b c"切以' '去皆(它：去加)。的值
纳俩项，它+它1。的循环 去值

"a b c"去收纳("")，"$它$它1"。

记法可用 「到」大中小右 形式指定优先级；如果不是系统性设计表达勿用！(绝句std未使用特性)
「x」式小级与 「*」同级、中「作」同级、大「=」同级；因且或「是」逻辑没啥可修饰
「x~」式小、中同「非」，大包括整个表达式
「~x」式小、中同「!!」(先于x~)，大同上

(删掉 用户的名字 嘛) 即「删掉~」小 而「~嘛」中，默认~x比 x~ 先算(小/中)。
量「」 和「文?」「取!」 都是不错的hack
>实现上，言单=名/(言前 括号/言单 言后) 形式先算符在先，x~大直接读右言， ~x 请顶层插自己名再读下+- ；前后级可比:小小大大

若试用户们 存一，它的名字是""。， “，。内部逗句默认警告”
Mandel,Berlin,圆环3D,Snake
存皆  存仅一
不始以"^"  末以"$"
事 试<文> 始以(：文)：真假
1令为其，到2。作俩<数>

书|引 书名；引单 书名 (名|记法名 (作 名?)?)+ “仅有一项时导入例/例物 的所有量”
单引号是 字 或跨行文本，前置缩进自动删除；否则默认禁止：文拼(首项)+文拼，次项[i]+末项[i]。

【类实例】的物 公司 法律 为
  量 法人 取者，董事长。
物 加(：流)：代者<流>(此流)、加法 为 “代理可继承自对象o，实用于不想重创建o”
  既定事 处理(i：数)=增(i)

书 绝句.基元
例 效果；物 断止 私下的造于()
类 异常；物 错：异常
类 开区间 为
  始；末
  扩(方位、计)
例 数略“半区间 a[0~数略]是a”
对何<我>类 数值：可序 为
  外部的事 负加减乘；除(内数) “自动 1+1L提升 1+1.0报错”
  事「~」(末)=开区间(我、末)
  事「止」(末止)
  「步长」「降步长」
  同名例 为 最大最小 值0 字节数 同字节
类 整数：数值 为
  除余()：计余
  量 宽窄 为
    _0~_8
  伴生例：数宽窄“类别0=Cnt,Int,Rat  长度0~8”
类型别名 数=数4
类型别名 计=数4「不小0」
类 浮：数值

类 有序
类 广列
类 列：广列
【弃用】类 可迭
类 有长：可迭“有长仅迭”
类 有长有位：有长

类 分量同算

’角长‘物 向量：分量同算(2)

抽象物 动集：有长
物 集：动集<出T> “out 兼容收子类项 的集合”

储物(o:T)：代者<T>(o)
变，数a b c；浮p。
量a=建行(1)可变
量b=建组(2)作组<出数> “组是长固定的行，默认可变，否则类似固定行”

类型别名 数=可为<数1、>


组内的类型别名 正数=数，它>0。
类型别名 针=计=正数

书 绝句

令置?为其?；顺便..
量不可能：断止
可定的物 位旗(不定长 码位)
  加删有
说
函数我
表(1到2)

书 .译
标物 英

言句段 词构书

词法是 “” ‘’

『名』是绝句值中最常用且很难替代的部分，直接表达在代码文本、存储在编译输出里，只有它们是不需计算即得到的(@数组
一些是对生活概念内的固定指代如 `1 10 '字' "文本"`"字面常量"，另一些是对程序运行时某位置值的指代如 `首项 前缀 PI`"变量"

建行("动苏"、123.0、真、假、空作 数?)作行<值?> “按位置包含了『名』”

变量不只是独一的符号，它与位置关联。

单独的『名』没有意义，只有它与位置、其他值关联时才能实现程序目标，所以绝句的语法构造从『言』开始算

为啥 1,2 这些数值也能算『名』？这要问为啥 1+1=2 ——没有为啥，因为 2=0+1+1 ，从0加上两个1的数，称之为2 。数值只是计算内支持的项、变量只是可以不固定的量，叫啥并不重要

`入口=说(招呼("小王"))` 调用栈

事(x)是 函1<数>，x。“涵盖1变量 得<数>”

很大部分值都是代码内以字面形式提供的，只有小部分 `听去文()` 或 `文件("a.txt")` 是用户提供的

固定的值越少，程序可扩展性越强；但过度抽象也会带来理解难度，且不实用。编程应据使用范例，合理规划可调整的参数量

内存地址空间上，我们把独占的内存称为「对象」，通用空间称为「值」。值不可修改，往往没有专属的空间。绝句推崇低变量、高组合逻辑编程。


函数是代码复用、可配置性的好帮手，绝句里函数(含动词)除了能作为语言结构，也可以当对象用；事实上有 用()：返 一词的对象就是函数了！

绝句除了完整支持面向对象那一套，也可以用函数式(少起名字多用事=)的方法编程且不影响性能。

事的定义可有 事为 事= (可嵌套) ，或在大量定义相似的事时利用 `事 加2是再增，它+1。` 包装，类似Py的 `@decorator`

事 再增(f：函管<数>)= 事(：数)=f(它)+1

在不想给单动词「物」起名时， `变函<数、文> 显=函，"$它"。` 可以取代 例..事 显(：数)：文 的功能



对何<我> 类 可序 为
  事 「小于」(：我)：真假

事 大于(a：可序、b：可序)=a不是b且(a去不小于(b))
对和<N>(其中 N：可序<N>)(a：可序<N>、b：可序<N>)“我(Self) 泛型简写”

(：绝句.说)作函<文、效果> 、建集(1)：去加 作<数、效果>、「试(1)小于」


事 此为值 此设值 在同时存在时变量 = 就相当于通过这两函数；这样的物有 存储 代者 懒 值最新 【值收集】UI对象
等效<B、A> 自 至

含前缀 含后缀 切分以/ 以起始/结尾/切分
恒量构建=研墨，依赖("")。

绝句提倡把构建规则和main()写在一起，请不要把与社区大体重复的代码独立一个文件。 src/  test/ 的独立已经够了，如果你的仓库包含大量的代码外内容，把源码放在 /jueju/ 下就行


「提取」在 对里的提取、函，【提取x、i】、量提取a、b= 都是不可嵌套的！但用 提取建行(a、b到c)=建行(1、2到3) 这样可以

若你 和 令为 顺便 scope fun 是对标Rust if let 类的东西
有Kotlin 多主语的特性，有 物 A 事 B.啥()：数=我+我[^A] 后B上可用 函我<A、数> 的写法

言 ，绝句.基元 定义的算符(记法)  言前 言后
作型 空则 言句

句 ；段=多句

词 是动词名词，即操作和参考值

构 是物、类、类型别名及书级词

书 是带点名与引用表
引 点名
引单 点名(名作 (名))* --若无项，引入末名 例物/例/伴生例 的内容
【自由布局调用 "View"】
竖排，
  量b=按钮()

心电图和FIFO环形队列
Ripple在指弹起后固定时长到达边缘

源至源、反向逐行、末填白... 理解为很大像素的扫描线+底图，无需先反向 递减变递增

算符与名字的分词是中文里一个问题，一般语言基于名字词法的“尽量短” 避免把3词a+-b错误归位，但对同类字符 (甲到乙、 按钮被点击)显然不够
Tries 后缀树是绝句记法解析分词工具： 非")( " 字~典首字 典:误=拼合,正=缓存1符 ，扫描直到苛构词，首先取止字典首字 再查，若空则拼合无效的部分
若有2词 abc, bc 则 "_bc" 会失败一次 跳1字符 再匹配，理论上 b 失败可直回根树同前缀(正错双路径)，但这带来不必要空间与代码量(记法大多几字、无后前缀重叠)
实际 abd, bc 则 "abc" 在首次读2字仅d不对，也最多跳1字。

按绝句的语言层次：言句段 词构书 排下此处列的语法(目前还在归总手写不分词解析器经验,..)

```
名 ([+-]小)数 字文真假空
言 &|^ +- */% << >>; > < == !(=><); && || as(特殊右项) =
  符|名|new 型
言前 -! &* delete ++ -- ~
言后 .符| [言] |(符:言,) |::<型,>(符:言,)
型 符| [&*](const)型 |[型,数量]
句 va[lr]|let 符(:型)(=言)--不可皆空
  return 言
  if(言)段句 else 段句--言内,同
  while(言) 段句
  do 段句 while(言)
段 {多句;}
事名 (性质,)fun(<符,>)(型.)符(符:型,):型
性质 #[名(名,),]
词 事名 (段)
  struct 符(<符,>){名:型,}
  trait(<符,>)符{事名;}
  impl 符 for 型{事名 段;}
书 词;
```

; 可选换行|';'|无
as Type 我倾向优先级和 infix fun 相同

绝句概念的词=动名词，即OOP属性方法，构=储例况标抽象物， Kamet 是impl结构范式，有隐式主语但没有并列两者(事/量) 不知道咋对应

绝句的概念把 >= <= 视为 !< !> (前缀不)、 a+=1 写为 a令置为「+1」

JS,Lua 会把 {a:1} 等半常量放在 .name |.f() 并列的层次，所以可 {}+1 却不能组合出 {a:1}.a, function(){}() ，应该是反常量糖的一种设计

ParserKt的重写 scanjs 使用的输入流变成了一个单参 +peek -consume 闭包，大概是完全不考虑性能了，但调试方便且3行。

AC为Trie每径建失败回滚，也让其处理不限长输入，当然线性字典分词的避免重复s[i]== 对程序解析不重要，我用的是后缀树，现在 scan 的设计也并非是一次一字符了(尽管验证时仍需)，而 Java,Kt 语法也有 `ifCat(TypedName,ArgBody, both), ifCatTag(Tries({val:Type_Name,fun: }))` 等统一的方法处理


我可以把某人某集体金库的6位密码告诉你，得到6位密码你就暴富啊！可你知道对那人而言这6位数字是什么吗？是他拼搏半辈子的收获。你这6个数字不轻松吗，你就只知道是钱，不知道钱背后的心血有多不易。首创的价值不在结果而在投入

就像你作为食客可以评价那鸡肉有多柴，但每块都是数十倍于它的稻谷换来的；不是世界上没有过好东西，而是出现后，你觉得不值钱，不知道珍惜，就淡出了；也不是现在没有潜力股，只是自古以来流行的往往不顶尖，因顶尖的都甘藏背后

但就这样都还“好”，一些人眼里知识换不到钱和工作或点赞，就没价值，该删删该怼怼该蹭蹭。 国内就是这样的环境，那就别指望超英赶美了。

在你眼前标价、求固粉的人，谁强啥难说得天花乱坠，有多少是真正的技术人。

说得对，人最重要是身体健康与相对自由，
我应该认清人与人对名词定义的不同，自认配不配与技术作风是别人的私事，我有什么资格管呢？
做最帅的自己就好了。人穷是有原因的，但追求的一定都是更好，眼界不同归不同了。



AB岛问题，数学化的脑筋急转弯。 A岛恒说真、B岛恒说假，得知自己在哪。 但如果把它当逻辑问题想就易糊涂

从编程角度，二岛描述为 A=(命题p)=>p B=(命题p)=>!p ，问题为 存在p.A(p)!=B(p) 其中 p可以关于：我、此岛、另岛…

如果你想区别 p与!p (准确的说是 p(A)与!p(B) )，「此岛==A」也即函值=p 的问题正巧不能区分(此==A|此!=B)，但1+1=2 等无关AB的恒问题就可解决。

如果一定要关于AB，求解关系式 p. p(A)!= !p(B) /AB固定 把 p(x)=>x!=A , x!=x, x!=A&x==B (&前第1问就同了), other(定义为!p,因为!!p=p), other(x)==x&x==A 带进去试，本质只是加快你枚举测试，毕竟计算机只对方程组有更好的解法

总之，想区分函数 not(q=>!q) 与 idp(x=>x) /identity-path 唯一的方法就是真假值常量，不管是关于什么得出的，因为只有常量对应「区分」的语义；每个人眼里自己(id)都是自己，但对系统他必须独一(reflexive,自反性)。

AB叫什么并不重要，只是一个关系式问题里 A=p,B=!p 能拿到性质的定义

「另外一个岛会说这是A」 !p(A) 和「..说那是A」!p(!x)x==A 以及「此是真话」 p(x)==x  是一样的，但 p=!p 就恒假，AB也只有靠它们的定义区分


C太虚、Java太冗、C++太满、函数式太不写实，都是言不及义

各种_t _st 和类型运算符typedef 的区别；各种XXer XXor 莫名建立class；算法与魔术齐飞，语法共注释无色

类名函数名、参数局部量、属性

camelCase,snake_case,Caps
可是中文哪来下划线和大小写？按位置区别命名符号，区分来区分去不就为了选取方便吗？名词的作用域有多重要？可一个优秀的API，名动词区别开来应该很难吗？文档没做好才靠字符模式弥补可读性吧？
对象设计，动词，以及一堆动词构成的名词吗？


逗号布局 若真，说("好")。否则，回。

绝句用，。表示或逗号缩进 取代常见的 `{}` 语句块

对公司里的，
  对部门里的某，
    若某的名字是" "，略过[ ^公司]。“不是啥正经部门 空格都不删”
    否则，说(某)。

恒事、恒量 是编译期即试计算的值，已知量会执行，而保留未知。其结果会被内联到代码里
因此，绝句不需要“构建语言”或“高级类型系统”就能实现它们的功能。编译期沙箱安全是考虑内的。

如果你的代码含大量公式，可以用：

事 某 为
量，a=PI；b=2；c=3。
变数，
  i初0
  j初i+1
其中，
  量PI=3.14

人称文法 我的名字去替换(a、“为”b)

绝句使用的面向对象范式(OOP)被称为『名动词面向对象』，没有 static(class的同名object上的名词和动词)
我/this、亲/super 描述OOP，它/it 描述函数式，你(temp1= ) 代表临时变量 替换 f(x=x.next) 等赋值表达式

储物 P(x：数、y：数) 为
  量 距离 取，浮去开方(x*x+y*y)。
  事 绘于(g：画布)=g去fillRect(x、y、1、1)

量p=P(1、2)；量提(x、y)=p
对建行(p)带编号 里的提p、i，量提(x、y)=p；待写。
p令为，【提x、y】x+y。

下程序描述了临时「你」和函式「它」的自然度：

变人? 找 初空
对嫌疑人里的x，
  若你 x的名字前缀以"?"，找=你。

找?令为，警署去抓捕(它)。 空则抛错误("写检讨")

「若/判」里也可用“你”，「对/接迎」也可用“它”

也可以写出构造函数「造于」

物 P 为
  变数，x初0；y初0。
  造于(x：数、y：数) 为
    我的x=x；我的y=y “无法用主构造器外的方法赋值不变量”
  造于(l：数)：我(l、l)
  既定的事 化文()="($x,$y)"
  初，说(我)。 “init{} 即造于的末语句”
  同名例 点计算 为“Kotlin companion object”
    量 零=P(0、0) “P的零 ；P的点计算的零”

造于和初的作用是修饰主构造器。
与Kotlin 里的val/var 可变性稍有不同，(仅)主构造器语法里「量」可不带前缀。如果有超类：

未定物 带长(变数l) 为
  未定的事 当增长
物 点线(x：数、y：数、你l：数)：带长(l)

好了。现在物和事是一回事了，只是物可以暴露变参 层层修饰，「内物」可以取代 Kotlin 的匿名 fun()=object{}
物(主构造器)的参数比事严谨，不能含特称命名，其他构造器和事一样

类 基础 为
  变数 金钱
物 A：基础 为
  既定的量 金钱=10
物 B(你a：A)：代者<基础>(a) 为
  既定的量 金钱=10

B(你 A())顺便其，
  金钱是10；你的金钱令置为「-10」
  “那其”金钱是0

代者<T>(T类值) 可以继承自T的实例、保持更新，并修改一些行为。
这复现 Kotlin 的 `class A(obj): T by obj` ，绝句也用 `量x=某存储<T>()` 取代 `val x:T by delegater` 的 `operator fun getValue(self,KProp):T` 语法重载
实际上，`变数a初0 ；a令置为「+1」` 里即事 存储<T>.令置为(op：转换<T>) 值=op(值)
同样还有 变ab； 量 v=值最新，a+b。 由绝句编译器自动处理ab改变的重算

若 物 A：“类”可关闭 是外部代码，`类实例 可点击 A 为` 能定义自动转换。
你也可以用 `物 主 活动()` 定义 `物 主活动：活动()`，即去掉亲物(超类)前的冒号自动后缀物名。请尽量起有意义(能表示特色)的名字规避这个，如 `物『易翻译』：活动 为`

在Kotlin里，class和伴生例(绝句:同名例,在物首次使用时创建)的类型是无关的，但绝句里可以让类<我、..>约束同名例：

对何<我> 类 零值 为
  同名例 为
    量 零值：我
对何<T：零值>事 零=物的同名例<T>()的零值
物 某：零值 为
  同名例 为
    既定的量 零值=某()

绝句的「量提」不支持嵌套元组。通过 `恒事 化组` 定义解构顺序
绝句还有个 `提 建表("k"到 v或0、"x"到1或"报错消息")=某表` 的解构语句。由 `<K、V>表：可解构<我>` 负责将含存储<V> 的另表内位置值对应上。

恒事 归一(模：表<存储或<K>、存储或<V> >、值：表<K、V>) 为
  对模里的提(k、v)，
    若k是存储，报错("暂不支持反查")。
    否则，再归一(v、值[k]“空则使用'或'的值”)。


绝句类型皆是集合。如有 `f(1、g())` ，Int是f参[0] 的子集、g()的类型 是f参[1]的子集 ，类型检查便通过。`a=1` 类同。没有比『值?』大的集合、没有比『断止』小的集合。
若把 函1<T、R> 作参数，函1<A大于T、B属于R> 能实现最大兼容，因为，<入T>只能赋值、<出R>只能取值，一个值都能接收的 函<值、R> ，显然属于 函<数、R> ，即『型参的形变性(variance)』。 函<T=*> 里*代表T上界或 值?
绝句通过「恒事」暴露类型符号，因为类型永远在运行前就在， 对何<T>(其中T：X) 写在物事前面。没有 TypeScript 的 type:lit/list/dict ，也没有 C++ 的 template<> 和 decltype(x) y=0;

如果说类型也能计算，对何<T> 用于引入变量，我们取T在所有位置的交集(直至空集) 以推导其类型，然后再检查。  (其中 T：某恒事()“而非 某物<>” ) 用于增加限制，这里就可以依类型和常量生成新类型了。 例如用 "([II)Z" 简写 `函3<行<数>、数、真假>`
恒事 相同(T：类型、U：类型)：型<数值> = 若T不属于断止且 T属于U且U属于T，型<数>()。否则，型<浮>()。

【不定长型参】
你不需要学习链表和解构匹配，亦无需写大量重复代码，就能定义编译期检查，因为类型也是调用表达式，行<> 只是调用同名的类型构造器(所以 其中 里 可"()")。而对于一些不运行的程序，`恒事 f(：文)：typ<此文>=待写 ；恒事 typ(：文)：类型`  的返回类型可以依赖参数来检查(类型即值, 一些人也说依赖类型)，也可取子集以外的成立规则。绝句编译器不仅是语言实现，也是用户定制的库。

恒量/事 在编译期常量折叠时执行，能化简就规约，信息不够的就内联变量，「若」和「对」全常量数据 经过剪枝和循环展开都是没有运行期开销的。`x为未知` 可用来判断参数x是否能折叠为值。 通过决定恒事的内量是否常量(`作值` 即不是)，能实现编译期的高级语法糖。绝句的 代者<> 也正是靠反射-语法模板("事 某f(：某余a)=o去某of()") ，动态定义物事 实现的


记法 事「加」(a：数、b：数)=a+b

绝句里没有 `operator plus(+)` 这类功能，因为用户可自由定义分词中/前/后缀运算，与它相关的符号是「」。在表示算式时，「」可以和逗句换用，但它能写 `1令为「+ 2」；量a=建行(1、2)；a去叠「+」；a去叠改(100)「-」` 的不完整形式
数学有从1个数得出很多数，它觉得这个数是本质，所以叫归纳、规约、回归，我们只从几个数得出1个数，是计算的过程，就叫折叠
物量事的名字换成「至」「到」这样的角括，就代表定义新算符，从而兼容 `对1至2“(1~2),1止3”里的数，待写。` `建表(1到2、2到3)` 语法。绝句·瓷就有 `按钮被点击时，它的颜色=红。` 这种记法

在物里，量是「~为优」的后缀形式；事是「~与~」的中缀式。 在全局里，事是「待写~」的前缀式。它们的参数个数是1,2,1。 」后可随小中大，越大越后计算，囊括更多单项，单项前后缀优先级默认是 `-(a!!)` ，的去助词和[]是种特殊后缀

引单 绝句.标点 「+」作 语法可以隐藏可能造成麻烦的记法

汉语词性：动名形副代介连数量助vnaArjlnNh 感叹/拟声

中缀否定 若此行不为空，待写。

绝句里 1<=10 也可写成 1不大10 ，没有「小于或等于」这件事。看起来很奇怪(当然,从Java自动转换是支持的)

许多语言里正反命题(如一行空不空 isEmpty isNotEmpty=!isEmpty)都有，这造成了不严谨性，而记法的加入 `某行 为空；某行 不 为空` 删改了这些冗余操作符。绝句是第一门拥有从四则运算扩展来，掰着手指都能数过来的表达式，功能却毫无匮乏的语言——因为它不随意添加符号

类似地，如果你的数据含大量真假值，绝句提供了 位旗 帮忙编码和查询，省得生硬列举。

关键明词 公开私下族内组内

Java被认为是经典OOP语言，但它的理论不可理论——是从一个不太好的图形编程 Smalltalk 继承来的，因此，许多人一边接受Java，一边又不得不为它的缺点写重复代码。

Java的继任者，Kotlin，修正了 Scala,Groovy 等语言的模糊用词，带来了真正优美的面向对象编程-没有 static、再见 final ，默认 public 成员，关键词化 @Override 检查，使 Java 里必须用“设计模式”解决的 `UserBuilder().setID(1)` 变成 `User().apply{id=1}`、`Singleton.getInstance()` 和Factory变为 `object Inst:Singleton()` 后直接引用 和构造函数，

简化明确了 `for(i in 0..1) for(item in list)` 等迭代、以 `val u=getUser() ?: return` 使null问题化腐朽为神奇，并且能和 JavaScript 乃至C兼容、跨客/服端编程，删掉无意义重复和不统一，无愧于『高级语言』四字。

而绝句追随 Kotlin 的足迹与现代汉语的进化，更进一步，将面向对象彻底与现实接合：对象是名词的“变/量”组合成的名词:物/例，方法是名词“我”上的动词:事；按物量事，抛弃了半通不通的外来语翻译『类(class)/属性(property)』和『方法(method)』

整门语言，有诀为证：

物:储例况标 内未定
句若判对回 重复停
行集合映滤 排组归
名数浮字文 真假空
言记大小是 不属存
语名言句段 词构书
象我亲若你 函式它
储组行表列 事内量

可见性，公开私下族内组内
确定性，既定未定可定终定
物结构，初造于 同名例 量取置 事是=
内联 断续 恒 不定长

绝句的 `(表达式)空则(语句)` 修正了 Kotlin 内 return 也是表达式/`listOf(return,break)` 的问题

绝句的 `令为；令为其；顺便；顺便其` 严谨了 Kotlin 的 `let;run;also;apply` ，我们不提倡 `事 数.某=(我)令为其“=run”，它+1。` 来省略返回类型，因此不给流水线/顺便操作符添加参数 `函1<数、返=数>` 为 `函1我<数、返=数>` 的版本。

- 绝句去掉了匿名内部类(即Kotlin 匿名 object)，因为内物(inner class) 和逗句块与它重复，相对的，内物首字母可小写(尽管用中文就没有大小写)也可定作私下。绝句删掉很多“有戏”的地方
- 但，绝句的编译期计算引入了更多可能。在绝句里“类型”只是语法位置绑定的信息，直白而优美，和类型“魔法师”比字正腔圆、有的放矢，不迷糊不哆嗦。从“你好世界”的动作到描述层面的编程，为表达而突破，不为高深所动，如此的绝句始终在你手上。不为酷而编程，你就是最酷的
- 绝句使用 代者<T>(o) 恒事调用(没错继承列表里可以)取代 T by o ，绝句能 `亲[^非直接父类]去干啥`
- 类型参数 in/out/reified 为“入出真”前缀。类不能有真(拿Class<T>)型参，但构造器也是普通函数，可以被重载(仅同名例的受调用 动词)
- 带我函数(fun with receiver)的我就是首参，在 `去：` 语法里可以互换
- `(a as T?) is T` 空判断和 x as T 后 x 的 smart cast 是支持的， [MethodHandle.invoke](https://xie.infoq.cn/article/6d30b8221c1a967ec32ac3b9c) 按参实型调用也可自由使用
- 绝句的 label 使用 [^] 语法而非@ 。 `out@for() inn@for(){break@out;continue@inn}` 作 `对[外]a里的，对[内]b里的，停下[^外]；略过[^内]`
- 绝句也有 soft keyword 和『』强行合法名字，这被称为 软/常/苛 分词限制

单字行表 可为< 行<数>、 表<名字、用户> >

绝句的语法崇尚简洁的同时保证语义，因此它不像一些入门者所诟病的单字符命名癖，也不会落入越长越清晰的词堆逻辑中。

因为崇尚一眼看懂(且“一眼”也不应费时间)，绝句有套独门秘籍帮助编程——不纯函数式。 所谓不纯是因当今流行的函数式，多少存在炫耀技巧名词，无视做法原因的坏毛病；靠函数作参数，能简化无聊流控逻辑，而且可函数式「内联」-意味函参数代码直接粘贴到处理内，每运行不再“调用”！

对何<T>类型别名 命题=函1<T、真假>

对何<T>事 列<T>.过滤(条件：命题<T>)：列<T> 为
  对我里的，
    若条件(“接受”它)，交(它)。
量 _123=列自(1)，它+1。去过滤「<4」去取(3)

绝句的另一套绝技是纯 Markdown 内联文档 ‘’ ，学习标准库的有效文档法概括，再把示例和链接写在最后就成。编译器自带doc网页生成功能

因为中文的特质，对于语言最重要的数据集处理——全都执行某操作(+1,.)、以某操作过滤、组合上序号、叠加求和，以及 表<“名字=”文、用户信息> 的键值KV表，都以不大于3字的动名词表示

组行表集合迭 迭子 列，Array List Map Set Collection Iterable Iterator Sequence

包括行和惰性计算流在内，绝句的列表处理统一暴露了一个「列」接口，来执行映滤排组归操作

支持协程(断续函数)。
