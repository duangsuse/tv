语言。直直的，不拐弯
数据。简单的，无特例
框架。可见的，不模糊
原理。尘封的，更未来
数据等效，程据对仗

物储例况标 内抽象
句若判对回 重复停
行集合映滤 排组归
名数浮字文 真假空
言记大小是 不属存
语名言句段 词构书
象我亲若你 函式它
储组行表列 事内量

公开私下族内组内
既定未定可定终定
初造于 同名例
取置代者 事是=
内联 断续 恒 不定长 【外部】
对何皆有其中

<T>存储(变值)：代者<T>(值)
造于 初 同名例 取者 置者 代者
事为 事= 事是 (其中) 可选/特称/隐式/不定长 参数
对何<真T>(其中) 类型别名，
性质推导，

对何<我>类 可序 为
  事 比大小(：我)：序
取伴生例(o作数4)“伴生例的类别在子物也可用”
“对何<T>(其中T：无型) 取伴生例<T>()作无型”

量a=晚置<路由器>()
量b=懒，算出。
回重()
1令做，[此]
  "a"令做，说(它[^此])。
尝试，抛下 错("")。接迎可为<错打开、错>，说(它)。皆有，下一项()。
变数a初1；a令置为「+1」

组是长固定的行、列替代迭的API
对a带编号里的量(x、i)“俩项”
量我是 建行(a、b)；回a+b
判a量，
  建行(1、a、b)，“去提取(1 &a&b)是真”
"${变量}$文 本"
映为 滤出 排序(序=大先) 组合每两项/分块/分块补满 归纳  串联/交替/组合

记法可用 「到」大中小右 形式指定优先级；如果不是系统性设计表达勿用！(绝句std未使用特性)
「x」式小级与 「*」同级、中「作」同级、大「=」同级；因且或「是」逻辑没啥可修饰
「x~」式小、中同「非」，大包括整个表达式
「~x」式小、中同「!!」，大同上

(删掉 用户的名字 嘛) 即「删掉~」小 而「~嘛」中，默认~x比 x~ 先算(小/中)。
>实现上，言单=名/(言前 括号/言单 言后) 形式先算符在先，x~大直接读右言， ~x 请顶层插自己名再读+-

书|引 书名；引单 书名 (名|记法名 (作 名?)?)+ “仅有一项时导入例/例物 的所有量”
单引号是 字 或跨行文本，前置缩进自动删除；否则默认禁止：文拼(首项)+文拼，次项[i]+末项[i]。

【类实例】的物 公司 法律 为
  量 法人 取者，董事长。
物 加(：流)：代者<流>(此流)、加法 为 “代理可继承自对象o，实用于不想重创建o”
  既定事 处理(i：数)=增(i)

书 绝句.基元
例 效果；物 断止 私下的造于()
类 异常；物 错：异常
类 开区间 为
  始；末
  扩(方位、计)
例 数略“半区间 a[0~数略]是a”
对何<我>类 数值：可序 为
  外部的事 负加减乘；除(内数) “自动 1+1L提升 1+1.0报错”
  事「~」(末)=开区间(我、末)
  事「止」(末止)
  「步长」「降步长」
  同名例 为 最大最小 值0 字节数 同字节
类 数：数值 为
  除余()：计余
类 浮：数值

组内的类型别名 正数=数，它>0。
类型别名 针=计=正数

书 绝句

令置?为其?；顺便..
量不可能：断止
可定的物 位旗(不定长 码位)
  加删有
说
函数我
表(1到2)

书 .译
标物 英

言句段 词构书

词法是 “” ‘’

『名』是绝句值中最常用且很难替代的部分，直接表达在代码文本、存储在编译输出里，只有它们是不需计算即得到的(@数组
一些是对生活概念内的固定指代如 `1 10 '字' "文本"`"字面常量"，另一些是对程序运行时某位置值的指代如 `首项 前缀 PI`"变量"

建行("动苏"、123.0、真、假、空作 数?)作行<值?> “按位置包含了『名』”

单独的『名』没有意义，只有它与位置、其他值关联时才能实现程序目标，所以绝句的语法构造从『言』开始算

为啥 1,2 这些数值也能算『名』？这要问为啥 1+1=2 ——没有为啥，因为 2=0+1+1 ，从0加上两个1的数，称之为2 。数值只是计算内支持的项、变量只是可以不固定的量，叫啥并不重要

`入口=说(招呼("小王"))` 调用栈

事(x)=函数，x。

很大部分值都是代码内以字面形式提供的，只有小部分 `听去文()` 或 `文件("a.txt")` 是用户提供的

固定的值越少，程序可扩展性越强；但过度抽象也会带来理解难度，且不实用。编程应据使用范例，合理规划可调整的参数量

言 ，绝句.基元 定义的算符(记法)  言前 言后
作型 空则 言句

句 ；段=多句

词 是动词名词，即操作和参考值

构 是物、类、类型别名及书级词

书 是带点名与引用表
引 点名
引单 点名(名作 (名))* --若无项，引入末名 例物/例/伴生例 的内容
【自由布局调用 "View"】
竖排，
  量b=按钮()

心电图和FIFO环形队列
Ripple在指弹起后固定时长到达边缘

源至源、反向逐行、末填白
cnblogs.com/cpaulyz/

算符与名字的分词是中文里一个问题，一般语言基于名字词法的“尽量短” 避免把3词a+-b错误归位，但对同类字符 (甲到乙、 按钮被点击)显然不够
Tries 后缀树是绝句记法解析分词工具： 非")( " 字~典首字 典:误=拼合,正=缓存1符 ，扫描直到苛构词，首先取止字典首字 再查，若空则拼合无效的部分
若有2词 abc, bc 则 "_bc" 会失败一次 跳1字符 再匹配，理论上 b 失败可直回根树同前缀(正错双路径)，但这带来不必要空间与代码量(记法大多几字、无后前缀重叠)
实际 abd, bc 则 "abc" 在首次读2字仅d不对，也最多跳1字。

按绝句的语言层次：言句段 词构书 排下此处列的语法(目前还在归总手写不分词解析器经验,..)

```
名 ([+-]小)数 字文真假空
言 &|^ +- */% << >>; > < == !(=><); && || as(特殊右项) =
  符|名|new 型
言前 -! &* delete ++ -- ~
言后 .符| [言] |(符:言,) |::<型,>(符:言,)
型 符| [&*](const)型 |[型,数量]
句 va[lr]|let 符(:型)(=言)--不可皆空
  return 言
  if(言)段句 else 段句--言内,同
  while(言) 段句
  do 段句 while(言)
段 {多句;}
事名 (性质,)fun(<符,>)(型.)符(符:型,):型
性质 #[名(名,),]
词 事名 (段)
  struct 符(<符,>){名:型,}
  trait(<符,>)符{事名;}
  impl 符 for 型{事名 段;}
书 词;
```

; 可选换行|';'|无
as Type 我倾向优先级和 infix fun 相同

绝句概念的词=动名词，即OOP属性方法，构=储例况标抽象物， Kamet 是impl结构范式，有隐式主语但没有并列两者(事/量) 不知道咋对应

绝句的概念把 >= <= 视为 !< !> (前缀不)、 a+=1 写为 a令置为「+1」

JS,Lua 会把 {a:1} 等半常量放在 .name |.f() 并列的层次，所以可 {}+1 却不能组合出 {a:1}.a, function(){}() ，应该是反常量糖的一种设计

ParserKt的重写 scanjs 使用的输入流变成了一个单参 +peek -consume 闭包，大概是完全不考虑性能了，但调试方便且3行。

AC为Trie每径建失败回滚，也让其处理不限长输入，当然线性字典分词的避免重复s[i]== 对程序解析不重要，我用的是后缀树，现在 scan 的设计也并非是一次一字符了(尽管验证时仍需)，而 Java,Kt 语法也有 `ifCat(TypedName,ArgBody, both), ifCatTag(Tries({val:Type_Name,fun: }))` 等统一的方法处理


我可以把某人某集体金库的6位密码告诉你，得到6位密码你就暴富啊！可你知道对那人而言这6位数字是什么吗？是他拼搏半辈子的收获。你这6个数字不轻松吗，你就只知道是钱，不知道钱背后的心血有多不易。首创的价值不在结果而在投入

就像你作为食客可以评价那鸡肉有多柴，但每块都是数十倍于它的稻谷换来的；不是世界上没有过好东西，而是出现后，你觉得不值钱，不知道珍惜，就淡出了；也不是现在没有潜力股，只是自古以来流行的往往不顶尖，因顶尖的都甘藏背后

但就这样都还“好”，一些人眼里知识换不到钱和工作或点赞，就没价值，该删删该怼怼该蹭蹭。 国内就是这样的环境，那就别指望超英赶美了。

在你眼前标价、求固粉的人，谁强啥难说得天花乱坠，有多少是真正的技术人。

说得对，人最重要是身体健康与相对自由，
我应该认清人与人对名词定义的不同，自认配不配与技术作风是别人的私事，我有什么资格管呢？
做最帅的自己就好了。人穷是有原因的，但追求的一定都是更好，眼界不同归不同了。
