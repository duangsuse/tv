语言。直直的，不拐弯
数据。简单的，无特例
框架。可见的，不模糊
原理。尘封的，更未来
数据等效，程据对仗

物储例况标 内抽象
句若判对回 重复停
行集合映滤 排组归
名数浮字文 真假空
言记大小是 不属存
语名言句段 词构书
象我亲若你 函式它
储组行表列 事内量

公开私下族内组内
既定未定可定终定
初造于 同名例
取置代者 事是=
内联 外部 断续 恒 不定长
对何皆有其中

<T>存储(变值)：代者<T>(值)

量a=晚置<路由器>()
量b=懒，算出。
回重()
1令做，[此]
  "a"令做，说(它[^此])。
尝试，抛下 错("")。接迎可为<错打开、错>，说(它)。皆有，下一项()。
变数a初1；a令置为「+1」

对何<真T>(其中) 类型别名，
事为 事= 事是 (其中) 可选/特称/隐式/不定长 参数
造于 初 同名例 取者 置者 代者
对a带编号里的量(x、i)“俩项”
判a量，
  建行(1、a、b)，“去提取(1 &a&b)是真”
"${变量}$文 本"
映为 滤出 排序(序=大先) 组合每两项/分块/分块补满 归纳  串联/交替/组合

组是长固定的行、列替代迭的API

书|引 书名；引单 书名 (名|记法名 (作 名?)?)+ “仅有一项时导入例/例物 的所有量”
单引号是 字 或跨行文本，前置缩进自动删除；否则默认禁止：文拼(首项)+文拼，次项[i]+末项[i]。

【类实例】的物 公司 法律 为
  量 法人 取者，董事长。
物 加(：流)：加法、 流 代者 此流 为 “代理可继承自对象o，实用于不想重创建o”
  既定事 处理(i：数)=增(i)

书 绝句.基元
例 效果；物 断止 私下的造于()
类 异常；物 错：异常
类 开区间 为
  始；末
  扩(方位、计)
例 数略“半区间 a[0~数略]是a”
对何<我>类 数值：可序 为
  外部的事 负加减乘；除(内数) “自动 1+1L提升 1+1.0报错”
  事「~」(末)=开区间(我、末)
  事「止」(末止)
  同名例 为 最大最小 值0 字节数 同字节
类 数：数值 为
  除余()：计余
类 浮：数值
对何<我>类 可序 为
  事 比大小(：我)：序

取伴生例<T>()作无型
取伴生例(o作数4)“伴生例的类别在子物也可用”

类型别名 正数=数，它>0。
类型别名 针=计=正数

书 绝句

令置?为其?；顺便..
量不可能：断止
可定的物 位旗(不定长 码位)
  加删有
说
函数我

言句段词构书

『名』是绝句值中最常用且很难替代的部分，直接表达在代码文本、存储在编译输出里，只有它们是不需计算即得到的(@数组

建行("动苏"、123.0、真、假、空作 数?)作行<值> “按位置包含了『名』”

一些是对生活中某概念内的固定指代如 `1 10 '字' "文本"`"字面常量"，另一些是对程序运行时某位置值的指代如 `首项 前缀 PI`"变量"

单独的『名』没有意义，只有它与位置、其他值关联时才能实现程序目标，所以绝句的语法构造从『言』开始算

为啥 1,2 这些数值也能算『名』？这要问为啥 1+1=2 ——没有为啥，因为 2=0+1+1 ，从0加上两个1的数，称之为2 。数值只是计算内的项、变量只是不固定的量，叫啥并不重要

`入口=说(招呼("小王"))` 调用栈

事(x)=函数，x。

很大部分值都是代码内以字面形式提供的，只有小部分 `听去文()` 或 `文件("a.txt")` 是用户提供的

固定的值越少，程序可扩展性越强；但过度抽象也会带来理解难度，且不实用。编程应据使用范例，合理规划可调整的参数量


源至源、反向逐行、末填白
cnblogs.com/cpaulyz/

按绝句的语言层次：言句段 词构书 排下此处列的语法(目前还在归总手写不分词解析器经验,..)

```
名 ([+-]小)数 字文真假空
言 &|^ +- */% << >>; > < == !(=><); && || as(特殊右项) =
  符|名|new 型
言前 -! &* delete ++ -- ~
言后 .符| [言] |(符:言,) |::<型,>(符:言,)
型 符| [&*](const)型 |[型,数量]
句 va[lr]|let 符(:型)(=言)--不可皆空
  return 言
  if(言)段句 else 段句--言内,同
  while(言) 段句
  do 段句 while(言)
段 {多句;}
事名 (性质,)fun(<符,>)(型.)符(符:型,):型
性质 #[名(名,),]
词 事名 (段)
  struct 符(<符,>){名:型,}
  trait(<符,>)符{事名;}
  impl 符 for 型{事名 段;}
书 词;
```

; 可选换行|';'|无
as Type 我倾向优先级和 infix fun 相同

绝句概念的词=动名词，即OOP属性方法，构=储例况标抽象物， Kamet 是impl结构范式，有隐式主语但没有并列两者(事/量) 不知道咋对应

绝句的概念把 >= <= 视为 !< !> (前缀不)、 a+=1 写为 a令置为「+1」

JS,Lua 会把 {a:1} 等半常量放在 .name |.f() 并列的层次，所以可 {}+1 却不能组合出 {a:1}.a, function(){}() ，应该是反常量糖的一种设计

ParserKt的重写 scanjs 使用的输入流变成了一个单参 +peek -consume 闭包，大概是完全不考虑性能了，但调试方便且3行。

AC为Trie每径建失败回滚，也让其处理不限长输入，当然线性字典分词的避免重复s[i]== 对程序解析不重要，我用的是后缀树，现在 scan 的设计也并非是一次一字符了(尽管验证时仍需)，而 Java,Kt 语法也有 `ifCat(TypedName,ArgBody, both), ifCatTag(Tries({val:Type_Name,fun: }))` 等统一的方法处理

