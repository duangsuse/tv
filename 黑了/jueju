语言。直直的，不拐弯
数据。简单的，无特例
框架。可见的，不模糊
原理。尘封的，更未来
数据等效，程据对仗

物储例况标 内抽象
句若判对回 重复停
行集合映滤 排组归
名数浮字文 真假空
言记大小是 不属存
语名言句段 词构书
象我亲若你 函式它
储组行表列 事内量

公开私下族内组内
既定未定可定终定
初造于 同名例
取置代者 事是=
内联 断续 恒 不定长 【内置】【重复于 "a b c" "0~9"】量$0$1
对何皆有其中

<T>存储(变值)：代者<T>(值)
量 有增 代者 值最新，x+1。
=值最新(x)，它+1。

值最新，说(滑条的值 作存储<数>)。

造于 初 同名例 取者 置者 代者
事为 事是 事= (其中 事=事=.. ) 可选/特称/隐式/不定长 参数
对何<真T>(其中) 类型别名，
性质推导，

恒事 符号执行，如a+1+2 ，已知量会被化简、未知参数则保留
类型<> 可以看作编译期的调用，创建出对象用于子集检查；恒事可以对标 Rust宏，也可以做循环展开等(视图树简写..)优化
恒 外 回重写 参组<数>
恒=内联+常量折叠 、外=Kotlin external(native)+expect

初，。init{} 可作为fun定义，infix 可让单参函数自带？但要 1.to 2 和 1 to 2 都可用，显然是支持 (f x) 并列即调用了吧

加=(a=>b=>a+b), 加(1)==(b=>.. ) 不易变的东西在前。就像洗盘子，会把抹布放在前面
事和值没有绝对的等价关系，局部函数 事(a)=事(b)=.. 只能在「其中」块出现，函<真假、数> 和 函自<数、真假> 最长16参

函数原义为盒子里的数，绝句解释为涵盖了几个变量的值，从算式得出或从计算流程指定
在C,VB等语言函数一般指子程序，只能含数目固定全局变量，没有闭包(匿名类型的对象:函数值)

对何<我>类 可序 为
  事 比大小(：我)：序
取伴生例(o作数4)“伴生例的类别在子物也可用”
“对何<T>(其中T：无型) 取伴生例<T>()作无型”

o作值 作行<值任>  “相当于或 util.List 即List<?>” 去皆，它作数。和List<*>一样是安全的

量a=晚置<路由器>()
量b=懒，算出。
回重()
1令做，[此]
  "a"令做，说(它[^此])。
尝试，抛下 错("")。接迎可为<错打开、错>，说(它)。皆有，下一项()。
变数a初1；a令置为「+1」

管道(文件("a.txt")顺便，夹/"a"；名；换前后缀(0)。)给(我：去滤) 至原地
听去行 再(面板：去处理)再(：去说)

组是长固定的行、列替代迭的API
对a带编号里的量(x、i)“俩项”
量我是 建行(a、b)；回a+b
判a量，
  建行(1、a、b)，“去提取(1 &a&b)是真”
"${变量}$文 本"
映为 滤出 排序(序=大先) 组合每两项/分块/分块补满 归纳  串联/交替/组合

纳文()顺便，"a b c"切以' '去皆(它：去加)。的值
纳俩项，它+它1。的循环 去值

"a b c"去收纳("")，"$它$它1"。

记法可用 「到」大中小右 形式指定优先级；如果不是系统性设计表达勿用！(绝句std未使用特性)
「x」式小级与 「*」同级、中「作」同级、大「=」同级；因且或「是」逻辑没啥可修饰
「x~」式小、中同「非」，大包括整个表达式
「~x」式小、中同「!!」(先于x~)，大同上

(删掉 用户的名字 嘛) 即「删掉~」小 而「~嘛」中，默认~x比 x~ 先算(小/中)。
量「」 和「文?」「取!」 都是不错的hack
>实现上，言单=名/(言前 括号/言单 言后) 形式先算符在先，x~大直接读右言， ~x 请顶层插自己名再读下+- ；前后级可比:小小大大

若试用户们 存一，它的名字是""。， “，。内部逗句默认警告”
Mandel,Berlin,圆环3D,Snake
存皆  存仅一
不始以"^"  末以"$"
事 试<文> 始以(：文)：真假
1令为其，到2。作俩<数>

书|引 书名；引单 书名 (名|记法名 (作 名?)?)+ “仅有一项时导入例/例物 的所有量”
单引号是 字 或跨行文本，前置缩进自动删除；否则默认禁止：文拼(首项)+文拼，次项[i]+末项[i]。

【类实例】的物 公司 法律 为
  量 法人 取者，董事长。
物 加(：流)：代者<流>(此流)、加法 为 “代理可继承自对象o，实用于不想重创建o”
  既定事 处理(i：数)=增(i)

书 绝句.基元
例 效果；物 断止 私下的造于()
类 异常；物 错：异常
类 开区间 为
  始；末
  扩(方位、计)
例 数略“半区间 a[0~数略]是a”
对何<我>类 数值：可序 为
  外部的事 负加减乘；除(内数) “自动 1+1L提升 1+1.0报错”
  事「~」(末)=开区间(我、末)
  事「止」(末止)
  「步长」「降步长」
  同名例 为 最大最小 值0 字节数 同字节
类 整数：数值 为
  除余()：计余
  量 宽窄 为
    _0~_8
  伴生例：数宽窄“类别0=Cnt,Int,Rat  长度0~8”
类型别名 数=数4
类型别名 计=数4「不小0」
类 浮：数值

类 有序
类 广列
类 列：广列
【弃用】类 可迭
类 有长：可迭“有长仅迭”
类 有长有位：有长

抽象物 动集：有长
物 集：动集<出T> “out 兼容收子类项 的集合”

储物(o:T)：代者<T>(o)
变，数a b c；浮p。
量a=建行(1)可变
量b=建组(2)作组<出数> “组是长固定的行，默认可变，否则类似固定行”

类型别名 数=可为<数1、>


组内的类型别名 正数=数，它>0。
类型别名 针=计=正数

书 绝句

令置?为其?；顺便..
量不可能：断止
可定的物 位旗(不定长 码位)
  加删有
说
函数我
表(1到2)

书 .译
标物 英

言句段 词构书

词法是 “” ‘’

『名』是绝句值中最常用且很难替代的部分，直接表达在代码文本、存储在编译输出里，只有它们是不需计算即得到的(@数组
一些是对生活概念内的固定指代如 `1 10 '字' "文本"`"字面常量"，另一些是对程序运行时某位置值的指代如 `首项 前缀 PI`"变量"

建行("动苏"、123.0、真、假、空作 数?)作行<值?> “按位置包含了『名』”

变量不只是独一的符号，它与位置关联。

单独的『名』没有意义，只有它与位置、其他值关联时才能实现程序目标，所以绝句的语法构造从『言』开始算

为啥 1,2 这些数值也能算『名』？这要问为啥 1+1=2 ——没有为啥，因为 2=0+1+1 ，从0加上两个1的数，称之为2 。数值只是计算内支持的项、变量只是可以不固定的量，叫啥并不重要

`入口=说(招呼("小王"))` 调用栈

事(x)是 函1<数>，x。“涵盖1变量 得<数>”

很大部分值都是代码内以字面形式提供的，只有小部分 `听去文()` 或 `文件("a.txt")` 是用户提供的

固定的值越少，程序可扩展性越强；但过度抽象也会带来理解难度，且不实用。编程应据使用范例，合理规划可调整的参数量

内存地址空间上，我们把独占的内存称为「对象」，通用空间称为「值」。值不可修改，往往没有专属的空间。绝句推崇低变量、高组合逻辑编程。


函数是代码复用、可配置性的好帮手，绝句里函数(含动词)除了能作为语言结构，也可以当对象用；事实上有 用()：返 一词的对象就是函数了！

绝句除了完整支持面向对象那一套，也可以用函数式(少起名字多用事=)的方法编程且不影响性能。

事的定义可有 事为 事= (可嵌套) ，或在大量定义相似的事时利用 `事 加2是再增，它+1。` 包装，类似Py的 `@decorator`

事 再增(f：函管<数>)= 事(：数)=f(它)+1

在不想给单动词「物」起名时， `变函<数、文> 显=函，"$它"。` 可以取代 例..事 显(：数)：文 的功能



对何<我> 类 可序 为
  事 「小于」(：我)：真假

事 大于(a：可序、b：可序)=a不是b且(a去不小于(b))
对和<N>(其中 N：可序<N>)(a：可序<N>、b：可序<N>)“我(Self) 泛型简写”

(：绝句.说)作函<文、效果> 、建集(1)：去加 作<数、效果>、「试(1)小于」


事 此为值 此设值 在同时存在时变量 = 就相当于通过这两函数；这样的物有 存储 代者 懒 值最新 【值收集】UI对象
等效<B、A> 自 至

含前缀 含后缀 切分以/ 以起始/结尾/切分
恒量构建=研墨，依赖("")。

绝句提倡把构建规则和main()写在一起，请不要把与社区大体重复的代码独立一个文件。 src/  test/ 的独立已经够了，如果你的仓库包含大量的代码外内容，把源码放在 /jueju/ 下就行


「提取」在 对里的提取、函，【提取x、i】、量提取a、b= 都是不可嵌套的！但用 提取建行(a、b到c)=建行(1、2到3) 这样可以

若你 和 令为 顺便 scope fun 是对标Rust if let 类的东西
有Kotlin 多主语的特性，有 物 A 事 B.啥()：数=我+我[^A] 后B上可用 函我<A、数> 的写法

言 ，绝句.基元 定义的算符(记法)  言前 言后
作型 空则 言句

句 ；段=多句

词 是动词名词，即操作和参考值

构 是物、类、类型别名及书级词

书 是带点名与引用表
引 点名
引单 点名(名作 (名))* --若无项，引入末名 例物/例/伴生例 的内容
【自由布局调用 "View"】
竖排，
  量b=按钮()

心电图和FIFO环形队列
Ripple在指弹起后固定时长到达边缘

源至源、反向逐行、末填白... 理解为很大像素的扫描线+底图，无需先反向 递减变递增

算符与名字的分词是中文里一个问题，一般语言基于名字词法的“尽量短” 避免把3词a+-b错误归位，但对同类字符 (甲到乙、 按钮被点击)显然不够
Tries 后缀树是绝句记法解析分词工具： 非")( " 字~典首字 典:误=拼合,正=缓存1符 ，扫描直到苛构词，首先取止字典首字 再查，若空则拼合无效的部分
若有2词 abc, bc 则 "_bc" 会失败一次 跳1字符 再匹配，理论上 b 失败可直回根树同前缀(正错双路径)，但这带来不必要空间与代码量(记法大多几字、无后前缀重叠)
实际 abd, bc 则 "abc" 在首次读2字仅d不对，也最多跳1字。

按绝句的语言层次：言句段 词构书 排下此处列的语法(目前还在归总手写不分词解析器经验,..)

```
名 ([+-]小)数 字文真假空
言 &|^ +- */% << >>; > < == !(=><); && || as(特殊右项) =
  符|名|new 型
言前 -! &* delete ++ -- ~
言后 .符| [言] |(符:言,) |::<型,>(符:言,)
型 符| [&*](const)型 |[型,数量]
句 va[lr]|let 符(:型)(=言)--不可皆空
  return 言
  if(言)段句 else 段句--言内,同
  while(言) 段句
  do 段句 while(言)
段 {多句;}
事名 (性质,)fun(<符,>)(型.)符(符:型,):型
性质 #[名(名,),]
词 事名 (段)
  struct 符(<符,>){名:型,}
  trait(<符,>)符{事名;}
  impl 符 for 型{事名 段;}
书 词;
```

; 可选换行|';'|无
as Type 我倾向优先级和 infix fun 相同

绝句概念的词=动名词，即OOP属性方法，构=储例况标抽象物， Kamet 是impl结构范式，有隐式主语但没有并列两者(事/量) 不知道咋对应

绝句的概念把 >= <= 视为 !< !> (前缀不)、 a+=1 写为 a令置为「+1」

JS,Lua 会把 {a:1} 等半常量放在 .name |.f() 并列的层次，所以可 {}+1 却不能组合出 {a:1}.a, function(){}() ，应该是反常量糖的一种设计

ParserKt的重写 scanjs 使用的输入流变成了一个单参 +peek -consume 闭包，大概是完全不考虑性能了，但调试方便且3行。

AC为Trie每径建失败回滚，也让其处理不限长输入，当然线性字典分词的避免重复s[i]== 对程序解析不重要，我用的是后缀树，现在 scan 的设计也并非是一次一字符了(尽管验证时仍需)，而 Java,Kt 语法也有 `ifCat(TypedName,ArgBody, both), ifCatTag(Tries({val:Type_Name,fun: }))` 等统一的方法处理


我可以把某人某集体金库的6位密码告诉你，得到6位密码你就暴富啊！可你知道对那人而言这6位数字是什么吗？是他拼搏半辈子的收获。你这6个数字不轻松吗，你就只知道是钱，不知道钱背后的心血有多不易。首创的价值不在结果而在投入

就像你作为食客可以评价那鸡肉有多柴，但每块都是数十倍于它的稻谷换来的；不是世界上没有过好东西，而是出现后，你觉得不值钱，不知道珍惜，就淡出了；也不是现在没有潜力股，只是自古以来流行的往往不顶尖，因顶尖的都甘藏背后

但就这样都还“好”，一些人眼里知识换不到钱和工作或点赞，就没价值，该删删该怼怼该蹭蹭。 国内就是这样的环境，那就别指望超英赶美了。

在你眼前标价、求固粉的人，谁强啥难说得天花乱坠，有多少是真正的技术人。

说得对，人最重要是身体健康与相对自由，
我应该认清人与人对名词定义的不同，自认配不配与技术作风是别人的私事，我有什么资格管呢？
做最帅的自己就好了。人穷是有原因的，但追求的一定都是更好，眼界不同归不同了。



AB岛问题，数学化的脑筋急转弯。 A岛恒说真、B岛恒说假，得知自己在哪。 但如果把它当逻辑问题想就易糊涂

从编程角度，二岛描述为 A=(命题p)=>p B=(命题p)=>!p ，问题为 存在p.A(p)!=B(p) 其中 p可以关于：我、此岛、另岛…

如果你想区别 p与!p (准确的说是 p(A)与!p(B) )，「此岛==A」也即函值=p 的问题正巧不能区分(此==A|此!=B)，但1+1=2 等无关AB的恒问题就可解决。

如果一定要关于AB，求解关系式 p. p(A)!= !p(B) /AB固定 把 p(x)=>x!=A , x!=x, x!=A&x==B (&前第1问就同了), other(定义为!p,因为!!p=p), other(x)==x&x==A 带进去试，本质只是加快你枚举测试，毕竟计算机只对方程组有更好的解法

总之，想区分函数 not(q=>!q) 与 idp(x=>x) /identity-path 唯一的方法就是真假值常量，不管是关于什么得出的，因为只有常量对应「区分」的语义；每个人眼里自己(id)都是自己，但对系统他必须独一(reflexive,自反性)。

AB叫什么并不重要，只是一个关系式问题里 A=p,B=!p 能拿到性质的定义

「另外一个岛会说这是A」 !p(A) 和「..说那是A」!p(!x)x==A 以及「此是真话」 p(x)==x  是一样的，但 p=!p 就恒假，AB也只有靠它们的定义区分


C太虚、Java太冗、C++太满、函数式太不写实，都是言不及义

各种_t _st 和类型运算符typedef 的区别；各种XXer XXor 莫名建立class；算法与魔术齐飞，语法共注释无色

类名函数名、参数局部量、属性

camelCase,snake_case,Caps
可是中文哪来下划线和大小写？按位置区别命名符号，区分来区分去不就为了选取方便吗？名词的作用域有多重要？可一个优秀的API，名动词区别开来应该很难吗？文档没做好才靠字符模式弥补可读性吧？
对象设计，动词，以及一堆动词构成的名词吗？
