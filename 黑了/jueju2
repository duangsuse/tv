编程是用「能联系住一切领域与(变化于现实)的语言」，逐条明理、有理复用地设计、组合语言于领域的构件，它是一种工程，却更该有优美的文体。

类物例事量 书引其恒是
既可未终定 公私族组内
储例况标 若判重复
事回抛停略 看滤序组归

看滤序组归 (滤虚祖龟)

列复喂<数>，[n]
  (2“4的因数”~n)升-1 去找，n%它是0。

列生，[n]
  (2~n)升-1 去看，
    若n%它是0，交(它)；n=它。

a去叠自(行链())，它+我。 叠加 (1~n)叠乘

试a[1~略]存皆，[是x i] a[i左]<x。
复a[0~略]

a令为，仨项(极小、极大、叠加/计)。令为，[是 a b c]"$a[$c]$b"。
“循环联合”

书|引 复合名  pkg,use
引单(共前缀:复合名) (复合名|算符名)(作 名|"空")?、 “前缀+点号名应是 物/名动词”

“类型别名 人表=表<任、人> 视作「物」”

对何<K>人表=表<K、人>
对何<> 任行=行<任>

对何<任我读写 恒>（其中 T 可序）
for<*“also "notype,dynamic" ”,this,get,set> (T HasSort)


from string import*
import random as rn
def takeSet(f,n,res):
    while len(res)!=n: res.add(f())
    return res
def randStr(n,nS=10,cs=ascii_letters+digits):return takeSet(lambda:"".join(rn.choice(cs)for _ in range(nS)),n,set())

rmContChar=s=>s.replace(/(.)(\1+)/gi,"$1")

引string
引单random 作rn
对何<T>事 改集<T>.取满(n：数、f：函0<T>) 为
  重复若长<n，添(f())。

事 randStr(n：数、nS=10、cs=ascii_letters+digits)=改，建集<文>()。令，
  取满(n)，nS次 去文隔("") 「rn去choice(cs)」。

况物 Nat 为
  Z()
  S(：Nat)

事 Nat.试相等(n：Nat)=判我到n 是，
  Z到Z，真。
  S(a)到S(b)，a==b。
  否则，假。

(建组(5)，
  建组(5、0))令，
  (0~末针)去看，[i] 我[i][i]=i。

量a：任

不定长 组<> 对恒事量是特殊的。 恒量a=建行(1、x)[1] 在运行期执行，而 恒量a=建组(1、x)[1] 展开为“x”。恒量b=(0~1)去看为，a[它]+1。 恒量b是建组(x、y) 也是编译期确定的，组能装算式，这可以用于创建比C更多功能的语法宏

恒事/量的规则：
1.其参数会及早计算(const folding,常量折叠,编译期化简)。事的参数非常量表达式，则直接内联/控制流
2.非恒里提及了「恒」量的代码会被及早计算，恒量不跨函数。绝句句级的语义是，非恒才生成运行期代码
3.若 恒量a=建组(1、x+1) 等 组<T>无法及早计算，它会变成恒组<T>，a[1]+2 即 x+1+2

恒物的规则：
1.恒物不作值，若 行<可变量<数>> 等无法及早计算，就作为「物」新构造
2.恒物()得恒量。其上所有事量内联，如  建组(3、4)[1~略]去看，[是x i]x+i。

例如，
恒事 增(i：可变量<数>)=令，i的值=i+1。
事 f 为
  变数a
  增(a)

事 f 为
  增(储a)
其中，
  变数a
  恒例 储a：可变量<数> 为
    量 值 读，a。 写，a=它。

可变量<数>隐转为数， (储a)的值=(储a的值)+1 ；a=a+1 ，此处能a= ，不必包装IntRef
但是，若有 说(储a) ，恒例直接视作例，a有非局部写引用，需包装IntRef
组可变量<T> 的信息更多

终定的例 算符 为
  事「+」


异步问题在语言来看，就是 a() 调用-等待 b() c() 到 b()完算c() 完算a() 的“尾调用(回调)化”
1. 可把 +-*/ 等运算视作调用， 1+yield() ，但函数变量的栈帧会从调用栈撤下，这些要保存
2. for 等控制结构也需保存“状态机”地址

例 录音驴：模型 为
  量 阈噪=500
  事 录段=听筒去取前无「<阈噪」去取前「不<阈噪」去叠在(已录)，它去添(我)。令，
    马达(1)；喇叭(频域(音域)去拆拼(已录)，线去映射(它、音域到尖音)。)；马达(0)
    已录去删；“再”录段()
  量 已录=暂存<字节>()
  量 音域=俩量(100~4410)
  量 尖音=俩量(音域[0.5]、音域[1])

对何<> 名=文「我不是"穷B"」
储物 房子(I：名) 为
  事 名.爱=说("$我，${I}爱$你")
  事「广告位」(：函我1<房子>)=令，函()；说("巴比天英伦古府 温馨50坪小窝  高邻${I}诚意幸会")。

事 打开 为
  房子("张三")令，"王五"去爱。
  房子("洪世贤") 广告位，
    "品如"去爱；"慕容复"去爱 “没差的 点开就懂”
  量 House=房子
  ("Jack"到"Rose")其令，[是B到A]
    House(A)令，B去爱。

对何<我>类 可序

对何<N>（其中 T 可序）
<N extends Comparable<N>>
Ln,LnBy

while true:
while: break[^1]“停下上1层”
if true;

if you a[0]<5: return you
a[0].takeIf{it<5}?.let{return it}

val odd=if n%2==0: 2*n :ok else n :ok +1
量奇=若n%2是0，2*n。否则，n。+1

val odd=(if n%2==0: 2*n else: n)+1

fun id(n a=0:Int)=if n==0:a; else while return(n-1,a+1)
事 id(n a=0：数)=若n是0，a。否则，重复回(n-1、a+1)。

事=事()=
其中[^2]

“我们建议WWF(熊猫徽标环保组织)”时说什么“他阴阳怪气”、“境外NGO黑钱”、“他看不起中国人吃肉”，看个标题都能对号入座，自卑的是谁呢？一群攀着进口货、软件的人，哦现在明白中国最强了 可以止步了 可以“科普多了去了 不缺你1个”的发稿

“1的碘化银”时他能说什么“哇中国技术真是太厉害了”，不好意思人家就一直追随中国技术。陪伴是最长情的告白，嘴上的『爱』，图片仅供参考。热度过=抛

你们的坚守就是对自己的同族“不惮”以最坏的恶意揣度和摘要，跟风或引风抹黑你以为“恨国”的人 ；鲁迅“恶意”是为了让人清醒团结，你们这样只是想消费人！ 对消耗品你不在乎，反正迟早有下一个

你爱中国，不为山区捐钱捐教、不为国军添砖加瓦、不为网络友好氛围、不去敬老院或社区义工、不为科学科普多搜点原文真相再“揭露”，你爱中国。 骂就是爱，觉得别人在骂是爱，你为反对他而骂更爱，永动机啊。
骂就是骂，有种你在法院“一锤”定他、让国安公诉他。

证据是真的、屁股是正的，只有解读“好恶”和判决“莫须有”错了。“正义” “爱国”，真高明。

打个比方，一条狗跑进你家，帮你干事解闷，它出去后成了邻居家的狼狗，也是干同样的事，因为你家既广又漂亮 受到所有人喜欢
然后七大姑跑过来骂你，我们和邻居有仇，怎么收留这样一条可疑的狗，说你是邻居的间谍、叛徒 举着石锤要杀你，这闲人没病是有啥？请问

原来被所有人喜欢是有原罪的。原来追求无关立场的真理“科学无国界”是叛国的、是屁股歪的。歪了几米？ 啥时候有某位“大V”开锤就是已歪到底，才终于被揪出了！你这么优秀，肯定是境外！ 呵呵

哦，原来研究技术的人，还需要嘴上嚷着『爱国』、贴出“对不起”三字，才能让你们这群从来没支持和关注过我们的，“自主思考”斥责者满意啊。

我们要真想投敌，也不是没那能力！脚踏实地的人只会用行动证明爱国、知错就改，因为表态谁不会啊？跟随热点谁不会啊？汉奸也曾“很爱国”呢，你曾选择了油嘴滑舌的人，就不要抱怨生活演戏演得累！


我找的不是考题的可行解，而是问题的最优解，更多问题，各种层面的最优、更优。
找寻比算法、思路更大的东西，竟然是语言。
这是我的语言，也是我对问题的进一步追问。 我想看到更多人的答复。

只是对业余科学人“有多贱”你们只会眼见为实，多片面(5s对+1s错)的事实都OK

这些人配不上『科学』，了解不到测试的创立者毕生做的事，对他只是我100 余者7、80分的胜利，获认可而已，打架打赢了而已。真相真理不追求，反正也能反转呗

赢后呢？ 你又为这“满”分的东西贡献出什么？ 你什么也不再探索只组合既有，什么也不质疑只复制集锦，别人就觉得你牛，胜过无数奠基者、无言付出者。

你管这叫学位、专业、专家 ，有牌牌，所以能随意指责科普界，“跨界瞎讲”谓民科、片面采样+各种修饰词语气词 叫伪科学。 被网民里最好辩的骂不打紧，最痛心被本应同道的“专业人士” 原文不搜时间不看地开喷，脚不沾泥 你最白最正确了。

这种满分人真受过科学训练吗？ 不好意思真科学界哪有机会上网发帖啊，人家都发论文博文的好不好

找一个人历史上只言片语的错误来批、来暗示其所有现在不值得，是一种什么行为，这些爱国人可能不知道。 我只知道没有这种人，中国早超英赶美了。这些人嘴里喊着爱国，内心却全是吃人，爱国只是一个无法邪恶的口号罢了；你是正，那他必是邪啊

找一个人的性格缺点和一切不合群、你不满意的点刁难嘲讽并依此欺负，这是一种“校园霸凌”。 只不过回形针现在确实足够好，他们只能找到2018年0.5秒的“料”、“NGO” WWF 的公益广告来恶意别名解读、没有“哇我国实用某原理真的好牛”的某期， 去霸凌它。

你们亲眼见证或参与了1场霸凌，本质和校园欺凌的起因过程并无区别，对受霸凌者都是莫名其妙的，而对他们都是“它这种人活着有啥意思”，对你们都是“苍蝇不叮无缝蛋”，对校方都是“别影响我声誉”。 回形针不按你们这些人的思路重点“回击”，今天的下场，他活该。活该。他信错了人

在一场霸凌里，不制止你就是加害者。

针对「科学无缺点」的追求成了它最致命的缺点。 一个为泛科普付出一切的人，莫须有的就成了罪人，还被言之灼灼、跨时空 跨段章 执法的，1句话1秒画“证据确凿”

他们把所有错归给自己，是为了你明白自己骂了什么原稿后 能心安！

到今天，说自己是无辜的、骂举证者“屁股歪”的、甚至继续强加主观恶意到回形针的，大有人在。 因为他没罪你就有死罪，非白即黑，一黑到头。 呵呵，霸凌里只有受害者敢猜自己有做错的可能的

至少他敢反思，你们敢吗？他敢和“反对者”见面，你敢“捏造”反对者找自己的茬吗？ 从0到1，是正无穷。从1到2，只是+了1层恶意猜测而已。我们创造，价值不需要数字来证明。我们有底气，不需要无限上升用辞自然容纳一切。

你们伤害了回形针背后“资本”的信仰，也让它看清了一些现况。幸好加害者不是全体中国人，只是一些好辩的网民

但回形针停了便永远停了，没变成某些靠怼人挣饭的正义斗士。 尽管什么时代都有投机者，也总会有内心有火、眼里有光的人。真实的规律，科学，是不会因人的内讧而消失或改变的，哪怕划去无数次、歪曲多少词，总还是会其他人在其他时间再次找出来，它只是这样而已！

靠不得这群当间谍全爱自嚗，盯「反转」找间谍的人。一群普通人越是追求，在他们眼里越恶

在某些人眼里，正邪白黑就是比对错和真假重要。 这些人才不管 事实真假=>判决对错=>执行 咧，他们可牛逼了， 知识真假=>执行 、 屁股对错=>执行 ，1人即法律 k赞即正义 洗白即收钱即邪恶 ，还有的直接坐地撒泼 “我就是想骂” “不够我拉黑” 见到=()=>执行 了uuu，还能 定罪= 屁股歪=>恨国=>定罪(歪度+恨国度) 无限上升。

或许它曾想改变什么、帮助什么，最后被想帮的人吃了，又怎么样，不过是潜力或机遇，又不是仙人赐的超英赶美，于中国何加焉？再等10年便又有“屁股正”的了，如回形针爆火那时一样

这场仗，赢是为何？为驱逐间谍。那么每个正义斗士一上场就能看到说着他们听不懂的语言的“外国”“间谍”时 他们已经输了。只是发生了一场骂战，无论是平是胜负，骂就是骂。

你听不懂未必是“洋人”做作，大团队多出品仅理论未必是“恨国”诱导 。回形针只想为科普事业奉上一切，不是观众的观众们却在威逼它“该讲什么” “不得做哪期”，傲慢的是谁。



书引标类型 物类例物事
储例况标物 既可未终定 公私族组内
事量变恒记其中
判重复是空则作?

窍：书物类 物定内 事判看滤序组归  同名多义 部分求值 类实例

物事:inner class, 双主语扩充(函我), 对何<我>
恒:inline reified(or in-out)

利用中缀调用“自然编程”在所有没new的OOP 甚至只要是定义式语言就可用，但绝句给了一个既不“命令”，也不“hack”的编程方法，它不是优雅，而是所有语言都未曾尊重的，编程与生活的质朴本身。

道生一(言于名)

古人曾说，「言必信，行必果」。 表达必能传达什么，动作必要意义明确，这是绝句之道。

言的意义是从几值算出1值，从 真假空、1 2 "3" 这些具名量里，求得其定义域(类型)里的其他值。算的过程称求值或规约(单步执行)，因为参与的都是字面量『名常』，和小学算术一样 给出结果就行

『名』给了负数和浮点小数意义，相同算式在(变量名)的值域不同时，表现出多种功能，同名多义，“多态”。 名是名常的扩充，它依旧带有类型，却可以随意取值，内嵌在代码文本，或来自文件夹、终端输入、表格、网络……

绝句「恒」事/量 允许尽量在编译期计算名常，缓存其结果于代码。 编译或解释，在绝句的界限很模糊，编译就是生成代码的解释，解释就是求值的树深先遍历。 编译只是把能确定的固定下来而已

『名链』

站在表现力的高峰，语言反而消失了。 所以为语言定义新用途，才是设计者该做的事
如果继续做语言人、黏合得太多，只能让语言能力下降，令其变成问题

计算机能让空想变成现实，编程是探索符号和现实的关系，甚至不要符号
普适和具体朴实是不冲突的，『爱』就很普适，却能让人举出无数例子，作稳定统一的区分

一生二(言或句)


二生三(段于体构物)

三生万物。

律B扫： PE/ELF dll和函数表(启动)hook  内存区-数值/增减搜索 地址读写锁

//Layout 为{}或:\n 缩进块, :语句; 提供IDE导航 asig({wsN,wsUp})。p果.lay=[item..]
lay=(open=":",item, sep=";")=>p=>
//逆波兰算符重排 1+2*3=1 2* 3+ ，在 a=1+2*3 里(=)最小 层次最大，若有 (a=1)+1 大含小则在 P.fde 加括号
op=(item,t)=>


el/prop/Eqv  Only1/emet/time-VecN-anim $show,edit,canEdit
makes(sort),make n-变 wOp[acty
tapup计时/连线,移窗(过程), 绘画擦, 大小拖影; 色彩scroll substr 队列 彩方
::before{pad} , 左越'/'向 越快，到顶点可以下滑

require("vs/editor/browser/services/abstractCodeEditorService") //listAll(). Did,activate,ctx,Dispose..
ce=x.getActiveCodeEditor();$('.modified.editor').onclick=()=>ce._paste(1,'\n')


分形树  BSP: quadt kdT BVH(图码 https://zhuanlan.zhihu.com/p/374748734 https://blog.csdn.net/air_liang1212/article/details/105520107 https://zhuanlan.zhihu.com/p/114307697
i++ +i
#define SQR(x) x*x
a/=SQR(a+b)/SQR(c)
char[5] s="hello";//or 6 .不能整体重赋值，但能{""}初始 或memcpy
#pragma pack(push,1)


## 数据与行

绝句的常量语法类似 JSON

### 改写操作

队列和栈(像电梯满员后进入先退出)

### 解构

建行()带号 去看，[是x i]
建表()去看，[是k v]

要改，建表()。
要跨线程，建表()。

建序表()去慢查

## 语义类型

解决问题时，先剔除所有名词和重复，找出『基线问题』，问题就变成基线的特例与重复。 以这种视角解决问题，自然就解决了所有同类问题、规避了大量潜藏的未来问题

如果只是对每个解题步骤选更好的命名和写法，能简化并表达更多，但若以更大的思路定义整体问题，明确而优美，会简短的更自然、更灵活

绝句的核心在句、句之上构筑一切，不是字词语法 i++ ++i 的离奇问题。

对编程的这种理解下，“语法糖”的甜咸、简短与否并不是关键问题。因为语法之上才是步骤，步骤上才有算法和应用软件，绝句找出一些通用工具物，在编译期特殊处理。它们代表的并不是语法的简短，而是思路的直观。

可变量、值最新、懒、同一、其一(与跨平台、试)

跨平台的要点是，能根据平台条件执行代码(C 用 #ifdef 实现了这个)、能提供和封装出平台特定的API(Kotlin 以“跨用源码集” expect-actual 实现)

绝句的方案是，平台=基础API变量集。不分出源码集(不同平台物/类编译期定义是可同文件使用的)，因为它倡导所有平台封装出通用API 供大家使用，源码集的不同只有API封装者需要操心

共用的源码占主体，平台的不同以 `若平台属于某类，平台去xx。`  差别提供

恒量 平台：其一<安卓“包含 Android 特有的API全局变量”、Win32>

类例 共同事量 安卓 为

## 大结构

需例物类型处，不用写 `某例物的xx`，提及名字就能使用

例物 数据包码：例自编号 为
  收(0x01)；发；重发

读 写

说("%d %d" %arg(1、2))

组<读文>

事会以 名：类型(=默认值) 有些许参数(称作类型签名)，其前也可以有主语(这种事被称为方法 但绝句只说是“人的事、人去吃饭”)。

事 人.吃饭(装饭：碗、筷：筷) 为
  重复若 装饭的满不是0，筷去夹(装饭、我)。

事可以抛下异常，这相当于每事+1个可空“异常?” 返回值，调用方检测到异常不空时直接返回，除非在 尝试……接迎 里。一般用 `试，文件()去读文。去路(「+"ok!"」、"err") ` 简写或 `尝试，文件()去读文+" ok!"。接迎异常，"err"。`

`试，抛下错误() 去作<数>。 去“取否(1) 取否“则抛” ”取?其令为，。`  ，另外， 试过::去化其一“Either<Int,Error>” 可以让编译期的简写 变得更函数式

试，。去化其一 去再试，。试，。去另试，。

若有一大堆要试，可用“Promise.all” 待去取全()、待去取一() ，待<> 是基于断续的事 的运行期结构，类似 Promise 与 async/func* 的关系

对何<TE>【内联若判句】的恒 况物 试过
  物 成
  物 败
对何<T>恒事 试(可错：函1<T>)=尝试，试过.成(可错())。接迎异常，试过.败(你)。

【隐式等同】量 =同一

‘在如 `若，1。否则，2。 +1` 的尾表达式上化简，为[试过] `试，错了()。去取否(1) = 尝试，错了()。接迎，1。` 基于「x属于况物.某」服务’
标物 内联若判句

‘给函数式爱好者准备的。 [Prelude.Either] 注意绝句里没有 Maybe(Optional) ， `(空作<数?> )?其另为「+1」空则0` 就是编译期可空链’
对何<AB>况物 其一 为
  量 左；量 右
  事 路左；‘waySideB’事 路右
  事 路
  量 翻转
  物 左()：其一<A、断止>
  物 右()：其一<断止、B>
  ‘试连接左面’
  事 再试
  ‘试二者首个左面’
  事 另试
  “针对左边的并举”
  事「+」事「|」


Eqv<A,B>(cat:(A)=>B,cut:(B)=>A): flip map fwd bkwd static pipe each noOp fmt join caps caps0 int num opr add mul digi(10) kv json xml b64 url
‘B是A的一个表示，那么[拆]是可能报错的。 像 Python 里可以有 同一<str、bytes>(「它去encode()」、「它去decode()」 )去拆(建组(0xff)) 就是解码，[拼]就是序列化， 同一(数::去化文、文::去化数) 一样。’
对何<AB>物 同一
  量 翻转
  事 拆拼“utf8.cat("abc") ； istr.recat("0", [+1]) ”
  ‘仅在B上(A=>B 时)操作’
  事 仅右；事 仅左
  事「+」

同一<数、文>(文::去数、数::去文)

特称参数

『筷』没什么可多解释的，在后端开发里有大量这种“名字大写=其类型”的无用定义，类型签名里不写，以『此筷』引用

事 人.吃饭(：碗、：筷) 为
  重复若 此碗的满不是0，此筷去夹(此碗、我)。

不定长

不定长包含0项的情况。

事是

【颗粒化参数 2】

事[公式]

>此设计是简化 Go 的 (a, b : int, c : string) 同类型连续参数；但不能指定类型

因为有特称参数和默认值， `:User, a=0 b: Int` 就会很难读。如果有大量公式要写，Python 弱类型语法都会显得臃肿

[公式]参数 只能是单字符，随意空格，可以有默认值；类型由默认值或 `对何<> 空=数值` 别名指定

事 fib[n a=1 b=1 c=0] =若n是0，a。否则，fib(n-1、b、c、a+b)。

显然，这无法为前后端开发服务。如果你有大量同类型参要传，可以用 俩<数> 仨<数> 值域<数> 更有语序，绝句「恒」会保证内联0开销


要设计一个「物」即 “Java class”，只需把前头「事」字换成「物」，它的参数们，对外部就是可读写的。

事 某俩(：数、：文) = 此文+此数去文

物 某俩(：数、：文) 为
  事 受调用=此文+此数去文
  “^某俩(1、"") () 就可以调用，但一般造物不是为了有() 这个语法。 然后你可以加公开成员”
  量 num=此数
  变数 i 初此数

如果你不喜欢写简单，可以自己把「造于(made)」 “Kotlin constructor, Java 与class同名函数” 写出来：

物 某俩 为
  量i：数；量s：文
  造于(：数、：文)，i=此数；s=此文。
  造于(：文、s：文)=造于(此文去读数、s)
  “没有 constructor(s:String):this(s.toInt()) ，只支持 made(s:String)=made(s.toInt) 和 made(s:String): say("parse int"); made(s.toInt) ”
  事 受造 为
    说("__init__")


谈到构造时先计算，这有个“很甜”的错误示范(Java 9 里 List.of(1L) 就可)：

List<Long> f(){ return new ArrayList<>(){{add(1L);} }; }

事 f=$1()
其中，
  物事 $1：ArrayList<Long>() 为
    事 受造=add(1L)

一般要这样：

物 某俩 私下的造于(：数、：文) 为
  造于(：数、：文)=造于(此数+1、此文)

  变数? n =晚设 “插播一条 lateinit”
  事 onCreate 为
    n=1

绝句里「变」的类型写在前面，且不可自动推导！ 绝句标准库提供函数式风格，避免“求和” 建行(1、2)去叠「+」 和“for循环” (1~2)去看为「+1」 等被显式写出； 而「物」里可变量要这样写：

物 俩数(a：数、b：数)
物 改俩数(变“后随都可变” a：数、b：数) “如果可变量并非都在后面，就只能多加 造于()=造于() 了”

另外，含大量「量变」 的东西里可缩写。 主要是体现整洁，不能缩短什么

量，a=1；b=2
变，
  a初1
  b初2

绝句里一小片代码写得「短」应该是贬义词。尽管你的事量写得很长，如果它能使更多文件里、不同时期的代码，做到更直白易改、协调统一，这也叫「短代码」，只不过要以项目的整体视角，才能看出这种短。

『晚置』 是一个『可变量』，相当于 Kotlin 的 val by

恒例 晚置：可变量 为
  私下的变数 n
  私下的变真假 成=假
  量 值：数 读，
    若成，n。否则，抛下 断言错("lateinit n 尚未初始化")。
  写，n=它；成=真。

  “也可以参考『另我』 、『句位』变量”

这些会被「恒」内联进对 `变数? n =晚设` 的读写；绝句『懒』 『值最新』 『可变量』也是如此，如果始终被「恒」物事量计算，就不会产生运行期开销；但即使如此， 建行<懒<数>>() [0]的值 这种混淆编译期运行期的东西也是可行的！

特别地，“继承自实例”

物 改数(：数)：代者<数>(此数) 为
  事「+」(另：数)=另-我

使用了 `恒事 受继承(：句物<任>)` 这个钩子来生成代码，修改继承列表、添加模板成员，绝句AST（语法树）对外是完全公开的。

## 人称文法

>我/亲、它、你 在绝句分别代表 OOP（面向对象编程）、FP（函数式编程）、作用域简写名

「我」的初始化是 OOP 的理论要点，无论 Java,Ruby,Python,C++ ，new T(arg) =分配一块T大小内存+调用构造器以(arg) ，它实现了继承也服务于多态（同名多义）

T的所有亲类(super class)构造器都优先被调用，因此(仅含在构造器)访问可再定的事 容易用到被子类再定还未赋值的量，而 super() 调用的顺序也是 Java 的头疼点之一

比如 Android 的事件周期(lifecycle events)就是拿 OOP @Override 实现浏览器监听函数队列(仅有1 onclick 时实现多监听)，绝句不推荐使用类似方法滥用面向对象。

建议使用单继承/实现接口 和事量的完全再定，像组合1个“分段执行”函数、暴露其局部变量一样构建1个「物」，因此绝句里物/事 的语法很相像。这种方法比单纯的 OOP 聪明简洁，比生硬的 FP 易读严谨

绝句是混合OOP与FP的多范式编程语言，追求简洁明了的同时保证严谨高效，既理论且实用。


绝句推崇不纯的函数式，也即“0复制”、允许改写，而非半复制的新建数据集，这更类似定义式编程（尽量只写要做什么，不写具体步骤）。

除了 去看为，它+1。 的逗句文法，绝句还支持不提及变量“它”的记法

去叠「+」
去看为「+2」
去看为「名」

必要时为了清晰性「」是和逗句可互换的，如 建行("ab"、"cd")去平看为，[文] 文去看为「它去切以("")去接("啊")」。


在这两种语法中，你 指代若/判表达式 最左，直到([] 的) 访问或"()"的项，就是说“你”默认只是取“变量路径”的值：

若你a[0]是1，回你。

判你a[0]存，
  于0~5，你+4。
  于5~9，你/2。

和 Kotlin 的“作用域函数”有点像，但系统解决了可空链，语言类型与表达上的隐患

user?.takeIf{it.name.length>2}?.let{return it}
user.passwd ?: return //必须有密码

若你(user)的name的长>2，回你。 “不存在 takeUnless 等歧义表达”
user的passwd 空则回 “无 void=Unit 值”

空则 可后随1个语句，那样它就在语法上不能被表达式包裹。 Kotlin 允许 `listOf(break,continue,return false)`
可能是为了能写 ?: return ，而绝句里 void 就是类型“空”，没有“Unit 返回值” 也不允许写出来Unit类型，类型“空”上没有任何操作可用，如“断止”(Nothing) 一样

当然，绝句的 `a?.let{return it}` 即 `a? 其令，回[^1]它。` 恒事内非局部跳转也是支持的，但无需作为默认

“你”也被用于「尝试……接迎」和双主语。双主语+记法+恒物 可用于设计更自然的表达，但在绝句语序的改写优化下，更自然的表达性价比颇低

接迎IO错，
  说(你的消息)

封装了 Java,Python,Node 的 Data/bin IO Stream RW 读写/二进制数值基础

量std=Sys.stdIOE
量std是(入、出、错)
出“printf文本/dump对象” 去退化“write二进制” 去退化“无buffer. Sys.tty是conio/termios 封装. 可以 reopen/readPassword”

类 B 为
  量 b：文
物 A 为
  量 a：文
  事 B.f()=(我的b+你的a) “我的b+我[^1]的a”

## 小结构

因为绝句知道[^]标签极少被使用，标签名是不允许的，停下[^1] 代表break上层、略过[^0] 代表略过这层的后部操作

重复回

## 类型系统

对何<你>

类型别名 点“座标”=俩量，真。
类型别名 色“RGB”=仨量，真。

带断言的类型别名可以独有一些扩展事量

物只能有1亲物，却可属于N个大类

## 绝句列

把常见语言的迭代器(遍历器) Iterator(Enumeartor) 里next()函数内联： listOf(1,2).filter{it>1}.forEach{print(it)}

var i=0
while(i<2) {val x=a[i];i++ //next()永远是下一项
  while(!(x>1))continue //next()是符合测试的下一项
  print(x)
}

如果 continue 那行在!hasNext() 时额外调用1次print() 该如何？尾操作（“回调”）对其是不可见的，但在断续函数里，尾操作默认是在调度器重启在await 的断续函数（以极低的开销），这给了列<T> -交回(yield) 实现的可能

for(it in listOf(1,2)) //建行(1、2)作列
  if(it>1) //forEach filter 的尾操作
    print(it) //是print

断续函数默认以内联(inline)实现。如此，绝句就能0开销的使用函数式列表处理。因为可令调度器执行 if(it>1)print 后检查缓存队列(如1次5项..)，它也兼容旧的 Iterable 接口

## 绝句恒

语义解构

绝句没有贸然以 LLVM IR 等“native” 代码为编译目标。未知生，焉知死？ 尚未摸清代码被如何组织，将其钉死在模板里，放弃了语言更本质更本职的可能

## 绝句记法

实际上， 作<>、 作?<> 强制转换也是用记法实现的。

##

Alt/双指 左右 运行或开命令面板、Ctrl/三指 左右 调试或看文档
Alt/Ctrl 上下(折叠选区或)跳到函数头尾/移动成员，Alt 上下上下打开三种快捷键滑移(行/复制模式)面板
Alt Shift 列选区；层叠例文档 /函数y图/节点图
菜单自定、滚条 编码

啄木鸟、看！绿虚带碟

绝句，语文之美
语言之韵，绝句之律「绝地」
继承自过去，组合出未来  书引
既定事，可未终定！
组事为强族事，私下更为公开
汉语标点，成事有余。 华夏拾遗，丈量世界 “”和建组行表令
行云流水，表万物相连；序末俩头，看数浮何异 储例况标,数值,改/队栈
文心雕龙，函涵读写「语义类型、变量代理」
条条推敲，字字如金「记法」  试,次,~,止 ,到,令 被
对何项，是泛此型「对何<> 事量是」
重定义，万事万物 「值名多态」
事其中，何再物事？「匿名内部类」
类之例，无需多言。「类例-隐转、跨平台」
不严谨，愿重复回回虔诚「函数式」 重复有意义，不重复有语义
初造于你的(我[^0])，亲和作同一
若判不尝试，接迎无未来；试可令其续，空则仍有得「值<断止」 交集：成员集比A,B大
不为更新潮，只为更明确「恒 和其中推导」
你倾诉与我，这次不等待。换我构筑你「列」

不应该强制要求什么更好，而要站在一切过去叠出的现在与未来的结合点，为两者都留出空间

从 思路=>代码，到 模型<=>软件 ，这一路何其漫长，却重构的何其有意义。
编程是探索世界规律，就像科学。但却要自然与人智、物理与数学在某个点完美相容，我选择陪伴人类从古至今从未改变的东西，烟火气的语言。绝句的语言。

可以说绝句是想要“革新”，但它也可以是一种守旧，对编程本质的守旧。

『数学』是定规则，编程和更物理的数学是简规则，找规律


听到他们说“中文天生不严谨” “不擅长‘编码’程序”，我知道有错的不是他们、不是我，更不是中文，我和编译原理领域的所有人都没做错什么，可我依然会不高兴，甚至会痛苦
这既是对语文表达于思考的重要性的轻视，也是对编程的刻板印象。我爱写文也爱写代码，对我而言简洁准确的文章它就是代码、而稀奇古怪死记硬背的专有名词才是瞎造的，为何“文理”争夺的如此喧嚣
现在终于有了，我的理想就是为中国创造一门谁都看得懂的编程语言，并让自己一直使用下去。

没有任何领域的尽头是数学。与其说是数学，不如说是会表达与代换，这些从卖菜到谈判都有人会用。
正如，分子物理不能解决生物分类的问题，做物理并不能取代对各层次生物学方法的功劳和智慧。编程属工程科学(或艺术)、数学属思考科学和艺术， 只是一个切实可复现一个虚渺抽象。
如果你真懂数学和CAD，不会觉得数学只是空洞繁绕的文本和“演算” “图示”，那些“深奥”得最浅薄的数学。

翔天 惊海(Android,Powsh) 无相

(1~2).seen{ say(it) }
(1~2).see{ it+1 }.Ln==mkLn(2,3)
"a b a".sepBy(" ").plus(mkLn("c")).join(sep=" ")
Eqv.sep(" ").recat("a b a"){ it+mkLn("c") }

切以("\n")
同一(“可能出错的”拆cut、拼cat)“比如parseInt--toString” “is just Equiv<AB>(from:Fn<B,A>,into:Fn<A,B>)”

同一的 分隔符("\n") 去拆拼(歌词)，序反()。

同一令，分行+前缀("  ")。去拆("")

量，落距=100；落时=10
量 落字=

事 新一批

时每(100)
时延

对称窗 动画与交互、对何<>空=数值； 事 灰度[RGB] ；Vn(3)* ·

赛跑编号、分屏墙、空调回声、(挥手计数)定时调度、 边缘检测、argRelExtrema /人脸识别 LINC /文本格式/算法

JueDit 波动队列渐变

lvABC
A - Linguist for Cmd/CLI(ANSIcolor,.) pages 命令行/交互终端页的语言家
B - File format IO, C struct*[] like FFI 文件格式IO与C struct*[]内存FFI
C - Text format(Java,SQL,JSON,.) tree and highlight-textpos 文本格式 语法树+高亮 行列位置
Vecr - 2D(rot&len) or VecN bulk +-*/ helper

从 Basic,Logo “对话框/Form输入格编程”，那种软件解决的，例如不区分大小写（s大写,s小写 存一 它==s ）、模板引擎"".split("\n").map(s=>`一行模板 填${s}`).join("\n")

LibreOffice(xx.fodp) 要是创建一大堆仅文本不同的页，就得不断dup 某页并填充（按键精灵直呼内行），如果是程序员用 XML 选区模板，所有ID又要自己累加，这就是老时代“API绑定-点击时调啥查啥”一样的应用

程序员不该花时间弄“界面代码”，如果你能把所有用户操作固定到白板时间轴上，你会发现所有操作和定制件都只是给函数提供数据而已，还觉得UI对性能很重要吗？ 我们不应想什么写法更快， 而要努力降低UI的代码量 提高适配和统一功能，节省程序员和用户的时间，是程序的UI唯一的目标。 要知道20年前Basic那样对话框和Form 的UI 还是主流、拖拽面板toolbox 都很罕见，它进步得太慢了

用一条线调整 声音的响度、音高，声音也是震动着的线、播放声音像在颠簸的路骑自行车， 线和 x=0 的交点这单个值如果动起来，是 t=0~1 ，而这个值放到物体的平移、透明度，同时放到xy轴俩量，就成了动画，依然可以在2点间用线令动画线缓动
这个值放到像素图2点间距离，就成了渐变着色，像放在时轴编辑器里的视频； 每时刻的声音、每像素的图像，是由左右声道、RGB颜色通道 构成的；定好窗口期，用滤波、EQ(均衡器)等频域处理 可以修正噪点、噪声；用卷积可以检测边缘等图像特征

系统声音、窗口混成、GUI绘制 也都是这样，由分量叠加出整体量；无论随时间、随距离，尖锐、平滑，连续、离散 每行固定宽(2D)，信号就是线、是波。 可以用遮罩和包络去混成、微调——同样在『绘制』 可以用笔或橡皮擦

机器学习只是拟合两条线，从有限的采样推无限长线的所有点吗？ 神经网络只是可按梯度逼近参数最优的算式、程序吗

若说(数学是联系的科学、物理是变化的科学)，绝句是描述的科学。
描述如思考，学习如关联


分不清常量名、final/“宏定义”、字面量？ 只是编译期有「恒」定取值，能直接算而已。 元编程，不需“模板”

别再混淆“列表”了，看看绝句断续『列』吧！
a (b (c) ) => (b c) (c a)
(a _next=it) Iterator

“在非断续事里，调度断续任务”
造可断 接续 接续抛

律Arg 律Bin 律Code
PLNK ALGm

我可以选择抛弃：
要么做好，要么不做，若做不好我会去选择合适的路；不会一面不合适一面强行往上堆，那样不是完全没好处，是很不值

上帝在为你关门时，也打开了一扇窗。如果人走不过去，就让鸟飞出去吧。 哪怕普遍无法相信、哪怕人都不在乎，只有对真理的这信仰，不需要任何证书，不关心奢侈、热度、智愚、历史和旁人等一切“知识”。
为各种细节的“更”字而夜以继日的本能，才是做学问的人最可贵的共通点。

我学的越多，消耗的反而越少。 就像科学，所有进步都能在之前的解答上去构建；或许一时间你觉得很乱

知识只是知识而已。信仰科学、认识规律和缘由 始终在帮助更多人过得更好，它不能分辨所谓层次，也不一定带来幸福；但这基础，一定给有选择权的人新与确定

我缺少识别和计算的能力，但有代换和归纳的能力；换句话说，不能从简洁的规则构筑出解法，只能转化问题和既有解，没有那种直觉和理解力。 这可以说是差等生，因为能解似乎自然就有我的能力；但能力本身其实就是用途决定的。

如果说所有设计都是种「发问」，绝句为之所存的问题是什么？ 程序与数据、生活与代码间最直观的联系是何。这是绝句的回答，也是它想传递给你的问题
成为优秀的程序员除需夜以继日在实践，灵感和执着的“偏见”更不可缺。 不破不立；再海纳百川
绝句是我对「计算机所能」的理解，可在它的世界里，仍缺少许多热闹、许多答案。
作为绝句的第0个狂热粉丝，我诚恳地邀请你，把这个世界你爱的某个角落，以你的视角和理解素描进「事物」的世界。这一份不同的观点，将能带来如虹的未来。
就像页首示例[频谱]，不存在没用的频率。你不必一定要发最尖或最沉的音，选择最能与之共振的诗题，展现属于自己的最强音。

绝句不是「后现代」，也不想引领未来，它只是让计算机科学一切的过去，平平铺在这待装饰的舞台。

你本不必如此优秀，才能寻求真理

创建一个好的编程语言，是要统一人与计算机能解读的表达；如果二者有先后，人必然是优先的，但这种“人性化”才是最难的
计算机它不像人，大家生下来都能理解“你看到谁，做什么” “你唱支歌”，电脑什么都不知道。它只能用多层数学统计 去学习、预测，这还是“AI新技术”，当然AI乃至机械臂都比慢且窄的人力好
它无论什么领域都需要程序员给一个概念，“反射弧”。语法只是语言的身体，这些弧线之间的东西才是语言这个『人』的灵魂。

你可能喜欢一些非常“甜” “短而精炼、技巧强”的语言，就像做派“傻白甜”的人。“用法”（语法和命名风格）很简单 因为程序任务就流水线，但是她的灵魂 她对多样需求、性能 可配置 可复用、对代码维护的理解，你只有路遥知马力
绝句无论语法和标准库都改了无数次，砍掉过许多自认为很革命的错误设计、也做过一些大胆的专断选择。 它添加许多，却渴望更简单、更贴合事实。 它设计的越多，人们在乎到、念叨出的反而越少，我希望句有这种灵魂。


Kotlin,Java C#, Rust,C++, Python, Go, Scala Haskell 某个片面的设计思想、范式在绝句都可见一斑，绝句有原创也有“翻唱”。
对何<我> 就是(从未刻意去抄) Rust 既有的 trait Ord{ fn(..Self)} ，对何<数值>、恒 也是 C++ template, constexpr；事是、事[公式] 和看绿虚带碟 和事(逗句块)定义本身语法的“松散”是 Go,Python,TypeScript 思想的一点体现；类例、强类型同名例 是 Haskell 多态的系统性翻版(从未刻意。)；量纲类型则是类型别名和“参数检查”的联系
绝句也有许多“新概念”完全是与语言解绑的，比如从 Haskell 流传出的 Either(Rust,Kt Result) 在绝句表现为 其一<成值、败错>，概念性的“等价关系”在绝句是 同一<A、B>(拼“A=>B”、拆) 当然也“独有” 类例 隐同一至<B> A
绝句集合、作用域和IntRange (称作 定义域函数/值域<数>) 完全就是重命名重归类，没有比 Kotlin 或 Python 好，而 试,待,列(Result,Promise,Sequence)、读写形变性与reified,inline,by的元编程 完全是“移植”的

但，它的人称文法、记法，对面向对象“对象=强类型开放函数”、对物事(inner class) 等“技巧”更限制的解读 确信了它是有定位有观点的东西；绝句是，也不仅是“以语法和标准库”见长的语言。 大音希声、大道无名
绝句不想刻意去模仿什么，这些“类同”完全是从小线索一点一滴聚拢起来，成为一个整体

「恒」，这一个字就消除了 inline,const,by,reified,expect-actual C++ &ref,template,constexpr,decltype 等数不清的词和“元编程”概念。原来它在绝句设计稿中只是若有若无的“摸不透”成分，现在它可能是绝句语义里最重要的成分，try-catch简写、多平台、模式匹配解构 上都有它的影子

「其中」，让 Kotlin 没必要为“局部fun,typealias” 是否太激进而操心，也让匿名 fun=object 彻底和 inner class 同化了。这可能是绝句对 OOP 的改变上最不甜的一点，规避了句级语法的“灵活”

「你」和[^1] 却让句级甜得简单，消除了双主语的隔阂、takeIf takeUnless crossinline 鸡肋的高大上

有种说法我很赞成，教育是选拔，是淘汰赛，数字比人高做对比人多就被认为所有层面都是好的、善于学习和解决一切的，当然被宣扬出的人都是这样
可市场并非如此，要奔着100%去效仿比尔盖茨，哪怕你是学神，最多和他平齐，甩掉他后你又该效仿谁？ 打铁还需自身硬，硬的却也不是只有钢铁。
知识和计算完美无缺，缺的是“不严肃”对待的觉悟。不是优劣，而是有无。 100分做出120、120做出300， 比起标准答案，它追求只是新原理；优劣只能趋近，有无可以抉择。

Ace支持简谱/钢琴轴/歌词弹奏、支持多人V皮多场景演唱、粒子动画，对歌词和音高的支持很成熟
3个三点水的歌手V皮都很出戏


‘[w]项宽’
对何<T>(T：可序)
事 组<T>.切排(n：计、w：计) 为
  若n<2或w是0，回。

  L=0；R=0+w*n左
  重复若真，“[^0] 真该独立为事”
    n区=(R-L)/w+1
    若n区不大CUTOFF，短排(L~R)。
    否则，
      iC=L+(n区/2)*w
      令序(L、iC)；令序(L、R)；令序(iC、R)
      iL=L；iR=R
      重复若真，
        若iC>iL，
          重复，iL换「+w」。若iL<iC且 我[iL]不>我[iC]
        否则，
          重复，iL换「+w」。若iL<iR且 我[iL]不>我[iC]
        重复，iR换「-w」。若iR>iC且 我[iR]>我[iC]
        若iR<iL，停下。
        内存交换(iL、iR、w) “没门! 组<T>是无指针的”
        若iC是iR，iC=iL。 “iL>iC implies iL != iC”
      iR换「+w」
      若iC<iR，
        重复，iR换「-w」。若iR>iC且 我[iR]是我[iC]
      否则，
        重复，iR换「-w」。若iR>L且 我[iR]是我[iC]
      若iR-L 不< R-iL，
        若更小(L、iR)，
          sL添L；sR添iR
        否则，L=iL；略过[^0]。
        若更小(iL、R)，
          sL添iL；sR添R
        否则，R=iR；略过[^0]。
  若sL空，回。
  否则，
    L=sL去泡；R=sR去泡；略过[^0]

其中，
  变针，
    L；R “当前区”
    iL；iR；iC
  变计 n区
  量栈=改，建行<>。
  量，
    sL 栈；sR +栈
  
  事 令序(A：值改<针>、B：值改<针>) 为
    若我[A]>我[B]，变量集去换(A、B)。

‘无项宽w，比较函数[T]自带:不传指针’
对何<T>(T：可序)
事 组<T>.切排(n：计) 为
  若n<2，回。切(0、n左)
  重复，切(*晚 去泡)。若 晚不空
其中，
  量 晚“再排”=改，建行<俩<针>>。
  事 令序(A：值改<针>、B：值改<针>) 为
    若A大B，变量集去换(A、B)。
  事 针.「大」(i：针)=你[我]>你[i]

  事 切(L：针、R：针) 为
    量 n区=(R-L)
    变针，
      iL；iR；iC (L+n区/2)
    若n区不大CUTOFF，短排(L、R)；回。
    令序(L、iC)；令序(L、R)；令序(iC、R)
    iL=L；iR=R
    重复若真，
      若iC大iL，
        重复，iL右移。若iL<iC且 iL不大iC
      否则，
        重复，iL右移。若iL<iR且 iL不大iC
      重复，iR左移。若iR>iC且 iR大iC

      若iR<iL，停下。变量集去换(我[iL]、我[iR])；若iC是iR，iC=iL。
    iR右移
    若iR大iC，
      重复，iR左移。若iR>iC且 RC同
    否则，
      重复，iR左移。若iR>L且 RC同
    若iR-L 不< R-iL，
      若iR大L，晚添(L到iR)。否则，重复回(L=iL)。
      若R大iL，晚添(iL到R)。否则，重复回(R=iL)。

您好，有优越性的不是人，是人的知识和教养。 你可以不相信、容易恨铁不成钢，但请别随意否定与您八杆子打不着的概念，比如我就不会骂元宇宙。请注意算法或数学都和编程“语言”没半毛钱关系，大概您眼里单靠数学就海纳百川，就像川普说“我啥都懂”
没错，中文编程和您的国文水平一样空壳着地，所以您能把32行的指针扫描写成40行“充满重点”的面条代码，甚至原文有170行 天哪 都是些详尽却半懂不懂的变量名和注释。

您不会以为在长篇大论、0代码复用时用死长的名字会更易读吧。C语言机翻的难读，只证明白话文在表达混淆了取值&相邻的“指针”时，对其故作高深的内核反映的很诚实，不给你半分模糊用途&边界的余地呦

要是我写C，起码不会拿 char和void这种sizeof定死为1的东西替代 _Generics ；想想冯诺曼和巴克斯同时观摩你对SplitSort的理解，不把他俩气活喽：不省编译 又弱类型，机器改不透 同行看不懂。这边建议您直接上C++ template<> 如果嫌宏丑。extern"C" 也比 __cdecl 干净多了

当然这也不能全怪他，C在算法和多项处理上罕用，靠宏灵活内项sizeof也确实是没有规范。所以手算指针。C毕竟是1990年30多岁了，你2020也该别年少老气了。

傻子都知道问为啥没适合我编程的语种，就你觉得C9x一招鲜 霸知乎吃遍天了？  傻子笨到不懂算法，您机制到不懂傻子 横批：卧龙凤雏

