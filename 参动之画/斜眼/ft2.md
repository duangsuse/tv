你画过直方图吗？  `a.groupBy(key={it.色})` 里a是3个色球，按颜色每个投入x轴上不同的桶里。 想象你握着这3球，每个瞄一眼，再用不同速度抛向桶的列，它们便摞成一竖，仍等效原集合。
`Map<K,List<V>>` 是最好的描述，但K=数时 `List<V>` 就够了，只要颜色能有限编号。 频率就是x轴上可细分的“颜色”，某刻t各频震幅之和=原信号，动画t，以震幅降序从0点连线就生成以上。

音乐和声音都是波形，只有震动会发声，在xy座标系是 x=0~1,y=+-1 的时间%,震荡位 表成函数线。频率=音高,震位幅度=响度,模式=音色，
波形图(waveform)或.wav 文件封装了PCM(信号波定期采样)数字信号，是声音最直的表示；但为何电话、对讲机里的声音很细，均横器又为何有那么多竖滑条呢？
电钻声效和变音器的工作原理又是什么？为什么现在加速播放声音不变尖了？多亏傅里叶变换使频谱图可修改。

[Better explained](https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/) 有个解释：”它可以告诉你一杯水有什么成分“。 其实不如用颜色纷呈->颜色分层的鸡尾酒来解释，“折色”棱镜(红波长最长,绿频率最耀眼)也是，白光是由所有频率的可见光波构成的

就像颜色由“三原色”(或hsl色向-饱和亮)混合而成，复杂的声音是由不同频幅的sin波叠加而成。像画圆时x轴的往返，有 sin(0)=sin(0+2PI)。称2PI为一个震荡周期T，sin(T)+sin(1.2T) “同时播放”听起来就有点复杂了，实际上吉他拨弦、人唱歌即等效这样的叠加。
如果把声音分成“N频率”，就可以像色彩滤镜一样强化低音或高音，或者滤掉低震幅的“毛刺”频率 来简化文件(mp3,jpg原理)，语音识别也是基于频谱做的。
这也是为何声音和图像，两种风马牛不及的数据，都属于信号处理。其采样自现实世界，是xy轴上的线  x=t=0~2s ,y=f(t) ，比如 `f=汪汪.mp3 ,f=生成(2s,sin(x*音高)*响度) `。定f速增,x范围增空,震动变尖

现在我们知道 波形==频谱，知道波形是每秒44100个浮点1声道的数组 `[0,0,.23,..]`，知道频谱图(xy=频率,震幅)，但它俩咋对应？想想开头的“投色球”，那时从球的颜色确定桶位，但波形能分项？需给定线f,频率k，找出震幅P

`Pk=Int[t=0~1]dt*f(t)*e^-j2pi*kt` 是积分式。dt是“无穷”小量、j是虚数单位，这是FT Fourier Transform，输入1D信号则y恒为0
`Pk=Sum[i=0~N](1/N) f(i/N)*e^-j2pi*k(i/N)` 是计算机版，即 输入=时延buf=Array(N)，也切分 e^kt 缓存其 t=i/N 结果到i，这是离散DFT，通行的FFT就在其上优化
频谱只能图示吗？`f(t)=Sum[k](1/nK) Pk*e^j2pi*kt` 能还原处理过的频谱，这是EQ均衡器预设的功能

术语DSP(数字信号处理)。其中 `e^r=cosr+(sinr)j` 是欧拉公式（不是承太郎的Ora

```js
c={dt:.001,nK:30}
with(Math){DEG=2*PI,转=(r,f)=>f(sin(r),cos(r))}
律=(k,f)=>{let cx=0,yi=0,d=c.dt, t=f.pop?(f=just(f),d= 1):0;for(;t<=1;t+=d)
  转(k*t*DEG,(X,Y)=>{let[x,y]=f(t); yi+=x*X+y*Y ;cx+=x*Y-y*X}) //可缓存k*t个数据
  return[d*cx,d*yi]//k 也标明震幅+-和正统计/反还原
}
n=o=>o.length, newA=(n,f)=>{let a=Array(n),i=0;for(;i<n;i++)a[i]=f(i) ;return a}, just=k=>()=>k
//^律(k,[x,y]) 能还原波形  ^待会用于填充频谱
```

你肯定很蒙蔽，而数学生肯定想吐槽ij分不清，但编程里没人 `for(n in 0..5)` 的。
dt=.001 是细分音频数组 `a[n(a)*t >>0]` 好理解，离散就是能缓存e^kt计算，j即i怎么又是虚数单位(ii=-1,180度转)了？我们索性不谈复数(complex)了，谈物理吧。 __向量是0点连向xy的箭头，是方便算角度。离散是被“仅N关键帧”的连续__

历史上最初FT就是简单累积震幅差 `Int[t=0~5]dt f(t)cos(xpi*t)` ，数学的加入让它支持2D信号和自由dt精度。
注意到e^r的顺序是余正弦 cosr,sinr 吗？它从(1,0)逆时针，旋转点集时也是，像标枪手。__我这的定义里是 sinr,cosr 从(0,1)顺时针__，像钟表从 r=0~2PI 转回12点，因为——我不用复数，也不科普复数xy=real,imag轴，_数学生不需要看这种文、工程生不需要懂数学。这个我不接受反驳，请写更易懂的文以驳。_

差异：1D信号x恒为0，yi反映震幅 cx求和角度；即便你不知道2D旋转公式(xX-yY,xY+yX) 应该也能看出为何要两个数

可以把手绘路径视作点构成的折线，它是xy-t深 3个轴构成的3D图像，t=0~1，0度t0,90度t=.25*2pi。举起左手食指y，拇指中指是x,z=t轴。
它即“画圆时手抖”的线，找出大圆需+的震幅。`转(tDEG` 在xy平面只是圈，k!=1也看不出区别，但考虑t深，ty右平面=cos, xt顶平面=sin，它是t于(k)Hz的螺旋，因此 2D旋转t%后正是 +-1 内点与螺旋的差异，如果输入恰好是0,0宽1的正圆，路径t%点 t%DEG旋转结果— __0点转0,6点转6,... 会开始叠加而非互相抵消，在y给出一个震幅向量，这就是傅里叶的物理意义。__

有了震幅向量，以其 频率*震幅=动量 ；路径原点=不同频的动量(圈大小)之和，咱把累积动量每内点画成圆圈，而跟踪最外点，就成了傅里叶的可视化。 为何符号相反？

其实，若把I(0,1)旋转t*DEG ，xyt里它正是螺旋线，当然f(t)不会一直是I。从ty上看，它积了ft与cos(kt)的振幅距离，
反向时已知频k振幅l，用sin(k*-t)l 反着震(因距大乘积大)得原ft。输出y是震幅，那x是什么呢？如有 sin(t0+1.2T) 右移，不难发现y依旧能量出震幅，但向右偏了点，__所以角度是相位，距离是震幅。__

```js
//DFT:把 转(ktDEG,(X,Y)=>.. 变多项式，即可乘 f[i],k转[i], k转=newA(nK* 1/dt,(i,r=i/nK*DEG )=>[cos,sin])，+-k 也可变为仅-k，另一半是反向量 。
简画=ps=>{
let N=c.nK,谱=newA(2*N,i=>律(i-N,ps)), /*内俩频动量*/a0,a, P=录点(),/*序*/f=([k,p])=>pLen(律(k,p))
谱=谱.map((p,i)=>[i-N,p]).sort((b,a)=> f(a)-f(b))
return t=>{
  a=L.map(v=>v/2);let l=Math.min(...L)*2*c.wImg, k,p;
  for([k,p]of 谱){a0=[...a];J(a,律(k*-t,p),(a,b)=>(a+b*l)); 连线(a0,a);a0=a} P(a)
}}

录点=(a=[])=>p=>{a.push(p); a.forEach(p=>g.fillRect(...p,3,3))}
连线=(a,b)=>g.fillRect(...a,3,3)

J=(a,b,op)=>{for(let i=0;i<2;i++)a[i]=op(a[i],b[i]) ;return a}, pLen=([x,y])=>Math.sqrt(x*x+y*y)
for(let k of"+-*/")J[k]=eval(`(a,b,op)=>a.map((x,i)=>x${k}b[i])`)

eAdd=(e0=> (s,op)=>{e0.innerHTML=s;let e=doc.body.appendChild(e0.firstChild); return op(c=>e.querySelector(c))}
)(doc.createElement('eloader'))
布=e=>{e.width=e.offsetWidth;e.height=e.offsetHeight;return e.getContext("2d")}

svgPoints=(u,q=u[0]=='<')=>eAdd(q?u: `<svg><path>`,e=>{e=e('path');if(!q)e.setAttribute('d',u)
  let l=e.getTotalLength(),L=pWH(e),p//center to (0,0),norm to +-1
  return 切分(t=> J([(p=e.getPointAtLength(t*l)).x,p.y],L, (a,b)=>a/b*2-1))
})

/*2D“画圆时手抖”折线->频幅谱->动画t:各频分量t%的0点差->累积在屏心,幅wImg*whMin 连线不同频圆圈:以len降序
(nK个频,1/dt次割圆)*/切分=(f, N=1/c.dt>>0)=>newA(N, i=>f(i/N))
pWH=o=>{let f=o=>[o.width,o.height]
  return o.width?f(o):f(o.getClientRects()[0]) }

doc=document
eG.style.cssText=`width:100%;height:100%`; g=布(eG);L=pWH(eG)
g.strokeStyle="#888"
c.wImg=.2
{//
a=svgPoints(`M84.73,19.64h41.09c-9.82,40.72-16,67.27-16,96.36,0,5.09,0,44.36,14.91,44.36,7.63,0,14.18-6.91,14.18-13.09,0-1.82,0-2.54-2.55-8-9.82-25.09-9.82-56.36-9.82-58.91a283.69,283.69,0,0,1,7.64-60.72h40.73c4.72,0,16.72,0,16.72-11.64,0-8-6.9-8-13.45-8H58.54C50.18,0,37.82,0,21.09,17.82,11.64,28.36,0,47.64,0,49.82s1.82,2.91,4,2.91c2.55,0,2.91-1.09,4.73-3.28C27.64,19.64,46.54,19.64,55.64,19.64H76.36c-8,27.27-17.09,58.9-46.91,122.54-2.9,5.82-2.9,6.55-2.9,8.73,0,7.63,6.54,9.45,9.81,9.45,10.55,0,13.46-9.45,17.82-24.73C60,117.09,60,116.36,63.64,101.82Z`),
f=简画(t=>a[t*n(a) >>0]),t=0
setInterval(()=>{g.clearRect(0,0,...L);f(t+=c.dt)}, 1000/30)}
```

@3b1b 的视角也是如此：0,0画圆 t%周长的半径=sin(t)，即sin缠绕在0点为中心对称花(圆心式 r=sin ta)，正负抵消无振幅，但若频率k*t%正好合适，会发生“共振”-竖线正好量出sin的波峰

圆圈大=震幅大，速度快=频率快。如果图像较毛刺，中频信号会略广，如果图像很圆，如五角星，几乎是1圈在转。 频率震幅也能再”变换“—相对0,0长度=震幅、角度=相位
对人眼而言色相位比振幅重要，而声音频率即音高，常Q法就能从波形检测八度音。

```js
//余下代码
画风={S:'.stroke',F:'.fill'}
画=(ak,...a)=>Function(ak,fold(chunk(a,2),(s,[a,b])=>s+
(([_,c,k])=>`G=new Path2D;G.${k}(x,y,${b});g${画风[c]}(G);`)(/(.)(.+)/.exec(a)),'let [x,y]=a,G;'))

fold=(s,f,ac)=>(s(x=>{ac=f(ac,x)}) ,ac)
chunk=(a,N)=>f=>{for(let i=0,i1;i<n(a);i=i1)f(a.slice(i,i1=i+N))}

连线=画('a,b','Farc','2,0,DEG', 'SmoveTo(...b);G.lineTo','...b','Sarc',"pLen(J['-'](a,b)),0,DEG")
```

你可以 Ctrl-Shift-C 粘贴代码到空白页html试用。

```js
`<canvas id=eG><script>${$$('code').map(e=>e.innerText).join()}`
```

我也说点碎碎念吧，当然我一大专生也没啥好抱怨的，躺平吧。

这个讲法是因3b1b确信的，但我还是不想看原视频，因为太长也没代码，不同的是我无视了复数，只用2D旋转解释“统计”咋完成。因我是编译原理/几何绘制的

或许这样很不严谨，cos,sin换个位，只要把所有imag,real换“代入”回来就标准了，我没有预见有音频应用因此更难写的可能，况且他们已经够难写。以前我觉得这很了不起，
现在我很看不起让它们难写的这些技术(包括卷积vs加权求和,一群人讲不清何转)，
什么离散连续eij念得我头都爆了，3遍啊3遍，一大篇图作得到还有趣，我画不出，可惜缺乏意义 图例也没代码也没，其下评论学信号处理SP的懂了，但我不学信号处理

物理2D旋转定义无辜躺枪，因此我也不想重序公式(但看到“虚数”yi=Xx*Yy 变简单,又值了)。t=0~2pi (sint,cost) 是一个圆，在它上乘 (sinr x,cosr y) 在3点方向 y会拉伸，这不叫旋转。
[向量旋转矩阵](https://www.cnblogs.com/fangsmile/p/9324194.html)是从0点右上两个三角形叠加：XY=cossin r, xX-yY,xY+yX ，这个要几何来讲(两角和差)，但傅里叶对它的利用这里结了。

__我看了20多篇网文，就想解决问题，这些文章却贴一大堆图示和数学“专有”概念，暗示我只要原原本本翻译就能运行__——其实我早译过。重复给我的工作制造许多无聊的麻烦，我不太爱听正确的废话。我要你三句话内说出概念模型和为什么要计算、有何不同，与线图示对应；我要立刻兼容无数能表达为线的输入出，不要扭来扭去指代不明的符号。 什么理论不可求快 不可易说，我才不听，好不容易跨界写点码，就受公式折腾，荒废了我5天，我迭代4版才写成文中代码，如果说我得到什么比此文多的经历，对不起 像看画廊一样。我不懂艺术。

一些专家写的ωκ我一个字都看不懂，我知道知识无限，但作为编程爱好者，我没功夫浪费在说话上，和小孩子过家家一样的名词变式 不成章法语义缺失。 这不能全怪文章不都如[这篇](https://pythonnumericalmethods.berkeley.edu/notebooks/chapter24.02-Discrete-Fourier-Transform.html)明确简洁，但我前3天都没厘清Pk还是Pl(因为可视化的代码内 谱以震幅降序)，几十文章啊顺序都不清，我真不想重写个好看的就浪费一周(没错我就想认认真真做个应用,不想学习)。

上面批评都是真心的，但放下这些心平气和的说。

为什么3b1b的视频用拟人π呢？或许是象征学术圈吧，大家都是一个半圆，让对方完整，所以才能构成圈而非沙堡啊。
为什么我要在没头脑和不高兴间二选一呢？我在工程时是严肃的，但科普时就可以很随性，自由选择语言侧重。因为科普并不是需要大师精英来完成，自然而然去做就行啦

我一定会努力追求他们的高度、遍历技术之广度，哪怕是用自己的方法，哪怕高数没有及格过；
我不想断言它们或自己属于什么层次，因为，至少每一步都很有趣啊！
