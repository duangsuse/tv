# 怎样写一个解释器

面向：会编程、懂区分函参/作用域和执行顺序，以及 `[] push pop`、`{} [k], [k]=` 的人
澄明：尽管标题是解释器，为了完善理解也穿插不少编译原理-求值法相关的内容。用JS写的迷你调用语言支持惰性,闭包和算式

词汇|中|英|意义
AST|抽象语法树|Abstract Syntax Tree|由文本加载.便于转化(求值,显示,代码生成,类型检查)的IR `Node{Val eval();}`, 也称程构接口PSI
Expr|表达式|Expression|有值的AST项，和Stmt 都属可执行，如 `1+a`,`q?a:b`
Stmt|语句|Statement|无值的项，可用 `{}` 组合语句(也称块Block)，如 `if(q)1+a;else break;`
IR|中间表示|Intermediate Repr.|可以是深先求值树(AST)或SSA形式。后者更便于优化(重复表达式消除,常量折叠,死码删除,.)

程序是由变量和常量构成的，JSON/YAML等是由常量构成的。 程序执行获得值，而编译器把未知量对应到参数|求值栈位置，给计算排序，并生成class文件-javabc等可执行格式，可以加速重复执行的热点代码。

JS-V8 和 Android-ART 就是采用了即时/预先编译(JIT,AOT)的运行环境，ART的输入是Java字节码由dx求值栈->变量号后生成的smali码，但它仍可继续编译；所以，编译器、解释器不是相互孤立的，编译器和普通(文本)处理、结构重写程序没有本质不同，解释器甚至VM也只是直接执行了而已。本文从文本解析&执行入手

解释器一般是AST树遍历器(tree-walker)：深项先求值(归约)，`(1*2)+(3*4)=2+12` 再计算同样收2数值的(+)，得到 `树的结果=14`。这个(+)节点it 同样可以被 `a=it; f(it); true?0:it` 组合，并由它们决定何时求值(如 `true?0:print()` 就不会显字)

程序从变量常量组织出计算式Expr，再由Expr|Stmt 组成基本块{} (在if(){} -else? 也使用)；再去构成无顺序的静态定义结构。而在脚本语言 `if(true){class A{}} else{class B{}}` (JS,Py,Ruby均可)是可实现的

看完词汇你们已经基本了解了 Java,C#,C 这类语言的定义/程序结构 职责有别，并不是仅有 `var (Name=Expr,);` 特殊。 .java 的内容一定是 pkg/import 后 class|interface 开头，1文件只有1大定义，.c .h 预处理拼合后一定是 struct|FnDecl|FnDef|.. 的列表，这也是IDE符号表的来源。

为什么我要讲大篇无关的？不了解外语者，亦不懂本国语言。知道解释器最能体现原理后，学习信心提升了吧？

语言的职责就是凑齐未知量，计算。 从汇编无结构编程、到函编FP、面向对象OOP，表述式和定义式 都是如此

代码复用(函数)和不易错性(严谨类型)之外。接下来咱探讨的主要是，程序真正的意义，即执行。

## 计算器

与其从分词或语法结构组合的角度入手，不如先看计算器怎么写

```js
```

这是 Lua (针孔语言.现常见于游戏)的中缀排序实现——把 `1+2*3` 改为 `1 2 * 3 +` ，在前的算符先执行

也看看基于S-Exp(Lisp嵌套列表)的写法

```js
```

求值栈和常见的AST是完全等效的。毕竟，由栈组织AST本身也是种「执行」、AST平展也是种「执行」

树的逐步缩小(规约)意味着转化。除了执行，代码格式化、重命名、类型推导与检查，都可以用这种方法来做。一般定义 `Node.eval` 在 `data class If,For,VarEq,Call : Node` 里覆盖；如果有多个操作，可以独立为

```kt
object Eval:Visitor<Int>{
  fun see(t:Lit)=t.constant
  fun see(t:Op)=when(t.op){"+"->of(t.a)+of(t.b) }
}
abstract class Visitor<out R> { fun see()... fun of(t1:Node)=t1.visitBy(this) }
data class If(val cond:Expr, val a:Stmt, val b:Stmt){fun<R> visitBy(o:Visitor<R>)=o.see(this)}
//{}是组合语句. Stmt
```

如你所见。多么复杂的解析器、分词-解析啦，最终也就是提供这样一个平淡到无聊的求值API，顶多在遇到 `var x=1; 或f内(a=1,b=2)` 时维护下作用域KV表；自动处理转化，例如 `Int+Long` 和惰性 `if(true, 0, print(233))` 的 print()可能不执行-即传名调用=自动转匿名函数

调用和 `if` 的实现是成熟度分水岭，它之下=操作多点的文本计算器。如果说 `set=(形参,实参)=>形参.forEach((k,i)=>d.set(k,实参[i]) ) ` 只看对列表处理和旧值保留的了解，`if` 的实现可以是作为控制流-那break,continue,return 怎么实现，for怎么执行；或者 `?` 表达式-实现方法刚说了，自动转函数+`d.get` 时自动执行(缓存结果)

你会发现JS实际上暴露了不少答案，比如 `function f(){return arguments[0];}  f.apply(null, [1])==1`、比如 `with({a:1})res=a+1; res==2` ，只要认识到函数是带参带return的代码块，写 `执行=(f,args)=>` 并不难

这只是对元编程能力、不依赖框架能力的考验，如果你能找到不带来阅读难度的、优雅的写法(即良好的函数习惯)，问题自然迎刃而解。我们谈点有意义的。

在javac里甚至靠深先遍历把AST化为栈，那么为什么栈不能取代AST？先问两个问题。

- `o.f; o.f(1)` 甚至 `o[k]; o[k].f()` 是不是中缀？

都可以是。算符重排支持右项基于中缀来读取，但应该让 `Item=chain(Item, One([".",Name,Call.or(NO)], ["[",Expr,"]"]) )` 这样由单项层读链，免查优先级表（这不是伪代码。稍后有chain,One 的定义），稍后o.f(1)表达为 `o 1 'f:1 send` 的执行序，`o[k]=1` 则 `o k 1 a.set`

实际上，old-school 认为语法必须遵从 LL,LR 就是因为左递归 `A='a'|A'b'`: ab, abb.. 的转化 `A='a'B ;B='b'B|''` 能实现链和优先级，但如下节[其他选择]所言，这不过是列表处理都能做的递归切分，打散了而已。因为其运行时的限制，有了CFG(无关上下文,仅状态号)这回事；在正常的前缀提取-return 解析器里，因为能很好融合各种解析算法、自由扩展文法，根本不需要。

- `q? a:b` 和 `a||b` 的不完整执行，以及 `{let a=1; a+2}` 作用域，怎么表示为栈？

不完整执行是求值栈的硬伤。树遍历器可以 `If:(tree,v,res)=>res(v(0)?v(1):v(2))` 但求值栈执行 q? 前就把a:b 俩子项先算了 --但编译器就可以用求值栈取代AST，为什么？因为它能把 `q? a:b` 化为 `q ?not:B a ?jmp:C b  c`，这就无关遍历顺序了；那么在解释器里，我们把a,b拿[]包住，令其由?判断，惰性执行即可。 --即Thuck,0参函数

综上所述，实际点写语言，基于执行栈表达语法树是完全可行的，因为语法树唯一的用途是基于嵌套结构，复现解析时的调用栈做深先树重写。`luaY_parse()` 的结果就是函数体信息-解析转化一气呵成，再由 `luaV_execute` 可多次地执行语义。

变量(name:String)比较特殊，它是关于当前词法域-即嵌套KV表的，和编译关系不大，完全可在解析期转为位置——可以是 j号参数/局部|上i层j号|全局表键k ，比如，`f=(x=>x); f(1)` 里1就通过 `arguments[0]` 传递，`just=x=>()=>x, j1=just(1); j1()==1` 的闭包j1里x是上1层0号局部，数据和程序的结合构成里闭包，也即Java `new T(){}` 匿名内部类。

嵌套表在函数式教程常用 `"a+b" eval(a, new Map(d))+eval..` 全复制，其实每层 `eval(a, oldVal={})` ，`x=1`时保留old"x"，退出时恢复即可；这也称动态作用域

>程序是流动的数据，数据是休眠的程序；好的程序反映其所处理数据的结构。

>闭包是无名的对象，对象是多动作的闭包；动词与名词本为一体。

>当我编程，我表达的是实现目标的必须品的缘由，而不是某种可能成功的途径

>当我写文，我从解释化简归约出名词，也给大纲定义语序和详略，不在任何语言说无意义的名词。我只看目的，目的即是方法。

如果因为只有Lexer(Scanner)会手写，而使用 YaCC,ANTLR 等 compiler-compiler ，会造成巨多麻烦，这也是许多简单解释器却能写几万行的原因。 Mivik/kamet 有能力写自己的正则引擎，同时也有觉悟把一个支持类型推导和多态的LLVM编译器写得非常普通，分词和解析都是手写。500行完成(这是比较经典的实现,Lua现用解析器就是同样算法:递归下降+预判/流重试)

- ``

严格来说 AST `Node` 里常量存在 `LitNode(val constant:Any): Node` ，其eval()=constant ，如果不严谨定义，如无 AddNode 而只实现 '+ 操作，通过栈判断“节点”是否需计算，就能省去所有eval()的遍历/Visitor代码


编程语言和计算器区别：支持变量、含嵌套结构 不止
变量查找、节点visit()等称为解释器开销，在RS里我们顺手消除它

## 其他选择

算符重排也可写成优化形式，等价逆波兰双栈法：

```js
```

而双栈法（自带`()`支持）一些大学会教：

```js
```

重排的还要定义 `Item=Lit|[+-]Item|'('Expr')'` 才支持括号

其他(LL,LR,函数式组合器)的做法相当于 __不可配置__ 的列表切分：

```js
```

这种做法和AST关系更近，在toy语言里必须按层次(+- 层 */ 层)写 visit 求值、先求子树值(或者边解析边执行,就无需在Eval复现解析栈了)，即便是 PEG 和 YaCC 等工具里唯一的方法，它并不适合现在含十几个算符层次的编程语言解析-你的 Eval 会写得七七八八、optab定义会写得全是套版语法

函数式 `infixl/r` 左右结合可用于读优先级，逆波兰自带此功能。 函数式组合解析器常是 `strP=str=>s=>s.startsWith(str)?[res=str,tail=s.slice(s.length)]: s` 的 return(res,tail) 形式，有办法隐藏tail的传递，这是为了更纯。 纯函数式普遍较简洁，但JS不纯函数式能更快、更短更直接。

此外还有种似是其非的排序法：

后缀链也可写成左递归形式：

```js
```

非文本的计算器长这样：

```js
calc=(s,op='')=>reduceZ(s.split(/\s*/), (acc,k)=>{let b=parseInt(k),q; if(q=isNaN(b))op=k; return q?acc: eval(acc+op+b) })
reduceZ=(a,f)=>a.slice(1).reduce(f, a[0]) //0 +1+2
//把eval(op) 缓存成(a,b)=>a+b，加个分词，就是手打计算器, 你还能用程序指针做成图灵完全的形式..草
calc("1 + 2 * 3")==9
```

语法制导编译(Attribute Grammar)就是递归树重写的拙劣模仿，因为异化解析流程为『编译原理』特有、滥用DSL“专属”语言、以想当然的做法解耦/耦合语法和语义，注定给复杂的表达式文法带来大堆重复代码，就像现代支持 f"a{1}" `${1}` 等字串内插,Kotlin嵌套/*/**/*/ 的语言里无法简单区分分词与解析，最后分词器也不得不模仿LL解析的push/pop ，对状态机(手写‘汇编’解释器)的迷信，令编译器成了100天写不完、5篇讲不清的“浪漫”，因为程序员根本没法优化一个黑箱的 lex-yacc ，只能把它们的接口再包一遍。

你会发现这些人和真正的语义不在一个世界，例如他们相信 `int a,b,c;` 里逗号是“存在”的，就好像 pegjs.org 用 _ 来跳空格而非字符流预过滤，把一个Seq模式写得七七八八一样

为此，咱可以选择自己写优化解析器。但本篇重点在遍历与执行，点到为止

## 想解析常见文法

解析器与S-exp 是不冲突的。这里不定义类似

```js
```

的Node data，只是用S表达式(嵌套列)储存，至于为啥不边解析边编译？毕竟递归下降法更适合构造AST，作为游戏还是有直观性。


