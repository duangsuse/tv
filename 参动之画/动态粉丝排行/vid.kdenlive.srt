1
00:00:01,080 --> 00:00:04,560
看起来是实时数据，其实也是由帧构成的；

2
00:00:04,830 --> 00:00:06,540
只是这里有两个时间线，

3
00:00:06,750 --> 00:00:08,730
一个刷新数据和右边的时间，

4
00:00:08,940 --> 00:00:10,860
一个负责在y轴滑动横柱；

5
00:00:11,040 --> 00:00:13,410
但利用 CSS 属性渐变后我们只需

6
00:00:13,590 --> 00:00:14,640
负责第一个

7
00:00:14,640 --> 00:00:16,770
以下引入绘制领域符号集：

8
00:00:16,980 --> 00:00:18,300
n 前缀是个数、

9
00:00:18,570 --> 00:00:20,160
w,h是宽高、

10
00:00:20,160 --> 00:00:23,910
x,y 是横纵位置、k 是比率、l 是长度

11
00:00:24,120 --> 00:00:25,170
d 是偏差量

12
00:00:25,410 --> 00:00:26,790
1帧就是1天，

13
00:00:26,790 --> 00:00:29,970
也就是把 1天变成0.3秒这样的刷新，

14
00:00:30,210 --> 00:00:31,650
这样一年也才100秒，

15
00:00:31,950 --> 00:00:33,900
当然也可 10 小时一组数据、

16
00:00:34,080 --> 00:00:35,280
帧率加倍喽

17
00:00:35,280 --> 00:00:38,400
于是我们知道数据模型是有个 Date 作 0 点，

18
00:00:38,580 --> 00:00:41,130
然后序列的内容是这行 up 粉丝数，

19
00:00:41,400 --> 00:00:44,340
我们可以生成 300 帧 10s 的伪造数据(行25)

20
00:00:44,730 --> 00:00:46,260
`{t0:new Date,

21
00:00:46,440 --> 00:00:47,190
up:ss("张三 品如 桃桃 晒干 西瓜 歪点子 五先生"),

22
00:00:47,190 --> 00:00:48,210
fols: [randA(7), randA(7), ...]}`

23
00:00:48,210 --> 00:00:51,570
但是粉丝数完全随机整个动画会混乱一团，

24
00:00:51,780 --> 00:00:53,340
我们可以假设它每天都会

25
00:00:53,520 --> 00:00:54,900
平稳波动 +-10 吧，

26
00:00:55,170 --> 00:00:57,900
如果一个<5% 的这事件在他身上发生

27
00:00:58,080 --> 00:01:00,210
就再判定一次(后有小改动)，

28
00:01:00,480 --> 00:01:01,802
然后让它接下来 20 天内

29
00:01:02,099 --> 00:01:04,019
只会2倍速加减粉怎么样？

30
00:01:05,069 --> 00:01:07,110
生成测试数据OK了。

31
00:01:07,260 --> 00:01:09,390
可这个终归是要显示给人看的，

32
00:01:09,540 --> 00:01:11,430
我们可以弄个 `div>hr[height,bgColor,

33
00:01:11,640 --> 00:01:12,090
width]` ，

34
00:01:12,090 --> 00:01:14,130
然后这个 width 显然有个最大值，

35
00:01:14,370 --> 00:01:17,970
我们就把这组up们粉丝数(此日)的最大值对应到它的最大值，

36
00:01:18,240 --> 00:01:19,350
给定粉丝数

37
00:01:19,350 --> 00:01:22,140
`n*(wMax/nMax)` 就不越界(nMax=极)，

38
00:01:22,350 --> 00:01:23,280
没问题吧

39
00:01:23,280 --> 00:01:24,090
好，

40
00:01:24,090 --> 00:01:26,310
我们把父容器宽名为 w,

41
00:01:26,550 --> 00:01:27,929
单项宽 ww ；

42
00:01:28,170 --> 00:01:29,250
这个式子也是`ww=n/nMax *w`，

43
00:01:29,730 --> 00:01:31,264
也是w大果大、

44
00:01:31,440 --> 00:01:32,790
n,Max大果小，

45
00:01:32,790 --> 00:01:34,140
数值稳定差点。

46
00:01:34,380 --> 00:01:35,880
所以你现在知道了，

47
00:01:36,000 --> 00:01:37,500
所谓编程需要的数学，

48
00:01:37,680 --> 00:01:39,780
中档层次也只是这些比率计算；

49
00:01:40,020 --> 00:01:42,690
因为程序员思考的方式和数学家根本不一样

50
00:01:42,930 --> 00:01:44,313
需要注意的是，

51
00:01:44,313 --> 00:01:46,950
上面的『帧』是指 JS 新赋值时的数据帧，

52
00:01:47,190 --> 00:01:48,690
不是绘制意义上的帧，

53
00:01:48,960 --> 00:01:50,373
等时差播放时 CSS

54
00:01:50,601 --> 00:01:53,070
会负责横柱y高度的缓动渐变

55
00:01:53,370 --> 00:01:54,300
没错，

56
00:01:54,300 --> 00:01:55,710
刚刚的想法得改一点，

57
00:01:55,890 --> 00:01:56,550
首先

58
00:01:56,550 --> 00:01:58,740
up 主们的位置不固定但颜色一定，

59
00:01:58,920 --> 00:02:00,541
就不能只利用数组位置，

60
00:02:00,690 --> 00:02:04,199
而要给他们每人一个 ID, 与颜色、粉丝数 1:1,

61
00:02:04,440 --> 00:02:06,840
就是说ID和其显示元素对应

62
00:02:07,050 --> 00:02:09,750
但如果说交换数据写入的元素

63
00:02:09,930 --> 00:02:11,220
咋弄动画渐变呢？

64
00:02:11,490 --> 00:02:13,950
于是位置也不能靠 DOM 节点列，

65
00:02:14,130 --> 00:02:17,190
因为 CSS 只能渐变 top 纵向位置属性；

66
00:02:17,460 --> 00:02:20,340
这时你会发现我们又可以令 up 主列表 []

67
00:02:20,520 --> 00:02:22,410
与 NodeList `eBars.children` 直接对应了，

68
00:02:22,650 --> 00:02:24,750
只要它顶距离 `top:0px` 手算就行

69
00:02:25,200 --> 00:02:26,880
咱不求 fols 是有序的，

70
00:02:27,150 --> 00:02:29,850
只要它的副本上 sort() 得到自己的显示索引(行37)，

71
00:02:30,030 --> 00:02:31,170
从而计算y位置；

72
00:02:31,440 --> 00:02:33,660
不就是同位元素的当前高度 `es[i].offsetTop` (行45)吗？

73
00:02:34,020 --> 00:02:35,071
不过这样第一次

74
00:02:35,280 --> 00:02:37,710
就得把布局位置变成 `position:absolute` ，

75
00:02:37,950 --> 00:02:40,590
这样更新过程中才有高度信息去交换

76
00:02:40,830 --> 00:02:44,400
这样也避免检测两个乱序单项集的索引对应关系了(行39)，

77
00:02:44,730 --> 00:02:45,659
只要一个

78
00:02:45,659 --> 00:02:47,730
x-i 的值键映射就能知道

79
00:02:48,000 --> 00:02:49,560
自身元素新 top 属性

80
00:02:50,520 --> 00:02:52,560
要注意的一点是没必要

81
00:02:52,770 --> 00:02:55,650
内嵌任何交换排序算法，它们也不能更快，

82
00:02:55,830 --> 00:02:58,440
基于每帧数据变化能做的断言太少了

83
00:02:59,040 --> 00:03:00,180
然后标尺

84
00:03:00,180 --> 00:03:02,040
一些做过绘制的人可能觉得

85
00:03:02,681 --> 00:03:07,890
要用 `x%N==0` 取余判定做，但几何就是有很多途径达到同样效果。

86
00:03:08,160 --> 00:03:09,960
我们用 `background-repeat`

87
00:03:10,170 --> 00:03:11,640
宽最小单位的像素

88
00:03:11,820 --> 00:03:13,860
`w=dMark*k`

89
00:03:13,860 --> 00:03:16,110
画个高 `lMark=2` 竖线，

90
00:03:16,410 --> 00:03:17,609
重复遍成标尺，

91
00:03:17,880 --> 00:03:19,860
那么长的刻度咋整呢？

92
00:03:20,400 --> 00:03:22,830
重复的最小单位变成N个竖线，

93
00:03:23,040 --> 00:03:23,910
最后一个是长竖线

94
00:03:23,910 --> 00:03:25,380
完事。

95
00:03:25,380 --> 00:03:26,820
呃我回看了下

96
00:03:26,940 --> 00:03:28,620
他那个的标尺是作为背景，

97
00:03:28,800 --> 00:03:29,490
没有短长刻度

98
00:03:29,490 --> 00:03:30,660
就方便了，

99
00:03:30,840 --> 00:03:32,340
下标尺只含文本啊，

100
00:03:32,550 --> 00:03:33,630
而且还带缓动；

101
00:03:33,900 --> 00:03:35,010
方法其实类似，

102
00:03:35,250 --> 00:03:36,780
每段的宽度是一致的，

103
00:03:37,020 --> 00:03:39,150
然后文本是 `dMark` 累加的内容，

104
00:03:39,420 --> 00:03:40,470
这个能理解吧。

105
00:03:42,432 --> 00:03:44,340
`ww=dMark*k`

106
00:03:44,340 --> 00:03:46,320
是从步长算画布内宽度，

107
00:03:46,680 --> 00:03:48,030
这也可以叫 `dx`(x差量,x步长)，

108
00:03:48,480 --> 00:03:50,520
计算和横柱的宽度一样，

109
00:03:51,300 --> 00:03:53,880
`/w` 是算宽度里有多少个标记；

110
00:03:54,150 --> 00:03:57,780
然后 `i*dMark` 是那一段 x 位置的起始数值，

111
00:03:58,080 --> 00:03:59,070
和当前 x

112
00:03:59,070 --> 00:04:00,360
不一样它没乘k

113
00:04:00,990 --> 00:04:03,300
然后我们用的是语义化标签，

114
00:04:03,570 --> 00:04:06,360
`hr` 内部不能有元素比如图像之类的；

115
00:04:06,600 --> 00:04:10,590
如果需要放数组里基于up编号 的一些信息，

116
00:04:10,830 --> 00:04:13,800
可以改成 `span` 然后用内插元素的方法，

117
00:04:13,980 --> 00:04:15,090
显示它的文本，

118
00:04:15,360 --> 00:04:15,960
啊比如

119
00:04:15,960 --> 00:04:16,552
`it.

120
00:04:16,552 --> 00:04:18,750
lastChild.textContent=

121
00:04:18,899 --> 00:04:20,670
粉[i]-前粉数[i];

122
00:04:20,880 --> 00:04:23,460
然后 前粉数[i]=粉[i]` 求日差

123
00:04:23,460 --> 00:04:27,000
为表示对原up的尊重我没复刻个一样的出来，

124
00:04:27,240 --> 00:04:28,710
当然我把方法都讲了，

125
00:04:28,830 --> 00:04:31,285
这东西很有趣，但我没太大兴趣。

126
00:04:31,500 --> 00:04:34,560
主要还是给大家科普了一个计算机绘制入门，

127
00:04:34,860 --> 00:04:36,964
这种很常见的自排序排行榜啊，

128
00:04:37,230 --> 00:04:38,250
其实就是个有序

129
00:04:38,449 --> 00:04:40,169
编号-y高度的对应(行29,33,45 与调用:有序新位 后首if)，

130
00:04:40,440 --> 00:04:43,170
然后要懂区分显示位置和元素列表，

131
00:04:43,410 --> 00:04:45,660
读取与设置CSS绝对位置

132
00:04:46,440 --> 00:04:48,753
祝大家天天向上喽

