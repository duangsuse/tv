1
00:00:00,090 --> 00:00:04,520
指针 `int* i=0` 代表一个
通过 `&myVar` (读作 绑定myVar)标取后

2
00:00:04,520 --> 00:00:10,110
`*i` 读写的(int的内存地址)，(*i)和局部变量没啥不同。

3
00:00:10,110 --> 00:00:12,930
0即空指针，无效悬垂指针的特例。
(如 strstr 无子串, map.find无键

4
00:00:13,140 --> 00:00:15,060
一般有效的地址数位很长，

5
00:00:15,329 --> 00:00:16,918
而 `"abc"`(只读段含字符至'\0' 的位置)

6
00:00:17,100 --> 00:00:19,620
作为 `const char*` 自然也有其地址，

7
00:00:19,830 --> 00:00:23,460
总之 但凡是数据，无论是定长数组(缓冲区)、

8
00:00:23,640 --> 00:00:29,070
增长列表还是结构里的，还是局部量全局量，都是C分配的、字节构成的，

9
00:00:29,310 --> 00:00:30,810
因此都能按地址访问。
(内存地址最小单位=字节,对齐到4的倍数)

10
00:00:31,110 --> 00:00:33,960
这是20年前C语言“革命性”指针的由来。

11
00:00:34,200 --> 00:00:37,560
当然啦，它的革命性是指能和汇编无缝交接

12
00:00:37,800 --> 00:00:38,610
可以说，

13
00:00:38,820 --> 00:00:42,240
编译器用递减sp栈指针的方式分配 局部变量，

14
00:00:42,540 --> 00:00:45,600
因为变量的本质是任意地址上独占的内存片，

15
00:00:45,840 --> 00:00:48,360
__指针更像是种暴露的内部细节

16
00:00:48,540 --> 00:00:53,250
因为CPU可以把内存里4字节当 int32 来解释，即加减乘除；

17
00:00:53,550 --> 00:00:54,690
Java 里没有指针__，

18
00:00:54,960 --> 00:00:57,990
尽管你可以单靠所谓唯一地址改写整个对象

19
00:00:58,200 --> 00:01:00,300
如new int[2]或某类Object，

20
00:01:00,480 --> 00:01:03,150
这个ID不能通过 `(int*)a [i]= *(a+sizeof(int)*i )` 加减拿到相邻项，

21
00:01:03,330 --> 00:01:05,670
`&two[1]` 的更不可能无效，

22
00:01:05,940 --> 00:01:08,880
你也不能让其他函数改写你能取到的 int ，

23
00:01:09,060 --> 00:01:11,460
除非是 C++ `f(int& a)`。

24
00:01:11,730 --> 00:01:13,830
这和值类型复制传参的无关，

25
00:01:14,100 --> 00:01:20,550
可以理解为 __C允许把内存地址当变量对待，
只要你 `&i` 取个指针它就能到处改写，

26
00:01:20,730 --> 00:01:21,780
但Java不允许__

27
00:01:21,990 --> 00:01:26,100
缓冲区溢出、输出乱码，都是由于指针越界或错位(outbounds,dangling)导致的，

28
00:01:26,340 --> 00:01:27,600
「界」是口头的说法，

29
00:01:27,840 --> 00:01:29,850
比如 char** argv 的内存

30
00:01:30,030 --> 00:01:32,430
位置有最多 argc 个 size_t ，

31
00:01:32,640 --> 00:01:36,570
不能搞 `argc=n=2,i=2 item[i] (i=0,1`  ，

32
00:01:37,020 --> 00:01:39,090
缓冲区溢出、输出乱码，都

33
00:01:39,270 --> 00:01:41,670
是由于指针越界或错位(outbounds,dangling)导致的，

34
00:01:41,850 --> 00:01:43,170
「界」是口头的说法，

35
00:01:43,410 --> 00:01:57,900
比如 char** argv 的内存最多argc个size_t
不能搞 `argc=n=2,i=2 item[i](i=0,1`  ，
C 不支持 `char* argv[argc]` “带长数组”；

36
00:01:58,080 --> 00:02:00,960
当然啦 空指针和栈溢出是没预检查，

37
00:02:01,170 --> 00:02:03,030
乱码也可能是你没初始化 `i=0;a={0}`

38
00:02:03,210 --> 00:02:04,680
内存地址=变量，

39
00:02:04,920 --> 00:02:09,990
在与汇编兼容时为兼容一些特殊硬件地址，是不可掩藏的计算机细节；

40
00:02:10,230 --> 00:02:19,560
但在今天不会有人写*"a"='a'这种代码，也没人在乎变量在堆还是栈，
是全0的全局变量 用累加内存段大小的方式分配(段:段错误和不能为READ 的)，

41
00:02:19,860 --> 00:02:21,660
其实只需像Py一样

42
00:02:21,840 --> 00:02:24,360
给 argv,environ, calloc,str

43
00:02:24,750 --> 00:02:26,790
等加个长度信息的封装，

44
00:02:27,000 --> 00:02:33,450
指针计算就变得安全统一、可迭代，也能一行内
实现strcat,bytes() 增长的功能(socket收发线编程)

45
00:02:33,660 --> 00:02:36,180
Java里局部的 `Pair(1,2)` 也可以return

46
00:02:36,390 --> 00:02:38,670
而非C局部结构体的栈上帧内，

47
00:02:38,970 --> 00:02:41,580
但这不一定需要 对象/引用根GC ，

48
00:02:41,790 --> 00:02:45,150
Rc和WeakPtr 就能解决 free() 时机的问题，

49
00:02:45,390 --> 00:02:48,480
最后利用类型系统检查引用的生命期大小，

50
00:02:48,660 --> 00:02:51,000
这也是struct/impl-fn 语言

51
00:02:51,180 --> 00:02:54,270
Rust作为系统级C++替代者的核心特性，

52
00:02:54,540 --> 00:02:56,250
不一定要new后构造器，

53
00:02:56,430 --> 00:02:58,140
计算到结构体的函数就够；

54
00:02:58,410 --> 00:03:03,840
新数据的引用是随return 而失效，还是在哪个位置既有
尽量别过问，我自己推

