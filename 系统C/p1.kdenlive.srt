1
00:00:00,120 --> 00:00:05,700
首先这里操作系统的定义绝不止一个 UI 即 `explorer.exe` 图形shell(窗口管理器+任务栏)，

2
00:00:06,060 --> 00:00:08,790
就排除了 PPTos,[98.css],

3
00:00:09,060 --> 00:00:13,380
Scratch,VB 仿桌面等可插件(统一风格窗口)界面项目

4
00:00:13,740 --> 00:00:19,350
为了这期视频我特意回溯到DOS人人裸机BIOS应用的时代看了点文，

5
00:00:19,590 --> 00:00:23,370
感觉那个时代人是处处跟自己汇编的目标 指令平台(ISA)作对、

6
00:00:23,640 --> 00:00:26,010
机器是各种不支持各种窄又废，

7
00:00:26,250 --> 00:00:27,300
比尔盖茨曾说，

8
00:00:27,480 --> 00:00:29,520
640K肯定够用一辈子了

9
00:00:29,730 --> 00:00:31,680
(那时他的对手只支持64K)，

10
00:00:31,950 --> 00:00:33,570
就像2K年的千年虫(year2k)，

11
00:00:33,840 --> 00:00:41,490
97肯定不会跳回20；那时电子晶震 CPU时钟都不会超过200kHz 但这次视频也不提太多专业知识，

12
00:00:41,700 --> 00:00:44,160
此次的『操作系统』指代80x86

13
00:00:44,370 --> 00:00:45,540
(8086的改进,

14
00:00:46,040 --> 00:00:50,550
386引入虚地址)机上和 BIOS,GRUB 一样 __运行在Ring0 ，

15
00:00:50,760 --> 00:00:54,210
被实模式应用加载的 x86 (虚地址内存)保护模式

16
00:00:54,390 --> 00:00:56,430
管理工具__，一个带Logo的 ~~VGA打字机~~，

17
00:00:56,850 --> 00:01:08,880
没错这回没有 上下文切换PCB、[IDT], [8259A中断]注册 等专业内容反正，有了你们也不会看； 就像某些企业家说是支持国产系统，其实只是想跟个风

18
00:01:09,090 --> 00:01:12,660
CPU上电后执行的第一条指令是从BIOS开始(

19
00:01:12,870 --> 00:01:18,300
嵌入式设备BL fastboot一般都是固件 单次烧写,无外置存储)，

20
00:01:18,510 --> 00:01:22,620
而BIOS会负责从软硬盘、CD搜索 按bootable2字节

21
00:01:22,856 --> 00:01:26,160
(16进)AA55魔数结尾的 1K引导代码到7c00；

22
00:01:26,580 --> 00:01:28,260
BIOS 也是有字符终端功能的，

23
00:01:28,470 --> 00:01:30,720
不然哪来配置界面，

24
00:01:30,960 --> 00:01:36,150
DOS其实就是它套了个FAT文件系统+个命令解释器 command.com

25
00:01:36,661 --> 00:01:40,800
在DOSBox我们可以访问 int 0x21 的DOS系统调用、

26
00:01:41,070 --> 00:01:47,640
BIOS中断和ivt注册、设备端口IO 和实模式1M/ DOS知名的640K内存，

27
00:01:47,940 --> 00:01:52,500
但肯定希望能在 qemu 上运行 不靠GRUB或winBootmgr，

28
00:01:52,740 --> 00:01:54,660
毕竟那才像系统(尽管也有 [multiboot] 等启动协议)，好。

29
00:01:55,350 --> 00:01:58,890
了解C代码的人肯定知道C比汇编高了二三层，

30
00:01:59,100 --> 00:02:04,860
x86机器码是没有ld-linux.so 链接器(-fpic/-fPIC)、libc、栈调用规范这些概念的，

31
00:02:05,070 --> 00:02:06,540
用C语言写[bootsect]，

32
00:02:06,720 --> 00:02:10,380
相当于 Linux 0.11 为方便自带的引导加载器(

33
00:02:10,650 --> 00:02:12,510
现在GRUB就是用它的规范)，

34
00:02:12,750 --> 00:02:18,510
用C写MBR代码并没有简写的红利且要截掉函数头部栈指针的链增，

35
00:02:18,781 --> 00:02:23,280
因此我用js简短的预处理下=;符号 由[GAS汇编]，

36
00:02:23,460 --> 00:02:30,180
免得你们要安NASM才能编译模拟运行 额谈一下现在中国这个「操作系统」「核心科技」风

37
00:02:30,450 --> 00:02:33,960
，其实它就是利用大众的国产心理 造个热度开始蹭。

38
00:02:34,230 --> 00:02:38,220
完全国内成分的有吗？__有但没人敢用，或者软件不多，

39
00:02:38,490 --> 00:02:41,850
大部分原创的如 Deepin,Remix/Androidx86,Fyde 也有，

40
00:02:42,030 --> 00:02:46,170
但叫的不可能有那些魔改开源Logo 卖钱的中标麒麟一流响的__，

41
00:02:46,410 --> 00:02:47,880
哦，是中标(投标)麒麟

42
00:02:48,120 --> 00:02:49,560
说白了就是应用层蹭

43
00:02:49,800 --> 00:02:52,050
真正系统工程侧的叫好不叫坐，

44
00:02:52,320 --> 00:02:56,790
那努力自我提升的心不知有多少，但想以小投入搏大眼球的、

45
00:02:56,970 --> 00:02:58,980
至少赚波人气的 心态是绝对有。

46
00:02:59,460 --> 00:03:01,080
你要想真做做不出？

47
00:03:01,440 --> 00:03:06,413
其实是没思考怎么招人，以及这个最后有多少前景，回报得>投资啊，

48
00:03:06,660 --> 00:03:08,820
人家是营利不是慈善性质啊；（划重点）

49
00:03:09,060 --> 00:03:10,980
不是啥帝国主义技术封锁，

50
00:03:11,160 --> 00:03:12,900
那不有台积电有龙芯吗？

51
00:03:13,080 --> 00:03:14,430
经济不投缘罢了。

52
00:03:14,610 --> 00:03:18,660
叫了这么久背后兢兢业业提供 存储、传感器、屏幕 的半导体业、

53
00:03:18,870 --> 00:03:21,600
机器码解释器 有人出来跟风吗？没有，

54
00:03:21,780 --> 00:03:24,660
因为踏踏实实研究的人，没空呼喊那些口号。

55
00:03:24,930 --> 00:03:26,790
毕竟想推进，只有用手，

56
00:03:26,970 --> 00:03:29,010
而不是爱闲话好否定的嘴。

57
00:03:29,430 --> 00:03:31,830
真正意义的『操作系统内核』三要素：

58
00:03:32,100 --> 00:03:34,590
__线程调度内存隔离、文件设备(fat32,ext4,IRQ)、

59
00:03:34,770 --> 00:03:36,450
IP网络和并发工具(IPC,sem,mutex)__

60
00:03:37,290 --> 00:03:41,460
如果一个人写了线程池或malloc()或ELF文件链接器，

61
00:03:41,670 --> 00:03:44,940
声称自己写了操作系统 是可以的(比如GNU is !UNIX)；

62
00:03:45,120 --> 00:03:46,350
如果一个人在

63
00:03:46,619 --> 00:03:51,090
磁盘MBR写了 内核特权级，就是不用DOS功能的DOS程序

64
00:03:51,330 --> 00:04:03,480
，或者做了几个统一风格UI，声称自己写了操作系统 是不好的； 这是我对此领域的认知。只有一个开发者对目标『应用』 所有的(语言)API所需的字节结构，有层次清晰的认知，

65
00:04:03,690 --> 00:04:07,230
随便举一个过程他都能清楚这对『裸机』上有几段操作，

66
00:04:07,440 --> 00:04:09,180
他才有资格谈『操作系统』；

67
00:04:09,390 --> 00:04:10,230
简单点说，

68
00:04:10,440 --> 00:04:12,750
就是他能从C代码看到对应汇编

69
00:04:13,260 --> 00:04:15,960
只觉得操作系统 内核是核心技术的人，

70
00:04:16,140 --> 00:04:17,970
若作为一个框架下程序员或运维，

71
00:04:18,180 --> 00:04:19,680
没有资格提『内核』这个词，

72
00:04:19,920 --> 00:04:20,910
__因为无论什么内核

73
00:04:21,089 --> 00:04:25,080
你们的代码都能兼容，它对你只是编译参数里的名字而已。__

74
00:04:25,410 --> 00:04:32,760
曾站在比POSIX更低的地方，却能清晰看见应用之高 所需的硬件状态和文件管道等资源共享，

75
00:04:32,970 --> 00:04:35,730
堆砌着脚下基石 却看清更高的目的(GCC)，

76
00:04:35,940 --> 00:04:38,999
这是系统级程序员的基本功。说难也不难。

77
00:04:39,210 --> 00:04:43,260
Linux没有一行代码、一个数值是靠删改重试猜出来的。

78
00:04:43,470 --> 00:04:45,060
如果有，会被Linus骂：

79
00:04:45,330 --> 00:04:49,410
要么理论验证，要么请上千万台各类设备帮你实机验证。

80
00:04:49,741 --> 00:04:57,600
应用层会想一个功能最少需要几行代码来定义吗？

81
00:04:57,810 --> 00:04:59,701
内核在 Linux 上 vmlinuz 是 ELF 格式可执行 由GRUB,syslinux ，

82
00:05:00,060 --> 00:05:04,470
在 Win32 是 sys32/ntoskrnl.exe 由bootmgr，

83
00:05:04,680 --> 00:05:06,360
都是自己家的可执行格式

84
00:05:06,630 --> 00:05:08,550
(反正就是存代码和数据节,

85
00:05:08,789 --> 00:05:10,680
加载到内存的节section称段segment)，

86
00:05:10,950 --> 00:05:17,760
它们把裸机键鼠视频、内存、CPU多核， 虚拟化出 stdIO流、framebuffer v4l2

87
00:05:17,940 --> 00:05:20,669
、mmap,brk/sbrk、

88
00:05:20,880 --> 00:05:22,230
execve(argv,env)

89
00:05:22,470 --> 00:05:24,840
与pthread 等统一API，

90
00:05:25,170 --> 00:05:29,130
内核初始化后只有调度器是每CPU上总在执行的

91
00:05:29,520 --> 00:05:31,590
__也就是说系统内核不是服务，

92
00:05:31,770 --> 00:05:33,360
而更像一个有特权的库__，它

93
00:05:33,630 --> 00:05:34,860
最必要任务是：

94
00:05:35,190 --> 00:05:37,620
这个进程你做1ms了先暂停，

95
00:05:37,920 --> 00:05:39,720
那个更nice 的你恢复执行，

96
00:05:39,990 --> 00:05:43,320
求我从 openat("/etc/shadow") 写到你的内存片？

97
00:05:43,530 --> 00:05:44,940
你uid权限不够。

98
00:05:45,180 --> 00:05:46,920
求我从你的内存写到 pipe(23) ，

99
00:05:47,100 --> 00:05:49,890
我把它复制到内核堆；暂停再换进程，

100
00:05:50,130 --> 00:05:51,720
要从 pipe(23) read()数据？

101
00:05:52,290 --> 00:05:54,360
process_vm_writev 给你。

102
00:05:55,110 --> 00:05:56,610
进程、线程、函数协程，

103
00:05:56,790 --> 00:05:58,830
不同隔离度的任务(读写,网络,等待输入..)并发执行

104
00:05:59,100 --> 00:06:02,070
以上是虚拟终端执行 `cat

105
00:06:02,370 --> 00:06:03,840
/etc/shadow` stderr_fd=2 "权限不够"

106
00:06:04,199 --> 00:06:05,250
显示到终端窗口的过程

107
00:06:05,520 --> 00:06:08,790
你觉得 `int32_t i; i+=1;

108
00:06:09,000 --> 00:06:11,580
i-=1; print(i)` 代表三个什么？

109
00:06:11,880 --> 00:06:16,950
i是内存片4字节的独占空间，3动作有先后顺序，语义就正确。

110
00:06:17,220 --> 00:06:18,240
所以我 `for(;;)sleep(1);`

111
00:06:18,420 --> 00:06:21,150
会不会卡死整个电脑？DOS 里会的，

112
00:06:21,420 --> 00:06:24,780
但CPU上调度器能抢占时间片结束的死循环，

113
00:06:25,020 --> 00:06:26,823
保存现场，

114
00:06:27,150 --> 00:06:28,500
切换到其他任务，

115
00:06:28,680 --> 00:06:31,200
看起来就像同时有多任务在执行一样，

116
00:06:31,470 --> 00:06:34,710
async协程、Promise闭包都是一个道理：

117
00:06:34,980 --> 00:06:36,720
任务能暂停等待唤醒

118
00:06:36,960 --> 00:06:40,920
调度是以线程为单位的，分用户内存和文件才有进程，

119
00:06:41,130 --> 00:06:44,400
但大部分应用只有主线程 很多人不区分这个，

120
00:06:44,640 --> 00:06:50,220
所以他们也不知道 __onclick listen 啥的只是注册了一个函数让系统主循环能访问到，

121
00:06:50,460 --> 00:06:52,170
完整的UI是要响应交互-

122
00:06:52,410 --> 00:06:55,230
重绘的__，你的应用只定义了控件显示内容

123
00:06:55,410 --> 00:06:57,930
像内存对象回收就需要GC或Rc，

124
00:06:58,140 --> 00:07:01,290
你不需要考虑内核眼你应用的进程由啥构成，

125
00:07:01,560 --> 00:07:03,330
布局渲染啦垃圾回收啦，

126
00:07:03,540 --> 00:07:06,390
只要用户点哪里 啥变化，这叫应用层程序员思维。

127
00:07:06,660 --> 00:07:11,670
写内核是裸机应用，从x86平台已有的实现你应用需要的，

128
00:07:11,910 --> 00:07:17,520
不是从你写过一两个 Java的C++Qt 复用高的软件猜内核会咋样高难度

129
00:07:17,730 --> 00:07:24,870
，不敢想呢；无论是应用还是系统编程， 编程就只是从基本结构有技巧的堆出能用的程序，

130
00:07:25,140 --> 00:07:27,510
想做出想简化，永远有方法，

131
00:07:27,870 --> 00:07:29,100
只是这资料可难得找，

132
00:07:29,317 --> 00:07:33,240
如果你从没离开过国内的『互联网』也不爱读书，劝退吧。

133
00:07:33,480 --> 00:07:37,591
操作系统是由核心态设备事件IO+用户态 libc、

134
00:07:38,220 --> 00:07:41,190
init服务、交互shell、用户App 组成的，

135
00:07:41,430 --> 00:07:43,350
当然也可以像 ChromeOS 那样

136
00:07:43,530 --> 00:07:48,210
不需DBus,getty 等服务run-command

137
00:07:48,480 --> 00:07:50,190
靠另一个完善的

138
00:07:50,400 --> 00:07:53,160
用户级系统和Web应用取代shell界面 了

139
00:07:53,880 --> 00:08:05,490
连自己的代码被转化到含哪些信息的『可执行』或怎样注册表流程的『安装包』， 再以哪种方式加载执行都不知道，有什么底气谈操作系统这个宏大的软件、算法集合？

140
00:08:07,410 --> 00:08:11,250
这个box提供了设置/树和外设的shell脚本，

141
00:08:11,430 --> 00:08:14,010
靠启动进程最终达到设备日用目的，

142
00:08:14,220 --> 00:08:16,530
它还是要 libc.so dll库，

143
00:08:16,710 --> 00:08:18,600
加载动态链接才能执行的，

144
00:08:18,810 --> 00:08:25,320
所以说对程序对应的数据不了解，或者说不懂汇编 很难理解系统和用户程序 概念性的区别，

145
00:08:25,560 --> 00:08:27,960
__系统所代表的ABI

146
00:08:28,140 --> 00:08:30,030
并非只是内核的不同__。

147
00:08:30,330 --> 00:08:32,490
可以说所有内核功能和argv,

148
00:08:32,669 --> 00:08:35,370
environ等通用ABI定义都是为应用，

149
00:08:35,549 --> 00:08:37,350
或它们依赖的服务及设备

150
00:08:37,558 --> 00:08:42,090
比如DBus,Xorg ,strace调试器,ip addr 服务的，

151
00:08:42,360 --> 00:08:45,870
但内核的目的性只是把计算机的算力、内存外存、

152
00:08:46,050 --> 00:08:48,450
外设以更简单安全的方式让人利用，

153
00:08:48,630 --> 00:08:49,680
就像chroot ，

154
00:08:49,949 --> 00:08:51,420
它是一种统一底层

155
00:08:51,630 --> 00:08:52,650
硬件的虚拟化，(从单核模拟多核

156
00:08:52,830 --> 00:08:55,230
它源码、模组的层次是为这服务

157
00:08:55,560 --> 00:08:56,430
这都是理论

158
00:08:56,670 --> 00:08:59,130
因为只有看清楚软件是为了什么而用，

159
00:08:59,310 --> 00:09:00,510
开发者才不会止于复制。

160
00:09:00,717 --> 00:09:06,870
对libc(kernel32,user32)而言系统真正的 API 是 syscall列表+main入口的栈/寄存器，

161
00:09:07,230 --> 00:09:10,200
对C语言系统API是stdlib,

162
00:09:10,470 --> 00:09:15,630
以 CDEF等C调用规定 和动态链接linker (仅编译器可见)

163
00:09:15,870 --> 00:09:16,948
并称为 ABI， (系统上第0个SDK, 不止于API

164
00:09:17,280 --> 00:09:19,919
如 glibc,msvc,

165
00:09:20,189 --> 00:09:26,670
musl,bionic 等内核功能的封装和 malloc 堆等只需用户态资源的算法

