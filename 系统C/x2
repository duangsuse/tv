指针 `int* i=0` 代表
一个通过 `&myVar` (读作 绑定myVar)标取后 
`*i` 读写的(int的内存地址)，`*i` 和局部变量没啥不同。
0即空指针，无效悬垂指针的特例。
一般有效的地址数位很长，
而 `"abc"` 
作为 `const char*` (只读段含字符至'\0' 的位置)自然也有其地址，
总之 但凡是数据，无
论
是定长数组(缓冲区)、
增长列表还是结构里的，还是局部量全局量，都是C分配的、字节构成的，
因此都能按地址访问。
这是20年前C语言“革命性”指针的由来。
当然啦，它的革命性是指能和汇编无缝交接
可以说，
编译器用递减sp栈指针的方式分配 局部变量，
因为变量的本质是任意地址上独占的内存片，
__指针更像是种暴露的内部细节 
因为CPU可以把内存里4字节当 int32 来解释，
即加减乘除；
Java 里没有指针__，
尽管你可以单靠所谓唯一地址改写整个对象
如int[]或某类Object，
这个ID不能通过 `(int*)a [i]= *(a+sizeof(int)*i )` 加减拿到相邻项，
`&two[1]` 的更不可能无效，
你也不能让其他函数改写你能取到的 int ，
除非是 C++ `f(int& a)`。
这和值类型复制传参的无关，
可以理解为 __C允许把内存地址当变量对待，只要你 `&i` 取个指针它就能到处改写，
但Java不允许__
缓冲区溢出、输出乱码，都是由于指针越界或错位(outbounds,dangling)导致的，
「界」是口头的说法，
比如 char** argv 的内存
位置有最多 argc 个 size_t ，
不能搞 `argc=n=2,i=2 item[i] (i=0,1`  ，
C 不支持 `char* argv[argc]` “带长数组”；
缓冲区溢出、输出乱码，都
是由于指针越界或错位(outbounds,dangling)导致的，
「界」是口头的说法，
比如 char** argv 的内存
不能搞 `argc=
n=2,
i=2 item[i]
 (i=0,1`  ，
当然啦 空指针和
栈溢出是没预检查，
乱码也可能是你没初始化 `i=0;a={0}`
内存地址=变量，
在与汇编兼容时为兼容一些特殊硬件地址，是不可掩藏的计算机细节；
但在今天不会有人写 `*"a\0"=='a'` 这种代码，也没人在乎变量在堆还是栈，是全0的全局变量 用累加内存段大小的方式分配(段:段错误和不能为READ 的)，
其实只需像Py一样
给 argv,environ, calloc,str 
等加个长度信息的封装，
指针计算就变得安全统一、可迭代，也能一行内
实现strcat,
bytes() 增长的功能
Java里局部的 `Pair(1,2)` 也可以return 
而非C局部结构体的栈上帧内，
但这不一定需要 对象/引用根GC ，
Rc和WeakPtr 就能解决 free() 时机的问题，
最后利用类型系统检查引用的生命期大小，
这也是struct/impl-fn 语言
Rust作为系统级
C++替代者的核心特性，
不一定要new后构造器，
计算到结构体的函数就够；
新数据的引用是随return 而失效，还是在哪个位置既有 尽量别过问，我自己推
