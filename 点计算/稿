

如果给你两点 p0 和 p1 ，怎么在宽高wh的像素图上画线?

求黑色的点集，或者说哪些点是在直线内的

求 xy 距离 lx,ly 算 ly/lx 求 dy 再迭代 x , 理:这隐含 dx=1, 是利用 y=kx, 也是最大公约数 gcd(lx,ly) (低精度)

假设p0是只乌龟，角度r ，它爬行距离l 后在哪点

旋行成花、N角形 走l&转360/N

指针太阳系: d=0~360, l固定 多个步进l的环路径

Koch star, 赵爽弦图

果冻状的树: 每点 dep<n_dep时 分叉n 子点, 长l,角d 往返 也改变其p0点; 嗯再加个变色

你可能觉得只用 CSS rotate(90deg) 或 SVG 就行了干嘛要靠向量计算？
rotate 并不能让你知道一个线段、一个正方形某端点的新位置，如果你要在那个地方再放啥咋办？
CSS 也不能给对象提供加速度(velocity)，它能做的极点就是固定路径固定时长快慢曲线，定时曲线不是游戏的全部

附:走l&转N-i 螺纹、箭头、重复走/转递减 螺纹成花

理:d_xy 和 k_xy: 人造绘制滚动缩放/CSS overflow

plusRL(r,l) (r cos l,r sin l)
rad(d) d*PI/180

如果我们有个 p0, 然后有它的方向, 怎么求它方向与 p1 的相对角度？ (然后这里角度就是 p1-p0, 各自xy相减)

听起来很奇怪，点有方向、角度是两个数？其实这个方向和点本身是分开算的，它像物理上的力一样，是从相对的基(0,0)到点(x,y)，有角度有长度。

接下来的内容我不保证准确。我是完全不懂数学，公式都是抄的，大家可以自己画图推啊。

既然咱是把零点给抽象成任意p0点，刚才 plusRL 的式子就可以变一下，你看这 + 是xy都有的，是不是说它是p0?

刚才谈了点长->点，很有趣，现在是点点角

第三次到数学系找到了答案，不妨试一下就知道这个相对角度对不对

基于我抄来的优化角度增量公式

有个程序我比较好奇，就是我能照鼠标位置画个直线，但如果我想它长于鼠标咋办？

鼠标XY可视作相对(0,0) 的向量，所以直接创建向量然后 dup.l+ 一下就算出 p2 了，它简化计算的能力不错吧。

但是我想要始于 a 点到鼠标的射线，这又咋整？ 把a视作(0,0)点，这时你就发现，它左边的东西得减去。所以 p-a 就行,取长度和原来一样

假设我是在做游戏，玩家用只键盘选中怪物 我要瞄准它怎么办？把它的位置就当作鼠标位置给这个程序！



初始方向0, 那咱试试让一个长l直线朝向鼠标指针，点点长

然后它面向 pApple 时提示下

点的一种编码,自然数与链表

以角度去计算一切很直观，但利用距离差 pd, 给出 p0 你除了能知道角度更能直接算出 p1, 是说长度也有了

初中数学「向量相等是角度和距离相等，不意味点相等」是这个意思,对它p0可以是任何点

当我们谈「点」，其实说的是点最符合人类直觉的形式
当我们需要点，只是需要它上面的角度计算、绘制输出方法，而不是强制点一定要有 xy

如果我们能求形状的交集,即碰撞检测，也能做按键控制绑定之类、音效播放的东西，实际上就是设计出游戏了

Canvas: g.moveTo(x,y)&g.lineTo(x1,y1); g.rotate(r)&g.lineTo(0,l)
距离都是 px 像素单位

参考:asteroids,lines,Worm curve
向量点乘是积之和,可求平行状态、normalize是与距离之商,可缩数值、叉乘是(AB排除当前位积的相减, )垂直于AB, 可求A-B的各轴扭距,必须有三项才可计算

---花絮

向量就是可能是点也可能是方向,甚至速度的(x,y)二元组:半对!，它是一种便捷计算方式，就像刚才的 plusLR( 里 现在 r,l 都可调差了

物理/数学向量，不是民科版C++的那个vector ，是各种小型游戏必要的精灵绘制位置大小计算

给你p0,p1 ,它们之间长l的线末点在哪

给p0,p1 求其 r? xy差&arctan ; plusRL(p0, relR(p0,p1), dist(p0,p1))=p1

刚才我说的向量本质上和(x,y)一样啊？就是操作不一样。向量是点和距离差(角度)的结合:错!；刚才你直接看定义不易理解其实是因为那个操作方式杂和,不太严谨

回到最初 p0+r 与 p1 相对角度的问题，它的结果仍是二元组

向量的世界里只有距离，没有 0~60 度的角度

不过这个方法却不能去枚举角度:错!，只能计算和差；要枚举相当于生成 dir 向量, 和点一乘, 精度不太好

addDrag=e=>{
  onMov(e, (x,y)=>_qMv?movXY(e,x,y) :0, isDown=>{_qMv=isDown})
},
onMov=(e,f,f_doup)=>{
  _mv.set(e,f);
  e.onpointerdown=ev=>f_doup(true, ev);e.onpointerup=ev=>f_doup(false, ev);
},_mv=new Map//免内存泄漏
_qMv=0
doc.onpointermove=ev=>{let f; if((ev.target!=doc||_qMv)&& (f=_mv.get(ev.target))) f(ev.clientX,ev.clientY,ev);}
