大家好，这里是动苏

很抱歉这期视频以幻灯片形式提供，本期数学性话题应用弱比较冷门，
加上对曼德博分形参考的两篇文都有小偏差，以及临时从向量计算叉出的动机，
作者有点心累，内容继承了一些混乱也没梳理干净，对整体算法感兴趣请在我 GitHub 的 /tv 项目找

这是一期彩蛋，但还是和图形学相关啦，这期你可能看到……
向量计算的同学可能要看下一期，因为游戏专题独立可能更吸引人一些，我会对2D上相对角、点乘的公式做些科普。

你应该看过 P2 了吧？如果没有去看看，七夕节动苏家限定

把搜索程序前加个 async ，它就变成一个可暂停执行的异步，然后它可以在一个像素画后暂停给系统，先把这次刷新到屏幕，再去继续搜索

咱来看看 BFS,DFS 的区别，这就很直观了，然后 DFS 时 LRUD 顺序、选项可调，就

有认真看上一P的人会发现在第N张的说法有点妙，说「反正肯定有很多画重叠的点」，那么明知会重叠咋还要画呢？

一些人可能觉得不行啊，对函数性质的分析不够细，支持不了按屏幕点的画法，其实我们知道 f 也知道它的定义x域、值y域，有啥不可以的

复习下我们虽然知道要枚举的域，但xy都是那个函数，而我们的画布显然是呈现那个区间内的状态 而不是相对(0,0)点的状态，所以有 kx=w /(x1-x0) 设定域到画布的拉伸比率，然后 x,y 自然也都是相对于区间0点的

嗯，我们把它独立出来。这个是 P(px,py) 域到画布域 fillRect(x,y) 的映射，推出它的反函数就能把枚举对象变成屏幕域的点。

f(Px= x0+x/kx, Py= y0+y/ky)

但是，真这么简单？其实屏幕的一个点不相当于函数的一个点，我们知道像素是可数的整数,比如 1920x1080 宽x高 ，而函数是浮点世界的，0.1~1 和 1.0~100 之间的数字一样多，都是无限个

所以 scan() 有个 d即step 参数，越细图像缺口越小；而应用新分块搜索算法后越细图像越粗但越快呃，符合缩略图算法

当我们迭代xy时，求 x+1, y+1 的P位置，从而得到这个像素的 P 范围，靠它去搜索。

你可能好奇这和直接迭代函数域有啥区别，毕竟它们的问题集都是一样大小，但请看这个： [0,0,1].reduce((a,b)=>a&&b, 0) , 0&&0&&1

有区别吗？如果 && 的计算开销很大，那么还真有。reduce 是 100% 计算完整个输入的，它不知道第一个 false 出现时再&&也不变了；这实际给答案搜索进行了第一步的分块，如果迭代的第一个 Px 已经很靠近正解，那这个像素的所有P都可以直接跳过了。

试一试，嘛好像也没有快多少，毕竟这也是耗光了整个搜索空间。

不过你应该能注意到一个细节，就是心形函数有大量中空的部分，能不能把这部分检测出来、排除掉？

我们来实现下这个四块细分算法。

《我不会讲》（啊！！

程序有 P0,P1 左下右上构成一个矩形区域，它的中线 y向 y0+ y1-y0/2 啊很简单

用中线把它均分成四个矩形，比如这里左上块四边没有碰到任何解(也就是函数线)，它直接断言内部没有图像；右上有那就细分，直到宽或高 <=2 像素只搜四边即可，中间也会排除大量的像素区间啊

然后这四个矩形的 P0,P1 左含右无区间 按阅读序分别是 (x0,yC)~(xC,y1) (xC,yC)~(x1,y1) (x0,y0)~(xC,yC) (xC,y0)~(x1,yC)

1.若框的 LTRD 边 (x0,y0)~(x0,y1) (x0,y1)~(x1,y1) (x1,y0)~(x1,y1) (x0,y0)~(x1,y0) 按步长没搜到任何解，回
  a. 若框 x0+1=x1 即x长=1 ，或y，直接枚举y或x；是考虑到 2*3 或 3*2 的矩形四分时优化
2.若框面积<4，回
3.计算 xC,yC 并对四个矩形应用步骤一

很大一部分是在定义搜索顺序，绘制的部分是搜索到解时顺带画了

听懂的人应该会奇怪，那按顶层图像手填的区间搜四边都碰不上，是不是该直接线替子矩形检测一遍，其实也可以(毕竟初次调用不可能是基线情况,这样基线变预判也行)但是切分太麻烦，四个矩形16条边你试试

那就对输入预先搜索其x,y域，当然函数性质有很多，另设一个能同时解决心形和|x|=|y|的方法麻烦，我们可以做个类似的，先让四分法检查一遍外围，否则，从横纵向中点同时扫描xy极值，这不就优雅了吗。

这个初次扫描有点复杂，显然心形函数纵中点并不是最大值，那它的结果其实要尾随 y 已知, x 两边的扫描，直到 y 无解 y-d 就是图形的 y1 ，y0, x1 x0 同理

解决两个简单问题比解决一个复杂问题更容易，且更具扩展力；即便初次扫描很麻烦，它也是较有普适性的。

设想下y上下、x左右的中点，两边各有两条线一起增长扫向这颗爱心，大有十字准星之势，然后能得到 x,y 的最小最大值

可这还有个，就是x中点并不是心形函数的y最大值，它的最大值在两边；怎么办？

把这个 minMax 扫描称为 xl(y), yl(x) ，前者是某横行的 x 区间，然后咱先 yl(x_mid) ，对所得y区间分出向上,向下两个 xl ，当它们的两边没有相撞，y移动 step 直到检测到 y 边界，x 方向同理

四分绘制、十字区间搜索这两个扫描算法针对单独闭合图形和内部图形

整理下你会发现，是不是刚才 BFS 填色算法也可以用四分思路优化？

这个程序的区别是，在点检测时它直接从图像数据拿值，在空块时原版直接忽略而它顺路填个色；程序直接从整个画布区域起手

于是咱重构下四分法，加两个参数函数

抱歉，骗你的。bfs 的目的是检测点在的封闭图形，所以分块只能做到按块而非像素去 BFS ，而且这个按块法取四邻还挺麻烦，不能直接把白块都填了，不然外面的也填了。

- 为啥不能用 BFS 顺藤摸瓜式搜索隐函数？
因为它要知道图形边的某点也不简单，而且它不能处理内部图像
- 速度没变快？
0.1 级别的步长暴力搜索也不慢，或许是画布太小；算法复杂度只有量大才可见
- 和整体 scan 法结果差别大？
如果确定所画函数及参数一致，可能是一屏幕像素对应视口区间某部分内步长d的多个点，而你没实现这个
建议方法是视口移动创建2D数组缓存，这样线性、极值、四分扫描都可以复用到，而且生成时可以 X0=X1,Y0=a[y-1][x][kY1=3] 避免重复计算



Mandelbrot 集和 Julia 集

它们虽然是复数(complex) C=x+iy 上的问题，但用2D系也可以输进去，就是说给你(x,y)你可以有限次的迭代许多次，判断这个点的热率是多少，在不在 <2 的区间内，在就是集中的数；当然我不知道有没有优化掉每像素迭代的方法

M0 = (0,0i)
Mn = Mn-1 ^2 + C
也即 M[i+1]=Mi^2+ C
Julia 集迭代规则相同，直接在 C 上迭代

实际迭代过程是 (xx-yy +Px, 2xy +Py) 直到 xx+yy>=4 ；当然也可以是 sqrt(xx+yy)<2 这个是复数mod,理论性好点
即 t=xy; x=xx-yy+Px; y=2xt +Py ，毕竟 ii=(-1) mo?
Julia 的可简化成 x1=xx-yy+Px; y=2xy +Py; x=x1 ，没 M0

这个看了四个实现，旧值保存和命名、求和还是 += 上会有差异，但公式不变。

当然迭代太多次肯定是会超过的，所以只记<5 的次数就够了

迭代计数出来，看看是迭代终止的百分之几，换成 hsl(0,100%,N%) 空间的颜色值，就成了经典 Mandelbrot 分形。

从热率到颜色也可以自定义256色渐变调色板，生成方式是 RGB 各有0点如(2,16,0) 然后在某一点(<256)前某个通道(R,G,B)会有步增如(64,128,192)

色版的话也是 a[百分比*长a] ，因为之前是取 i/N 不可能 100% 嘛；不在集内黑色

当然这个画布的 x,y 也是可以加上个 vp_xy=[0,0] 然后有个 k_xy=[1,1] 函数是稳定可分的，就变成了可滚动缩放的图形浏览窗。

理论参考

https://one.xecades.xyz/%F0%9F%92%BB%20Projects/Mandelbrot/Mandelbrot.cpp
https://slicker.me/fractals/fractals.htm animate.htm
https://rembound.com/articles/drawing-mandelbrot-fractals-with-html5-canvas-and-javascript
